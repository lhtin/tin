# 依赖注入简介

## 理论

简单来说，依赖注入是一种降低代码之间的耦合度，提高代码的灵活性的编程方法。事情是这样子的：

我们编程都是从“Hello World”开始，但它不会永远停留在“Hello World”，它会变得越来越复杂。为了能够掌控程序的复杂，我们引进了模块化。模块化的目的是切分复杂，带来的问题是需要考虑代码之间的合作问题（不只是多人之间的代码，还有自己写的代码之间的合作问题）。合作意味着依赖，比如模块A依赖模块B提供的功能。具体到面向对象编程就是对象A里面，需要使用到对象B的实例。

现在问题来了，对象B的实例化是在对象A里面实例化呢，还是先实例化，再将实例化后的实例当参数传给对象A呢？如果实例化的方式不变，当然在对象A里面实例化最好了，因为使用对象A的程序员不需要关注对象A还依赖了对象B。可是呢，需求总是在变化。如果哪天对象B改变了，它在实例化的时候要求添加一个参数，这下对象A就傻了。因为需要将对象B实例化的代码做更改，这相当于A限制了B的改变（不能只修改B，还要考虑到A）。

那就选择将对象B的实例当参数传给对象A吧（解决问题的一种方法），这样对象A就不需要知道对象B是如何实例化的了（**题外话，对象B依然需要保证提供的服务方式不变或者说暴露的接口不变**）。这种将依赖的引入从使用者的代码中分离出来，交由框架管理的技术叫做**控制反转**（Inversion of Control）。OK，这里有两种方式将对象B的实例传给对象A。一种是对象A先声明依赖了哪些对象，框架根据声明去实例化这些对象并传给A。另外一种是对象A在需要的时候自己去问框架，框架返回A所依赖的对象B的实例。

这两种方式都是**把对象的实例化的问题交由一个依赖管理框架**。第一种方式叫**依赖注入**（Dependency Injection），第二种方式叫**依赖查找**（Dependency Lookup）。这两者的区别在于框架把依赖注入给对象，还是对象主动查找需要的依赖。

不管用没用控制反转，代码需要做的事情是一样都不少，控制反转只是将这种实例化的工作交给了代码而不是开发者。因为交给了代码来做，与代码的交互只能变的固定了（比如声明依赖的方式）。**有了控制反转的好处是对象B的修改升级只需考虑对象B和依赖框架**。

### 参考文章

1. 依赖注入（[https://github.com/android-cn/blog/tree/master/java/dependency-injection](https://github.com/android-cn/blog/tree/master/java/dependency-injection)）
2. 控制反转（[https://zh.wikipedia.org/wiki/控制反转](https://zh.wikipedia.org/wiki/控制反转)）

## ES5实现一个依赖注入小框架

之前一篇文章从原理上介绍了依赖注入这个概念（文章名称：依赖注入简介）。为了更好的理解，本文通过ES5的代码实现一个依赖注入小框架，它叫做`DI`，它提供了`register`方法来注册服务，`inject`方法来注入服务，`lookup`方法来查找服务。先从这个小框架的使用方式开始：

```js

// 定义了一个常值服务
var con = 0;

// 定义了一个函数服务
var fun = function (n) {
    // 查找con服务
    var con = DI.lookup('con');

    return con;
}

// 定义了一个类（对象）服务
function A () {
    // 注入con和fun服务给A
    DI.inject(this, [
        'c: con',
        'f: fun'
    ]);

    this.sum = this.f(this.c);
}
A.prototype = {
    getSum: function () {
        this.sum += 1;
        return this.sum;
    }
}

// 注册到框架中
DI.register('con', {type: DI.CONSTANT, value: con});
DI.register('fun', {type: DI.FUNCTION, value: fun});
DI.register('A', {type: DI.CLASS, value: A});

function B () {
    // 注入A的一个实例给B
    DI.inject(this, [
        'a: A'
    ]);

    console.log('B: ' + this.a.getSum());
}
function C () {
    // 注入A的一个实例给C
    DI.inject(this, [
        'a: A'
    ]);

    console.log('C: ' + this.a.getSum());
}
function D () {
    // 注入A的一个实例给D，A类前面一个加号表示单独拥有一个A的实例
    DI.inject(this, [
        'a: +A'
    ]);

    console.log('D: ' + this.a.getSum());
}

var b = new B(),
    c = new C(),
    d = new D();
```

输出：

```js
B: 1
C: 2
D: 1
```

先介绍下语法：

- `c: con`表示依赖于`con`这个服务，并命名为`c`
- `a: +A`表示依赖并独享`A`这个服务的实例，并命名为`a`

从上面的代码可以发现D是独享一个A的实例（输出1），而B和C共享了一个实例（先输出1，然后累加输出2）。上面的示例代码已经演示完了这个`DI`小框架的所有用法了，那么它是如何实现这个功能的呢，且看下面的代码。

小框架`DI`的源码：

```js

var DI = (function () {

    // 定义服务类型
    var CLASS = 1, // 类（对象）
        CONSTANT = 2, // 常值
        FUNCTION = 3; // 函数

    // 存放注册的服务们
    var services = {};

    // 存放共享的实例
    var instances = {};

    var getNew = function (name) {
        var service = services[name];
        switch (service.type) {
            case CLASS:
                return new service.value();
            case CONSTANT:
                return service.value;
            case FUNCTION:
                return service.value;
        }
    };

    var getOne = function (name) {
        if (name[0] === '+') {

            // 单独享用一个实例，直接方法
            return getNew(name.slice(1));
        } else if (typeof instances[name] === 'undefined') {

            // 把共享的实例存起来
            instances[name] = {
                value: getNew(name)
            };
            return instances[name].value;
        } else {
            return instances[name].value;
        }
    }

    return {
        CLASS: CLASS,
        CONSTANT: CONSTANT,
        FUNCTION: FUNCTION,

        // 向依赖框架注册一个服务（可被依赖）
        register: function (name, service) {
            services[name] = service;
        },

        // 注入依赖
        inject: function (self, names) {
            names.map(function (name) {
                var temp = name.split(':');
                self[temp[0].trim()] = getOne(temp[1].trim());
            })
        },

        // 查找依赖
        lookup: function (name) {
            return getOne(name);
        }
    }

})();
```

是不是觉得很简单。其实就是用一个对象来管理这些依赖，如果没有实例，它就去生成一个，如果想独享一个实例，它就去实例化一个新的实例。