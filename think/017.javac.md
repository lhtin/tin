# javac 学习笔记

## 源码下载

下载工具：[Mercurial](https://www.mercurial-scm.org)

brew 安装：`brew install mercurial`

总仓库地址：[OpenJDK Mercurial repositories](http://hg.openjdk.java.net)

常见仓库：

- [javac 7](http://hg.openjdk.java.net/jdk7/jdk7/langtools)
- [javac 8](http://hg.openjdk.java.net/jdk8/jdk8/langtools)
- [javac 9](http://hg.openjdk.java.net/jdk9/jdk9/langtools)
- [javac dev 9](http://hg.openjdk.java.net/jdk9/dev/langtools)

克隆仓库命令示例：`hg clone http://hg.openjdk.java.net/jdk8/jdk8/langtools jdk8-langtools`

## 编辑器

[NetBeans](http://netbeans.org)

编译之前修改 `make/build.properties` 文件中的 `boot.java.home` 属性，指向的 `jdk` 路径按该项目需要的 `jdk` 版本来定。比如 `jdk7-langtools` 项目可以使用 `jdk 7` 来编译，在 Mac 下可以改成：

```
boot.java.home = /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home
boot.java = ${boot.java.home}/bin/java
boot.javac = ${boot.java.home}/bin/javac
```

注意：要编译生成 `javac` 是通过**构建**，而不是**运行**，并且构建时一定要先**清理**已经构建出的内容。

快捷键：

- `Command + Up`: Go to Declaration
- `Command + Left`: Back
- `Command + Right`: Forward
- `Command + F`: Find
- `Command + R`: Replace
- `Command + G`: Go to Line
- `Command + X`: Cut Current Line
- `Command + -`: Collapse，折叠
- `Command + +`: Expand，展开

## 在 Java 8 上编译和运行 GJC

由于 Java 8 的 `target` 是 52.0，Java 1.4 的 `target` 是 48.0。这会导致用编译后得到的 Java 1.4 编译器去编译源文件时，会提示以下错误：

```
cannot access java.lang.Object
bad class file: /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/rt.jar(java/lang/Object.class)
class file has wrong version 52.0, should be 48.0
```

修复方式，将 `com/sun/tools/javac/v8/code/Target.java` 中的以下代码：

```java
public static final Target JDK1_4 = new Target("1.4", 48, 0);
public static final Target JDK1_4_1 = new Target("1.4.1", 48, 0);
public static final Target JDK1_4_2 = new Target("1.4.2", 48, 0);
```

修改为：

```java
public static final Target JDK1_4 = new Target("1.4", 52, 0);
public static final Target JDK1_4_1 = new Target("1.4.1", 52, 0);
public static final Target JDK1_4_2 = new Target("1.4.2", 52, 0);
```

> 宏：编译时运行的函数（来自[这里](http://liujiacai.net/blog/2017/02/05/clojure-compiler-analyze/)）

## Parse and Enter

parse: 将源码转为抽象语法树
enter: 将抽象语法树中的符号添加到符号表中供语义分析

