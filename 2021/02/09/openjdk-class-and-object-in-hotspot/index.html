<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2cdbc7958f6df4fec3751794de6e9c63";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>



  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-131906119-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-131906119-2');
  </script>



  
  <title>HotSpot中的Java类和对象 | 01的世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="本文记录Java类和对象在HotSpot中的实现方式。">
<meta property="og:type" content="article">
<meta property="og:title" content="HotSpot中的Java类和对象">
<meta property="og:url" content="https://tintin.dev/2021/02/09/openjdk-class-and-object-in-hotspot/index.html">
<meta property="og:site_name" content="01的世界">
<meta property="og:description" content="本文记录Java类和对象在HotSpot中的实现方式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tintin.dev/images/java-object-in-hotspot.png">
<meta property="article:published_time" content="2021-02-08T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-14T10:14:16.636Z">
<meta property="article:author" content="tintin">
<meta property="article:tag" content="java">
<meta property="article:tag" content="openjdk">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tintin.dev/images/java-object-in-hotspot.png">
  
  
    <link rel="icon" type="image/x-icon" href="/images/logo.jpg">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <span id="logo">01的世界</span>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://tintin.dev"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-openjdk-class-and-object-in-hotspot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title article-title-tin" itemprop="headline name">
      HotSpot中的Java类和对象
    </h1>
  
  <p class="article-meta-tin">by tintin @<time class="dt-published" datetime="2021-02-08T16:00:00.000Z" itemprop="datePublished">2021-02-09</time></p>


      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文记录Java类和对象在HotSpot中的实现方式。</p>
<h3 id="Klass和oop"><a href="#Klass和oop" class="headerlink" title="Klass和oop"></a>Klass和oop</h3><p>在HotSpot中，Java类使用Klass对象表示，Java对象使用oop（普通对象指针）对象表示。不过oop只存储Java对象的实例字段，实例方法还是存放在Klass对象中。根据源代码中的注释说明，如果将实例方法存放在Klass对象上，oop对象可以省去指向实例方法表（可以理解为C++中的虚函数表）的指针。不过可以这样做是因为oop对象头中持有了指向对应Klass对象的指针，所以当需要调用实例方法时，可以通过这个指针找到Klass对象，进而找到实例方法进行调用。</p>
<p>在HotSpot加载和解析类文件后，会创建InstanceKlass实例，紧接着实例的内存存放了vtable（虚函数表）和itable（接口和接口方法表）等信息。</p>
<p>Klass及其子类的继承关系如下面的代码所示。其中InstanceKlass实例为普通Java类的C++表示，InstanceMirrorKlass实例为java.lang.Class类的C++表示（因此InstanceMirrorKlass实例只有一个）。在HotSpot中，Java类的静态字段也使用oop对象表示（每个Java类只有一个，存储在InstanceKlass实例的_java_mirror字段），不过并不是由对应的InstanceKlass实例创建，而是由唯一的InstanceMirrorKlass实例根据传入的InstanceKlass实例来创建。_java_mirror是在InstanceKlass实例生成过程中创建的，这也说明静态字段跟实例字段一样，存储在Java堆中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* src/hotspot/share/oops/oopsHierarchy.hpp */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Klass</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span>   <span class="title">InstanceKlass</span>;</span>              <span class="comment">// 普通Java类，有其生成的oop对象存储了类中的实例字段</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span>     <span class="title">InstanceMirrorKlass</span>;</span>      <span class="comment">// java.lang.Class类，除了Class类自身的实例字段，由其生成的oop还存储了对应Java类中的静态字段</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span>     <span class="title">InstanceClassLoaderKlass</span>;</span> <span class="comment">// 类加载器类</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span>     <span class="title">InstanceRefKlass</span>;</span>         <span class="comment">// 引用类</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span>   <span class="title">ArrayKlass</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span>     <span class="title">ObjArrayKlass</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span>     <span class="title">TypeArrayKlass</span>;</span></span><br></pre></td></tr></table></figure>

<p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* src/hotspot/share/oops/klass.hpp */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Klass</span> &#123;</span></span><br><span class="line">   jint        _layout_helper; <span class="comment">// 包含oop header和实例字段的长度，创建对应的oop时需要</span></span><br><span class="line">   <span class="keyword">int</span>         _vtable_len;    <span class="comment">// 实例方法长度</span></span><br><span class="line">   OopHandle   _java_mirror;   <span class="comment">// 类对象的Class类实例</span></span><br><span class="line">   Klass*      _super;         <span class="comment">// 父类</span></span><br><span class="line">   </span><br><span class="line">   <span class="function">klassVtable <span class="title">vtable</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 虚函数表</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* src/hotspot/share/oops/instanceKlass.hpp */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">InstanceKlass</span>:</span> <span class="keyword">public</span> Klass &#123;</span><br><span class="line">   <span class="keyword">int</span>             _nonstatic_field_size;  <span class="comment">// 实例字段的长度</span></span><br><span class="line">   <span class="keyword">int</span>             _static_field_size;     <span class="comment">// 静态字段的长度，生产mirror时用到</span></span><br><span class="line">   <span class="keyword">int</span>             _itable_len;            <span class="comment">// 实现的接口个数</span></span><br><span class="line">   Array&lt;u2&gt;*      _fields;                <span class="comment">// 实例和静态字段信息，包括偏移值</span></span><br><span class="line">   Array&lt;Method*&gt;* _methods;               <span class="comment">// 实例和静态方法信息，有解释执行和编译执行的入口</span></span><br><span class="line">Array&lt;Method*&gt;* _default_methods;       <span class="comment">// 类所实现的接口中的默认实现方法</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 根据类型分配InstanceKlass或者他的子类</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> InstanceKlass* <span class="title">allocate_instance_klass</span><span class="params">(<span class="keyword">const</span> ClassFileParser&amp; parser, TRAPS)</span></span>;</span><br><span class="line">   <span class="comment">// 生成类的实例对象oop，包含实例字段在内</span></span><br><span class="line">   <span class="function">instanceOop <span class="title">allocate_instance</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">link_class_impl</span><span class="params">(TRAPS)</span></span>;  <span class="comment">// 方法链接，包括方法链接（确定解释器入口和编译器入口），接口列表的初始化</span></span><br><span class="line">   <span class="function">klassItable <span class="title">itable</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 接口和其方法表</span></span><br><span class="line">   <span class="comment">// 紧接着存放类的实例方法列表（虚函数表，vtable）</span></span><br><span class="line">   <span class="comment">// 紧接着存放类的接口和接口方法列表（itable）</span></span><br><span class="line">   <span class="comment">// ...（还有其他信息，省略）</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* src/hotspot/share/oops/instanceMirrorKlass.hpp */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">InstanceMirrorKlass</span>:</span> <span class="keyword">public</span> InstanceKlass &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> _offset_of_static_fields;  <span class="comment">// 静态字段在oop对象中的偏移量</span></span><br><span class="line">   <span class="comment">// 生产类对应的java.lang.Class类的实例oop对象</span></span><br><span class="line">   <span class="comment">// 相比InstanceKlass的allocate_instance，会把普通类的静态字段考虑进来</span></span><br><span class="line">   <span class="function">instanceOop <span class="title">allocate_instance</span><span class="params">(Klass* k, TRAPS)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当需要创建Java对象时，会调用InstanceKlass的allocate_instance方法生成instanceOop对象。注意各oop只是一个指向对应oopDesc对象的指针，不过为了保持前后描述的一致，当说到oop对象或实例时，其实是指对应的oopDesc实例。各oop之间的继承关系如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* src/hotspot/share/oops/oopsHierarchy.hpp */</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span>*                    <span class="title">oop</span>;</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">instanceOopDesc</span>*            <span class="title">instanceOop</span>;</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">arrayOopDesc</span>*               <span class="title">arrayOop</span>;</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>     <span class="title">objArrayOopDesc</span>*            <span class="title">objArrayOop</span>;</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>     <span class="title">typeArrayOopDesc</span>*           <span class="title">typeArrayOop</span>;</span></span><br></pre></td></tr></table></figure>

<p>oop实例本身只存储了两个字段。一个是_mark字段，用于存储各种信息，比如GC标记、锁标记等，可以根据需要使用。另一个是_metadata字段，存储指向InstanceKlass实例的指针。各oop的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* src/hotspot/share/oops/oop.hpp */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">volatile</span> markWord _mark;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> _<span class="title">metadata</span> &#123;</span></span><br><span class="line">     Klass*      _klass;</span><br><span class="line">     narrowKlass _compressed_klass; <span class="comment">// 压缩版本</span></span><br><span class="line">   &#125; _metadata;</span><br><span class="line">   <span class="comment">// 紧接着存放Java对象的实例字段</span></span><br><span class="line">   <span class="comment">// 紧接着存放Java类的静态字段（注意只有java.lang.Class类的实例才有这部分内容，也就是Klass中的_java_mirror字段）</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* src/hotspot/share/oops/instanceOop.hpp */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>不管是Klass实例还是oop实例，紧跟着实例内存后面还会多出来一些东西，比如Klass实例中的虚函数表、接口表，oop实例中的实例字段、静态字段。</p>
<h3 id="vtable和itable"><a href="#vtable和itable" class="headerlink" title="vtable和itable"></a>vtable和itable</h3><p>vtable的作用在于根据实例对象寻找所调用的函数，用于实现多态性。如下面的Java代码，虽然c被声明为Parent类变量，但是实例化的时候是使用的Child类，所以在调用f方法时，实际调用的是Child的。为了实现这个逻辑，在创建Klass对象时，会同时创建vtable，里面存储了所有虚方法（包括从父类继承过来的方法）。然后在调用实例的方法时，可以根据虚方法的索引，在oop对象对应的Klass对象的vtable中寻找。这个逻辑可以在下文的<code>invokevirtual</code>执行逻辑中看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent c = <span class="keyword">new</span> Child();</span><br><span class="line">c.f();</span><br></pre></td></tr></table></figure>

<p>而itable是为了实现Java中的接口功能，主要用于检查类是否有实现接口中要求的抽象方法，检查逻辑可以在下文的<code>invokeinterface</code>执行逻辑中看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A b = <span class="keyword">new</span> B();</span><br><span class="line">b.f();</span><br></pre></td></tr></table></figure>

<p>Klass对象、vatble和itable的内存布局如下：</p>
<p><img src="/images/java-object-in-hotspot.png"></p>
<h3 id="相关字节码执行逻辑"><a href="#相关字节码执行逻辑" class="headerlink" title="相关字节码执行逻辑"></a><strong>相关字节码执行逻辑</strong></h3><p>了解了Java类和对象在HotSpot中的表示后，再来看下HotSpot对<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>getfield</code>、<code>putfield</code>、<code>invokevirtual</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokeinterface</code>这些字节码的解释执行过程。阅读代码的入口可以从<code>src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp</code>文件开始，在字节码前面加上下划线就可以在这里面搜索到对应的case语句。</p>
<p>注意讲解的字节码的执行逻辑是用的Zero字节码解释器，而不是模版解释器或者C1/C2即时编译器。</p>
<ul>
<li><p><code>new index</code></p>
<p>  创建一个实例，调用的InstanceKlass实例的allocate_instance方法。该方法会在堆中申请一片内存，用于存放oop头部和实例字段。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">BytecodeInterpreter::run</span><span class="params">(interpreterState istate)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="keyword">switch</span> (opcode)</span><br><span class="line">       &#123;</span><br><span class="line">       ...</span><br><span class="line">       CASE(_new): &#123;</span><br><span class="line">         <span class="comment">// 获取new指令的操作数index</span></span><br><span class="line">         u2 index = Bytes::get_Java_u2(pc+<span class="number">1</span>);</span><br><span class="line">         ConstantPool* constants = istate-&gt;method()-&gt;constants();</span><br><span class="line">         <span class="comment">// 1. 可以的话从TLAB中快速分配</span></span><br><span class="line">         <span class="keyword">if</span> (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123;</span><br><span class="line">           Klass* entry = constants-&gt;resolved_klass_at(index);</span><br><span class="line">           InstanceKlass* ik = InstanceKlass::cast(entry);</span><br><span class="line">           <span class="keyword">if</span> (ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123;</span><br><span class="line">             <span class="keyword">size_t</span> obj_size = ik-&gt;size_helper();</span><br><span class="line">             oop result = <span class="literal">NULL</span>;</span><br><span class="line">             <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">               result = (oop) THREAD-&gt;tlab().allocate(obj_size);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="comment">// Initialize object (if nonzero size and need) and then the header.</span></span><br><span class="line">               <span class="comment">// If the TLAB isn&#x27;t pre-zeroed then we&#x27;ll have to do it.</span></span><br><span class="line">               <span class="keyword">if</span> (!ZeroTLAB) &#123;</span><br><span class="line">                 HeapWord* to_zero = cast_from_oop&lt;HeapWord*&gt;(result) + <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">                 obj_size -= <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">                 <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                   <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               assert(!UseBiasedLocking, <span class="string">&quot;Not implemented&quot;</span>);</span><br><span class="line">               result-&gt;set_mark(markWord::prototype());</span><br><span class="line">               result-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">               result-&gt;set_klass(ik);</span><br><span class="line">               <span class="comment">// Must prevent reordering of stores for object initialization</span></span><br><span class="line">               <span class="comment">// with stores that publish the new object.</span></span><br><span class="line">               OrderAccess::storestore();</span><br><span class="line">               SET_STACK_OBJECT(result, <span class="number">0</span>);</span><br><span class="line">               UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 2. 慢分配才用到了InstanceKlass::allocate_instance方法</span></span><br><span class="line">         CALL_VM(InterpreterRuntime::_new(THREAD, METHOD-&gt;constants(), index),</span><br><span class="line">                 handle_exception);</span><br><span class="line">         <span class="comment">// 防止指令重排</span></span><br><span class="line">         OrderAccess::storestore();</span><br><span class="line">         <span class="comment">// 将分配的对象push到栈上</span></span><br><span class="line">         SET_STACK_OBJECT(THREAD-&gt;vm_result(), <span class="number">0</span>);</span><br><span class="line">         THREAD-&gt;set_vm_result(<span class="literal">NULL</span>);</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">         UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       &#125;</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getstatic index</code>、<code>getfield index</code></p>
<p>  先根据index确定对应的oop对象（实例字段和静态字段有区别），以及字段在oop中的偏移量，确定之后根据类型将对应的值复制到栈顶。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp */</span></span><br><span class="line">      CASE(_getfield):</span><br><span class="line">      CASE(_getstatic):</span><br><span class="line">        &#123;</span><br><span class="line">          u2 index;</span><br><span class="line">          ConstantPoolCacheEntry* cache;</span><br><span class="line">          index = Bytes::get_native_u2(pc+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          cache = cp-&gt;entry_at(index);</span><br><span class="line">          <span class="keyword">if</span> (!cache-&gt;is_resolved((Bytecodes::Code)opcode)) &#123;</span><br><span class="line">            <span class="comment">/// 解析字节码和操作数，比如将class字符确定为对象的klass对象，将字段名称解析为oop中的索引</span></span><br><span class="line">            CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, (Bytecodes::Code)opcode),</span><br><span class="line">                    handle_exception);</span><br><span class="line">            cache = cp-&gt;entry_at(index);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          oop obj;</span><br><span class="line">          <span class="keyword">if</span> ((Bytecodes::Code)opcode == Bytecodes::_getstatic) &#123;</span><br><span class="line">            <span class="comment">/// 如果是静态字段，则取出class部分</span></span><br><span class="line">            Klass* k = cache-&gt;f1_as_klass();</span><br><span class="line">            <span class="comment">/// 静态字段从_java_mirror中去</span></span><br><span class="line">            obj = k-&gt;java_mirror();</span><br><span class="line">            <span class="comment">/// 目的是为了将后面取出的字段值存放在栈顶</span></span><br><span class="line">            MORE_STACK(<span class="number">1</span>);  <span class="comment">// Assume single slot push</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj = (oop) STACK_OBJECT(<span class="number">-1</span>); <span class="comment">/// 后续会将该位置覆盖为实例字段值</span></span><br><span class="line">            CHECK_NULL(obj);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// Now store the result on the stack</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          TosState tos_type = cache-&gt;flag_state();</span><br><span class="line">          <span class="comment">// 取出字段相对oop对象偏移量</span></span><br><span class="line">          <span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">          <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">              OrderAccess::fence();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tos_type == atos) &#123;</span><br><span class="line">              VERIFY_OOP(obj-&gt;obj_field_acquire(field_offset));</span><br><span class="line">              SET_STACK_OBJECT(obj-&gt;obj_field_acquire(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == itos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;int_field_acquire(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ltos) &#123;</span><br><span class="line">              SET_STACK_LONG(obj-&gt;long_field_acquire(field_offset), <span class="number">0</span>);</span><br><span class="line">              <span class="comment">/// long类型和下面的double类型占用两个slot</span></span><br><span class="line">              MORE_STACK(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == btos || tos_type == ztos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;byte_field_acquire(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ctos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;char_field_acquire(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == stos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;short_field_acquire(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ftos) &#123;</span><br><span class="line">              SET_STACK_FLOAT(obj-&gt;float_field_acquire(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              SET_STACK_DOUBLE(obj-&gt;double_field_acquire(field_offset), <span class="number">0</span>);</span><br><span class="line">              MORE_STACK(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tos_type == atos) &#123;</span><br><span class="line">              VERIFY_OOP(obj-&gt;obj_field(field_offset));</span><br><span class="line">              SET_STACK_OBJECT(obj-&gt;obj_field(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == itos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;int_field(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ltos) &#123;</span><br><span class="line">              SET_STACK_LONG(obj-&gt;long_field(field_offset), <span class="number">0</span>);</span><br><span class="line">              MORE_STACK(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == btos || tos_type == ztos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;byte_field(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ctos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;char_field(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == stos) &#123;</span><br><span class="line">              SET_STACK_INT(obj-&gt;short_field(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ftos) &#123;</span><br><span class="line">              SET_STACK_FLOAT(obj-&gt;float_field(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              SET_STACK_DOUBLE(obj-&gt;double_field(field_offset), <span class="number">0</span>);</span><br><span class="line">              MORE_STACK(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          UPDATE_PC_AND_CONTINUE(<span class="number">3</span>);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>putstatic index</code><strong>、</strong><code>putfield index</code></p>
<p>  先根据index确定对应的oop对象（实例字段和静态字段有区别），以及字段在oop中的偏移量，确定之后根据类型将对应栈上的值存储到oop中。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp */</span></span><br><span class="line">      CASE(_putfield):</span><br><span class="line">      CASE(_putstatic):</span><br><span class="line">        &#123;</span><br><span class="line">          u2 index = Bytes::get_native_u2(pc+<span class="number">1</span>);</span><br><span class="line">          ConstantPoolCacheEntry* cache = cp-&gt;entry_at(index);</span><br><span class="line">          <span class="keyword">if</span> (!cache-&gt;is_resolved((Bytecodes::Code)opcode)) &#123;</span><br><span class="line">            CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, (Bytecodes::Code)opcode),</span><br><span class="line">                    handle_exception);</span><br><span class="line">            cache = cp-&gt;entry_at(index);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          oop obj;</span><br><span class="line">          <span class="keyword">int</span> count;</span><br><span class="line">          TosState tos_type = cache-&gt;flag_state();</span><br><span class="line"></span><br><span class="line">          count = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">if</span> (tos_type == ltos || tos_type == dtos) &#123;</span><br><span class="line">            --count;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ((Bytecodes::Code)opcode == Bytecodes::_putstatic) &#123;</span><br><span class="line">            Klass* k = cache-&gt;f1_as_klass();</span><br><span class="line">            obj = k-&gt;java_mirror();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --count;</span><br><span class="line">            obj = (oop) STACK_OBJECT(count);</span><br><span class="line">            CHECK_NULL(obj);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// Now store the result</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">          <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tos_type == itos) &#123;</span><br><span class="line">              obj-&gt;release_int_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == atos) &#123;</span><br><span class="line">              VERIFY_OOP(STACK_OBJECT(<span class="number">-1</span>));</span><br><span class="line">              obj-&gt;release_obj_field_put(field_offset, STACK_OBJECT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == btos) &#123;</span><br><span class="line">              obj-&gt;release_byte_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ztos) &#123;</span><br><span class="line">              <span class="keyword">int</span> bool_field = STACK_INT(<span class="number">-1</span>);  <span class="comment">// only store LSB</span></span><br><span class="line">              obj-&gt;release_byte_field_put(field_offset, (bool_field &amp; <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ltos) &#123;</span><br><span class="line">              obj-&gt;release_long_field_put(field_offset, STACK_LONG(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ctos) &#123;</span><br><span class="line">              obj-&gt;release_char_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == stos) &#123;</span><br><span class="line">              obj-&gt;release_short_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ftos) &#123;</span><br><span class="line">              obj-&gt;release_float_field_put(field_offset, STACK_FLOAT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              obj-&gt;release_double_field_put(field_offset, STACK_DOUBLE(<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            OrderAccess::storeload();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tos_type == itos) &#123;</span><br><span class="line">              obj-&gt;int_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == atos) &#123;</span><br><span class="line">              VERIFY_OOP(STACK_OBJECT(<span class="number">-1</span>));</span><br><span class="line">              obj-&gt;obj_field_put(field_offset, STACK_OBJECT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == btos) &#123;</span><br><span class="line">              obj-&gt;byte_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ztos) &#123;</span><br><span class="line">              <span class="keyword">int</span> bool_field = STACK_INT(<span class="number">-1</span>);  <span class="comment">// only store LSB</span></span><br><span class="line">              obj-&gt;byte_field_put(field_offset, (bool_field &amp; <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ltos) &#123;</span><br><span class="line">              obj-&gt;long_field_put(field_offset, STACK_LONG(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ctos) &#123;</span><br><span class="line">              obj-&gt;char_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == stos) &#123;</span><br><span class="line">              obj-&gt;short_field_put(field_offset, STACK_INT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ftos) &#123;</span><br><span class="line">              obj-&gt;float_field_put(field_offset, STACK_FLOAT(<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              obj-&gt;double_field_put(field_offset, STACK_DOUBLE(<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, count);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>invokestatic index</code>、<code>invokevirtual index</code>、<code>invokespecial index</code></p>
<p>  首先执行一个方法是从ZeroInterpreter.main_loop中的while无限循环开始，在循环里面会调用BytecodeInterpreter.run，依次执行每一条字节码。当执行到调用方法的字节码后，首先先确定需要调用的方法，然后设置当前执行栈的msg为call_method并返回到main_loop。在main_loop中发现msg为call_method之后，就去调用需要调用的那个方法，调用完成之后设置msg为method_resume，然后循环回去继续调用run方法接着执行后面的字节码。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/hotspot/cpu/zero/zeroInterpreter_zero.cpp */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// We can set up the frame anchor with everything we want at</span></span><br><span class="line">    <span class="comment">// this point as we are thread_in_Java and no safepoints can</span></span><br><span class="line">    <span class="comment">// occur until we go to vm mode.  We do have to clear flags</span></span><br><span class="line">    <span class="comment">// on return from vm but that is it.</span></span><br><span class="line">    thread-&gt;set_last_Java_frame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the interpreter</span></span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::can_post_interpreter_events()) &#123;</span><br><span class="line">      BytecodeInterpreter::run&lt;<span class="literal">true</span>&gt;(istate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      BytecodeInterpreter::run&lt;<span class="literal">false</span>&gt;(istate);</span><br><span class="line">    &#125;</span><br><span class="line">    fixup_after_potential_safepoint();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the frame anchor</span></span><br><span class="line">    thread-&gt;reset_last_Java_frame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine the message from the interpreter to decide what to do</span></span><br><span class="line">    <span class="keyword">if</span> (istate-&gt;msg() == BytecodeInterpreter::call_method) &#123;</span><br><span class="line">      Method* callee = istate-&gt;callee();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Trim back the stack to put the parameters at the top</span></span><br><span class="line">      <span class="built_in">stack</span>-&gt;set_sp(istate-&gt;<span class="built_in">stack</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make the call</span></span><br><span class="line">      Interpreter::invoke_method(callee, istate-&gt;callee_entry_point(), THREAD);</span><br><span class="line">      fixup_after_potential_safepoint();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert the result</span></span><br><span class="line">      istate-&gt;set_stack(<span class="built_in">stack</span>-&gt;sp() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Restore the stack</span></span><br><span class="line">      <span class="built_in">stack</span>-&gt;set_sp(istate-&gt;stack_limit() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Resume the interpreter</span></span><br><span class="line">      istate-&gt;set_msg(BytecodeInterpreter::method_resume);</span><br><span class="line">    &#125; <span class="keyword">else</span> ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp */</span></span><br><span class="line">      CASE(_invokevirtual):</span><br><span class="line">      CASE(_invokespecial):</span><br><span class="line">      CASE(_invokestatic): &#123;</span><br><span class="line">        u2 index = Bytes::get_native_u2(pc+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ConstantPoolCacheEntry* cache = cp-&gt;entry_at(index);</span><br><span class="line">        <span class="keyword">if</span> (!cache-&gt;is_resolved((Bytecodes::Code)opcode)) &#123;</span><br><span class="line">          CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, (Bytecodes::Code)opcode),</span><br><span class="line">                  handle_exception);</span><br><span class="line">          cache = cp-&gt;entry_at(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 设置下一步处理的消息类型</span></span><br><span class="line">        istate-&gt;set_msg(call_method);</span><br><span class="line">        &#123;</span><br><span class="line">          Method* callee;</span><br><span class="line">          <span class="keyword">if</span> ((Bytecodes::Code)opcode == Bytecodes::_invokevirtual) &#123;</span><br><span class="line">            <span class="comment">/// 如果是实例方法调用，需要查虚函数表</span></span><br><span class="line">            CHECK_NULL(STACK_OBJECT(-(cache-&gt;parameter_size())));</span><br><span class="line">            <span class="keyword">if</span> (cache-&gt;is_vfinal()) &#123;</span><br><span class="line">              callee = cache-&gt;f2_as_vfinal_method();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">int</span> parms = cache-&gt;parameter_size();</span><br><span class="line">              oop rcvr = STACK_OBJECT(-parms);</span><br><span class="line">              VERIFY_OOP(rcvr);</span><br><span class="line">              Klass* rcvrKlass = rcvr-&gt;klass();</span><br><span class="line">              callee = (Method*) rcvrKlass-&gt;method_at_vtable(cache-&gt;f2_as_index());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((Bytecodes::Code)opcode == Bytecodes::_invokespecial) &#123;</span><br><span class="line">              CHECK_NULL(STACK_OBJECT(-(cache-&gt;parameter_size())));</span><br><span class="line">            &#125;</span><br><span class="line">            callee = cache-&gt;f1_as_method();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          istate-&gt;set_callee(callee);</span><br><span class="line">          istate-&gt;set_callee_entry_point(callee-&gt;from_interpreted_entry());</span><br><span class="line">          <span class="keyword">if</span> (JVMTI_ENABLED &amp;&amp; THREAD-&gt;is_interp_only_mode()) &#123;</span><br><span class="line">            istate-&gt;set_callee_entry_point(callee-&gt;interpreter_entry());</span><br><span class="line">          &#125;</span><br><span class="line">          istate-&gt;set_bcp_advance(<span class="number">3</span>);</span><br><span class="line">          <span class="comment">/// 退出run方法，进入main_loop然后判断msg，为call_method则去执行对应的方法</span></span><br><span class="line">          UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// I&#x27;ll be back...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>invokeinterface index</code></p>
<p>  接口方法的调用稍微复杂些，现需要找到方法所在的接口表，然后找到接口对应的方法入口，再根据方法索引找到对应的方法执行入口。接口相关的数据在两个阶段进行了初始化，首先在创建InstanceKlass阶段，会对itable的接口表部分进行初始化，将类实现的所有接口都存储在这里。然后在类链接阶段，将itable中每个接口对应的方法表给初始化。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">CASE(_invokeinterface): &#123;</span><br><span class="line">  u2 index = Bytes::get_native_u2(pc+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// QQQ Need to make this as inlined as possible. Probably need to split all the bytecode cases</span></span><br><span class="line">  <span class="comment">// out so c++ compiler has a chance for constant prop to fold everything possible away.</span></span><br><span class="line"></span><br><span class="line">  ConstantPoolCacheEntry* cache = cp-&gt;entry_at(index);</span><br><span class="line">  <span class="keyword">if</span> (!cache-&gt;is_resolved((Bytecodes::Code)opcode)) &#123;</span><br><span class="line">    CALL_VM(InterpreterRuntime::resolve_from_cache(THREAD, (Bytecodes::Code)opcode),</span><br><span class="line">            handle_exception);</span><br><span class="line">    cache = cp-&gt;entry_at(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  istate-&gt;set_msg(call_method);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Special case of invokeinterface called for virtual method of</span></span><br><span class="line">  <span class="comment">// java.lang.Object.  See cpCache.cpp for details.</span></span><br><span class="line">  Method* callee = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (cache-&gt;is_forced_virtual()) &#123;</span><br><span class="line">    CHECK_NULL(STACK_OBJECT(-(cache-&gt;parameter_size())));</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;is_vfinal()) &#123;</span><br><span class="line">      callee = cache-&gt;f2_as_vfinal_method();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Get receiver.</span></span><br><span class="line">      <span class="keyword">int</span> parms = cache-&gt;parameter_size();</span><br><span class="line">      <span class="comment">// Same comments as invokevirtual apply here.</span></span><br><span class="line">      oop rcvr = STACK_OBJECT(-parms);</span><br><span class="line">      VERIFY_OOP(rcvr);</span><br><span class="line">      Klass* rcvrKlass = rcvr-&gt;klass();</span><br><span class="line">      callee = (Method*) rcvrKlass-&gt;method_at_vtable(cache-&gt;f2_as_index());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache-&gt;is_vfinal()) &#123;</span><br><span class="line">    <span class="comment">// private interface method invocations</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Ensure receiver class actually implements</span></span><br><span class="line">    <span class="comment">// the resolved interface class. The link resolver</span></span><br><span class="line">    <span class="comment">// does this, but only for the first time this</span></span><br><span class="line">    <span class="comment">// interface is being called.</span></span><br><span class="line">    <span class="keyword">int</span> parms = cache-&gt;parameter_size();</span><br><span class="line">    oop rcvr = STACK_OBJECT(-parms);</span><br><span class="line">    CHECK_NULL(rcvr);</span><br><span class="line">    Klass* recv_klass = rcvr-&gt;klass();</span><br><span class="line">    Klass* resolved_klass = cache-&gt;f1_as_klass();</span><br><span class="line">    <span class="keyword">if</span> (!recv_klass-&gt;is_subtype_of(resolved_klass)) &#123;</span><br><span class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line">      jio_snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;Class %s does not implement the requested interface %s&quot;</span>,</span><br><span class="line">        recv_klass-&gt;external_name(),</span><br><span class="line">        resolved_klass-&gt;external_name());</span><br><span class="line">      VM_JAVA_ERROR(vmSymbols::java_lang_IncompatibleClassChangeError(), buf);</span><br><span class="line">    &#125;</span><br><span class="line">    callee = cache-&gt;f2_as_vfinal_method();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (callee != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    istate-&gt;set_callee(callee);</span><br><span class="line">    istate-&gt;set_callee_entry_point(callee-&gt;from_interpreted_entry());</span><br><span class="line">    <span class="keyword">if</span> (JVMTI_ENABLED &amp;&amp; THREAD-&gt;is_interp_only_mode()) &#123;</span><br><span class="line">      istate-&gt;set_callee_entry_point(callee-&gt;interpreter_entry());</span><br><span class="line">    &#125;</span><br><span class="line">    istate-&gt;set_bcp_advance(<span class="number">5</span>);</span><br><span class="line">    UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// I&#x27;ll be back...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this could definitely be cleaned up QQQ</span></span><br><span class="line">  Method *interface_method = cache-&gt;f2_as_interface_method();</span><br><span class="line">  <span class="comment">/// 方法所在的接口</span></span><br><span class="line">  InstanceKlass* iclass = interface_method-&gt;method_holder();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get receiver</span></span><br><span class="line">  <span class="keyword">int</span> parms = cache-&gt;parameter_size();</span><br><span class="line">  oop rcvr = STACK_OBJECT(-parms);</span><br><span class="line">  CHECK_NULL(rcvr);</span><br><span class="line">  <span class="comment">/// 实例对象对应的Klass</span></span><br><span class="line">  InstanceKlass* int2 = (InstanceKlass*) rcvr-&gt;klass();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receiver subtype check against resolved interface klass (REFC).</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/// 检查声明变量所使用的接口类型是否被类实现了</span></span><br><span class="line">    Klass* refc = cache-&gt;f1_as_klass();</span><br><span class="line">    itableOffsetEntry* scan;</span><br><span class="line">    <span class="keyword">for</span> (scan = (itableOffsetEntry*) int2-&gt;start_of_itable();</span><br><span class="line">         scan-&gt;interface_klass() != <span class="literal">NULL</span>;</span><br><span class="line">         scan++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (scan-&gt;interface_klass() == refc) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check that the entry is non-null.  A null entry means</span></span><br><span class="line">    <span class="comment">// that the receiver class doesn&#x27;t implement the</span></span><br><span class="line">    <span class="comment">// interface, and wasn&#x27;t the same as when the caller was</span></span><br><span class="line">    <span class="comment">// compiled.</span></span><br><span class="line">    <span class="keyword">if</span> (scan-&gt;interface_klass() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      VM_JAVA_ERROR(vmSymbols::java_lang_IncompatibleClassChangeError(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 寻找到方法所在接口的itable</span></span><br><span class="line">  itableOffsetEntry* ki = (itableOffsetEntry*) int2-&gt;start_of_itable();</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; int2-&gt;itable_length() ; i++, ki++ ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ki-&gt;interface_klass() == iclass) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If the interface isn&#x27;t found, this class doesn&#x27;t implement this</span></span><br><span class="line">  <span class="comment">// interface. The link resolver checks this but only for the first</span></span><br><span class="line">  <span class="comment">// time this interface is called.</span></span><br><span class="line">  <span class="keyword">if</span> (i == int2-&gt;itable_length()) &#123;</span><br><span class="line">    CALL_VM(InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(THREAD, rcvr-&gt;klass(), iclass),</span><br><span class="line">            handle_exception);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mindex = interface_method-&gt;itable_index();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 获取接口下的method表</span></span><br><span class="line">  itableMethodEntry* im = ki-&gt;first_method_entry(rcvr-&gt;klass());</span><br><span class="line">  callee = im[mindex].method();</span><br><span class="line">  <span class="keyword">if</span> (callee == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    CALL_VM(InterpreterRuntime::throw_AbstractMethodErrorVerbose(THREAD, rcvr-&gt;klass(), interface_method),</span><br><span class="line">            handle_exception);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  istate-&gt;set_callee(callee);</span><br><span class="line">  istate-&gt;set_callee_entry_point(callee-&gt;from_interpreted_entry());</span><br><span class="line">  <span class="keyword">if</span> (JVMTI_ENABLED &amp;&amp; THREAD-&gt;is_interp_only_mode()) &#123;</span><br><span class="line">    istate-&gt;set_callee_entry_point(callee-&gt;interpreter_entry());</span><br><span class="line">  &#125;</span><br><span class="line">  istate-&gt;set_bcp_advance(<span class="number">5</span>);</span><br><span class="line">  UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// I&#x27;ll be back...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openjdk/" rel="tag">openjdk</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/02/14/openjdk-constant-pool/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          HotSpot中的Run-Time Constant Pool实现
        
      </div>
    </a>
  
  
    <a href="/2020/12/26/openjdk-epsilon-gc-add-gc/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">给OpenJDK中的Epsilon GC添加GC功能</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/llvm/">llvm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%84%E8%AE%BA/">评论</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenJDK/" rel="tag">OpenJDK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/" rel="tag">design</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/econ/" rel="tag">econ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/llvm/" rel="tag">llvm</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nand2tetris/" rel="tag">nand2tetris</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">note</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openjdk/" rel="tag">openjdk</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quickjs/" rel="tag">quickjs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scheme/" rel="tag">scheme</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ukulele/" rel="tag">ukulele</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/" rel="tag">经济学</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/14/openjdk-constant-pool/">HotSpot中的Run-Time Constant Pool实现</a>
          </li>
        
          <li>
            <a href="/2021/02/09/openjdk-class-and-object-in-hotspot/">HotSpot中的Java类和对象</a>
          </li>
        
          <li>
            <a href="/2020/12/26/openjdk-epsilon-gc-add-gc/">给OpenJDK中的Epsilon GC添加GC功能</a>
          </li>
        
          <li>
            <a href="/2020/12/23/the-design-of-everyday-things/">日用品的设计（持续更新中）</a>
          </li>
        
          <li>
            <a href="/2020/12/21/nand2tetris-2/">Nand2Tetris Part 2 课程总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 <a target="_blank" rel="noopener" href="https://github.com/lhtin">tintin</a><br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>