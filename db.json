{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/MP_verify_wzdj75tMmTqbmmXI.txt","path":"MP_verify_wzdj75tMmTqbmmXI.txt","modified":1,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161119.1-1.bad.jpg","path":"assets/design/20161119.1-1.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161119.1-1.good.jpg","path":"assets/design/20161119.1-1.good.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161119.2-1.bad.jpg","path":"assets/design/20161119.2-1.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161119.2-1.good.jpg","path":"assets/design/20161119.2-1.good.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161119.2-2.bad.jpg","path":"assets/design/20161119.2-2.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161120.1-1.good.jpg","path":"assets/design/20161120.1-1.good.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161120.1-2.good.jpg","path":"assets/design/20161120.1-2.good.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161120.1-3.good.jpg","path":"assets/design/20161120.1-3.good.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161203.1-1.bad.jpg","path":"assets/design/20161203.1-1.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161211.1-1.bad.jpg","path":"assets/design/20161211.1-1.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161211.1-1.food.jpg","path":"assets/design/20161211.1-1.food.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161211.1-2.bad.jpg","path":"assets/design/20161211.1-2.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20161211.1-2.food.jpg","path":"assets/design/20161211.1-2.food.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20170702.1-1.bad.jpg","path":"assets/design/20170702.1-1.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20170702.1-1.good.jpg","path":"assets/design/20170702.1-1.good.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20180218.1-1.good.jpg","path":"assets/design/20180218.1-1.good.jpg","modified":1,"renderable":0},{"_id":"source/assets/design/20180630.1-1.bad.jpg","path":"assets/design/20180630.1-1.bad.jpg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/best-demo.jpeg","path":"assets/react-v15/best-demo.jpeg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/diff1.png","path":"assets/react-v15/diff1.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/diff2.png","path":"assets/react-v15/diff2.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/find-best.jpeg","path":"assets/react-v15/find-best.jpeg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/first-demo.jpeg","path":"assets/react-v15/first-demo.jpeg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-call.png","path":"assets/react-v15/react-call.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-first-render-component-element.png","path":"assets/react-v15/react-first-render-component-element.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-first-render-component-element.svg","path":"assets/react-v15/react-first-render-component-element.svg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-first-render-host-element.png","path":"assets/react-v15/react-first-render-host-element.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-first-render-host-element.svg","path":"assets/react-v15/react-first-render-host-element.svg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-render.png","path":"assets/react-v15/react-render.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-render.svg","path":"assets/react-v15/react-render.svg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-update-render-component-element.png","path":"assets/react-v15/react-update-render-component-element.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-update-render-component-element.svg","path":"assets/react-v15/react-update-render-component-element.svg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-update-render-host-element.png","path":"assets/react-v15/react-update-render-host-element.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react-update-render-host-element.svg","path":"assets/react-v15/react-update-render-host-element.svg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/react.drawio","path":"assets/react-v15/react.drawio","modified":1,"renderable":0},{"_id":"source/assets/react-v15/render-demo-pass.png","path":"assets/react-v15/render-demo-pass.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/render-pass.jpg","path":"assets/react-v15/render-pass.jpg","modified":1,"renderable":0},{"_id":"source/assets/react-v15/update-children-2-demo.png","path":"assets/react-v15/update-children-2-demo.png","modified":1,"renderable":0},{"_id":"source/assets/react-v15/update-children-demo.png","path":"assets/react-v15/update-children-demo.png","modified":1,"renderable":0},{"_id":"source/assets/tabs/Do-Re-Mi.jpg","path":"assets/tabs/Do-Re-Mi.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/London-Bridge-is-Falling-Down.jpg","path":"assets/tabs/London-Bridge-is-Falling-Down.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/夏威夷小曲子双音版.m4a","path":"assets/tabs/夏威夷小曲子双音版.m4a","modified":1,"renderable":0},{"_id":"source/assets/tabs/夏威夷小曲子（单音版）.jpg","path":"assets/tabs/夏威夷小曲子（单音版）.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/夏威夷小曲子（双音版）.jpg","path":"assets/tabs/夏威夷小曲子（双音版）.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/寂静之声.jpg","path":"assets/tabs/寂静之声.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/小星星（双音版）.jpg","path":"assets/tabs/小星星（双音版）.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/拉伸手指练习.jpg","path":"assets/tabs/拉伸手指练习.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/新年快乐.jpg","path":"assets/tabs/新年快乐.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/月亮代表我的心.jpg","path":"assets/tabs/月亮代表我的心.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/欢乐颂（双音版）.jpg","path":"assets/tabs/欢乐颂（双音版）.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/爬格子练习1.png","path":"assets/tabs/爬格子练习1.png","modified":1,"renderable":0},{"_id":"source/assets/tabs/爬格子练习2.png","path":"assets/tabs/爬格子练习2.png","modified":1,"renderable":0},{"_id":"source/assets/tabs/爬格子练习3.png","path":"assets/tabs/爬格子练习3.png","modified":1,"renderable":0},{"_id":"source/assets/tabs/生日快乐歌-F调.jpg","path":"assets/tabs/生日快乐歌-F调.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/生日快乐歌-G调.jpg","path":"assets/tabs/生日快乐歌-G调.jpg","modified":1,"renderable":0},{"_id":"source/assets/tabs/生日歌.png","path":"assets/tabs/生日歌.png","modified":1,"renderable":0},{"_id":"source/assets/tabs/青花瓷.m4a","path":"assets/tabs/青花瓷.m4a","modified":1,"renderable":0},{"_id":"source/images/economic-explanation-v1/Steven.Cheung's.Demand.jpg","path":"images/economic-explanation-v1/Steven.Cheung's.Demand.jpg","modified":1,"renderable":0},{"_id":"source/images/llvm-1/AST-v2.png","path":"images/llvm-1/AST-v2.png","modified":1,"renderable":0},{"_id":"source/images/llvm-1/AST.png","path":"images/llvm-1/AST.png","modified":1,"renderable":0},{"_id":"source/images/llvm-1/Expr.png","path":"images/llvm-1/Expr.png","modified":1,"renderable":0},{"_id":"source/images/llvm-1/FuncDef.png","path":"images/llvm-1/FuncDef.png","modified":1,"renderable":0},{"_id":"source/images/nand2tetris-1/CPU.png","path":"images/nand2tetris-1/CPU.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/MP_verify_wzdj75tMmTqbmmXI.txt","hash":"9d656334e6f6777688f7d6307b35089d9833b013","modified":1604221531981},{"_id":"source/CNAME","hash":"d7686cf95b0c82fda99f18e53929e0b5b92ac862","modified":1604379134271},{"_id":"source/_posts/java.md","hash":"b8d215c16782654739517f54ebb897d0094490db","modified":1606573382948},{"_id":"source/_posts/economic-explanation-v1.md","hash":"84d65268b99edb24cc63d5a86bab2ca06f351491","modified":1606573400148},{"_id":"source/_posts/llvm-0.md","hash":"9c5f078d478fa15bcb3bef9d95a5f3c1d7961a6d","modified":1605062907145},{"_id":"source/_posts/llvm-1.md","hash":"8b4f84b34eafaf15034e546ab6950a815a5d5d27","modified":1604221639045},{"_id":"source/_posts/nand2tetris-1.md","hash":"a83801d39071650dd1bc8ac52dd4f24ba7d861e9","modified":1606573420778},{"_id":"source/_posts/prize-in-economics-2017.md","hash":"45d545794965e631b365f166391ea486afdec73b","modified":1606573668497},{"_id":"source/_posts/react-1.md","hash":"0e14bf59a36df2c472c2a09205df3ef40f60ed97","modified":1606574148773},{"_id":"source/_posts/the-design-of-everyday-things.md","hash":"98d8c1a6521fa2f6d6199dad206298bc6ffbc9d7","modified":1606574316243},{"_id":"source/_posts/quickjs.md","hash":"1ab847357a7d28f1b0eaa8ae9a9be57d89d850ec","modified":1604221639046},{"_id":"source/_drafts/hexo-guide.md","hash":"7b7a07b29ce2825383d1d74ebb265bc3a5941087","modified":1604221639044},{"_id":"source/_posts/ukulele.md","hash":"ca959000f6032c45b984dda9d05a3320bede3641","modified":1606574336945},{"_id":"source/_posts/tspl4.md","hash":"ac578b0256360f33bb401d0c3f18ad0a1aa71c45","modified":1606573431210},{"_id":"source/_drafts/homebrew.md","hash":"96e1252945cee7832bcd753a45f0af26b96e71c3","modified":1604221639033},{"_id":"source/_drafts/keyword.md","hash":"fef0d92d077845331747db4b51d66200de07f441","modified":1604221639034},{"_id":"source/images/logo.jpg","hash":"576d1ad1ad886e33802a1071f678ca8af6575823","modified":1604221639053},{"_id":"source/_drafts/nand2tetris-2.md","hash":"bee7eb1a9fde2734ac295f7e5ed5a5a04a0f369d","modified":1604221639035},{"_id":"source/_drafts/react-2.md","hash":"c07ca5325b009ed24e9aa555097516cf86c82385","modified":1606573764692},{"_id":"source/_drafts/tetris.md","hash":"1c1af3db99f1265a8716bd2dad92ea2dd7a3a705","modified":1604221639043},{"_id":"source/_drafts/tetris.assets/image-20200726235018598.png","hash":"62f35c4810767e81a680928ea768b72710212ee1","modified":1604221639036},{"_id":"source/_drafts/tetris.assets/image-20200728233251358.png","hash":"14aca06b9368aea483eacea5223b09e1f8a39af7","modified":1604221639040},{"_id":"source/_drafts/tetris.assets/image-20200728233318286.png","hash":"be145c284880da847883f21106cc3ad2b5f7cdaa","modified":1604221639040},{"_id":"source/_drafts/tetris.assets/image-20200728233340150.png","hash":"7625e5473991eed1b47c48fd2e95b40671005665","modified":1604221639041},{"_id":"source/_drafts/tetris.assets/image-20200728233359263.png","hash":"41db35d7db0bc5588ad0e53ab49fbabb162aabd0","modified":1604221639041},{"_id":"source/_drafts/tetris.assets/image-20200728233415881.png","hash":"7ed1d32a6673d7973c001db45663b48654a5434f","modified":1604221639042},{"_id":"source/_drafts/tetris.assets/image-20200728233431364.png","hash":"01ffb8547564f1d666a6431358fd3a163adcbb81","modified":1604221639042},{"_id":"source/_drafts/tetris.assets/image-20200728233447992.png","hash":"032bf74911cc36526eb7de775096828c4dd799d3","modified":1604221639043},{"_id":"source/_drafts/tetris.assets/image-20200729002721907.png","hash":"33babef89a4b47d13ca9248a2a198c73f494f21c","modified":1604221639043},{"_id":"source/assets/react-v15/diff1.png","hash":"1ab418770d38e990cce6ad9687238ae9a77e1892","modified":1606572280412},{"_id":"source/assets/react-v15/diff2.png","hash":"b2afdef21e18ce8f7a90ff80d042ad0469b07b6d","modified":1606572280412},{"_id":"source/assets/react-v15/react-first-render-component-element.svg","hash":"022d9469e2c3a0db3fe0f50e628dcbf81c4a2bcf","modified":1606572280420},{"_id":"source/assets/react-v15/react-first-render-host-element.svg","hash":"ab862cbad6b550dd8128da3fb6c2f886aade8cf2","modified":1606572280420},{"_id":"source/assets/react-v15/react-render.svg","hash":"3c65b974de871919c2f51c944dc646dc210b3b95","modified":1606572280422},{"_id":"source/assets/react-v15/react-update-render-component-element.svg","hash":"7159d0b9950ae5f4c8280889f4b310d7c1621d5f","modified":1606572280424},{"_id":"source/assets/react-v15/react-update-render-host-element.svg","hash":"677c9e349065d29c7e99164a6e44cbd926e4e19d","modified":1606572280425},{"_id":"source/assets/react-v15/update-children-2-demo.png","hash":"1dd8853e493e5dcc45ea5359d0febfcd023abc0b","modified":1606572280428},{"_id":"source/assets/react-v15/react.drawio","hash":"ab64e43f7e10cf37c9f2138c32748c84637e275f","modified":1606572280425},{"_id":"source/images/economic-explanation-v1/Steven.Cheung's.Demand.jpg","hash":"cc1c1aa94bda77d512428dc2c21202346416ace1","modified":1606572280448},{"_id":"source/images/llvm-1/Expr.png","hash":"adf1665e19ede9566372fdaba3ede07faea70af2","modified":1604221639051},{"_id":"source/images/nand2tetris-1/CPU.png","hash":"b9927effbf9978ebdeba813eb8263a3daca7ffd6","modified":1604221639053},{"_id":"source/_drafts/tetris.assets/image-20200728000757270.png","hash":"40060a8f827854bca6af828dc53a4d4b9193b045","modified":1604221639036},{"_id":"source/_drafts/tetris.assets/image-20200728001916873.png","hash":"fc930686b222e7851fe68263e78035317f382899","modified":1604221639037},{"_id":"source/assets/design/20161119.1-1.good.jpg","hash":"23e9e561b4149dd950d2dc179293ab66491284f5","modified":1606572280450},{"_id":"source/assets/design/20161119.1-1.bad.jpg","hash":"358d88f40c800684568adef398cbb6b7b80cf3ff","modified":1606572280449},{"_id":"source/assets/design/20161119.2-1.good.jpg","hash":"504797a7f6763aa2e68301f51e6ab710081940a0","modified":1606572280452},{"_id":"source/assets/design/20161119.2-2.bad.jpg","hash":"7e4214a17a452babe89fc27541e74a148446e8a9","modified":1606572280453},{"_id":"source/assets/react-v15/react-first-render-host-element.png","hash":"269026d1b1c3a0d66f5a31b020445c29aacdcd83","modified":1606572280420},{"_id":"source/assets/react-v15/react-first-render-component-element.png","hash":"00ca95201c4adc8a11ab7d02d2c9f9b1d3a056c8","modified":1606572280419},{"_id":"source/assets/react-v15/render-pass.jpg","hash":"ed07290b52120d74a4a818f83affa7369f8d394b","modified":1606572280427},{"_id":"source/assets/react-v15/update-children-demo.png","hash":"f957c6aa20fafa3c44af3f5aecede79234b3614a","modified":1606572280428},{"_id":"source/assets/tabs/生日歌.png","hash":"a0b23fdd8a9a1a284153a7d2b578b393ec74ff90","modified":1606572280506},{"_id":"source/_drafts/nand2tetris-2.assets/image-20200726213820736.png","hash":"1fdd680c3d5eb9706d2fe613af8b55c999b5f9d5","modified":1604221639035},{"_id":"themes/hexo-theme-landscape/.travis.yml","hash":"0f850b4da6ba203ddc399bd7ffd675ca4e3da791","modified":1604222433797},{"_id":"themes/hexo-theme-landscape/.gitignore","hash":"4c78c751a5bbca6b54ad06922947573c967d51c8","modified":1604222433797},{"_id":"themes/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1604222433797},{"_id":"themes/hexo-theme-landscape/_config.yml","hash":"33a60bb6efd5e8d61e25b893e5da145f34931a05","modified":1604222433797},{"_id":"themes/hexo-theme-landscape/README.md","hash":"f723575f1243852b8bec9ba05004500b943e20f1","modified":1604222433797},{"_id":"themes/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1604222433797},{"_id":"themes/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1604222433798},{"_id":"source/_drafts/tetris.assets/image-20200728002726065.png","hash":"df038906124b5b1f2cc4594d896c07cfa874e30c","modified":1604221639040},{"_id":"themes/hexo-theme-landscape/package.json","hash":"c35345c642b4ec5287728d3a9e76f5fbeeb8b81c","modified":1604222433803},{"_id":"themes/hexo-theme-landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1604222433797},{"_id":"themes/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1604222433798},{"_id":"themes/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1604222433798},{"_id":"themes/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1604222433798},{"_id":"themes/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1604222433798},{"_id":"themes/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1604222433798},{"_id":"themes/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1604222433798},{"_id":"themes/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1604222433798},{"_id":"themes/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1604222433799},{"_id":"themes/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1604222433799},{"_id":"themes/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1604222433799},{"_id":"themes/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1604222433799},{"_id":"themes/hexo-theme-landscape/languages/zh-CN.yml","hash":"88c5beedec7042d388755278e3cd9f4296a6ed93","modified":1604222433799},{"_id":"themes/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1604222433799},{"_id":"themes/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1604222433802},{"_id":"themes/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1604222433803},{"_id":"source/_drafts/tetris.assets/image-20200728002438656.png","hash":"0ec9a44e92e564bbcc97420d475504400691f7a8","modified":1604221639038},{"_id":"themes/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1604222433803},{"_id":"themes/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1604222433803},{"_id":"themes/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1604222433803},{"_id":"themes/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1604222433804},{"_id":"themes/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1604222433803},{"_id":"themes/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1604222433803},{"_id":"themes/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1604222433799},{"_id":"themes/hexo-theme-landscape/layout/_partial/analytics.ejs","hash":"76b5b8caba94e6e9e5b876497d0874367908f388","modified":1604222433800},{"_id":"themes/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1604222433800},{"_id":"themes/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1604222433800},{"_id":"themes/hexo-theme-landscape/layout/_partial/article.ejs","hash":"bddc9ad29f14f2e729c383cb49eb1f84885e7a84","modified":1604222433800},{"_id":"themes/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"8488955d4a8e1459aff71eb6747f647663774b42","modified":1604222433800},{"_id":"themes/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1604222433800},{"_id":"themes/hexo-theme-landscape/layout/_partial/header.ejs","hash":"b33c990e3949c04a034aafd85726e7a3dddde7e4","modified":1604222433801},{"_id":"themes/hexo-theme-landscape/layout/_partial/head.ejs","hash":"7c7c17e58292bd3e463a489b7ca70b7ae66242d3","modified":1604222433800},{"_id":"themes/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1604222433801},{"_id":"themes/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1604222433802},{"_id":"themes/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1604222433802},{"_id":"themes/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1604222433802},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1604222433815},{"_id":"themes/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1604222433802},{"_id":"themes/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1604222433802},{"_id":"themes/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1604222433804},{"_id":"themes/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1606574487144},{"_id":"themes/hexo-theme-landscape/source/css/_variables.styl","hash":"7fda3cc85720b15b2a8fd60d1cf1af73c83f7266","modified":1604222433806},{"_id":"themes/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1604222433815},{"_id":"themes/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1604222433817},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1604222433801},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1604222433801},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1604222433801},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1604222433801},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1604222433801},{"_id":"themes/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1604222433804},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"ea7378678babaa81221f6c53d842f506ff87bcd8","modified":1604222433802},{"_id":"themes/hexo-theme-landscape/source/css/_partial/article.styl","hash":"1acfe8585f979d7343adc9e5b31e7d77d223cfdc","modified":1606573113613},{"_id":"themes/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1604222433804},{"_id":"themes/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"b45dcda3db2daf4389a300c5865976e085bc938b","modified":1604222433804},{"_id":"themes/hexo-theme-landscape/source/css/_partial/header.styl","hash":"2f9c5af0579315f569965cbad65a46cff113da40","modified":1604222433805},{"_id":"themes/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"59caa575ad47d4e3e5361b9744f305ff2c314d18","modified":1606573216572},{"_id":"themes/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1604222433805},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1604222433805},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1604222433805},{"_id":"themes/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1604222433806},{"_id":"themes/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1604222433806},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1604222433805},{"_id":"source/assets/design/20161119.2-1.bad.jpg","hash":"26434e3a5ee6722e36923627d6cdbf174d7d972a","modified":1606572280451},{"_id":"source/assets/react-v15/best-demo.jpeg","hash":"873a38f914a69eb69915af12d97f420929f9a51a","modified":1606572280411},{"_id":"source/assets/react-v15/first-demo.jpeg","hash":"56a82e120491e5944b02148c8c6259ae32730574","modified":1606572280416},{"_id":"source/assets/react-v15/render-demo-pass.png","hash":"1fc7dd674c0d941b89cfa67b7afaff45f4073bf1","modified":1606572280427},{"_id":"source/assets/react-v15/react-update-render-host-element.png","hash":"7074ff21ec0ac776879823fae31e73dc81b9ea86","modified":1606572280425},{"_id":"source/assets/tabs/月亮代表我的心.jpg","hash":"07f6850441119b1f1204d751e04fd077b2acf2ea","modified":1606572280497},{"_id":"source/images/llvm-1/AST.png","hash":"54d56189987065bdcf2ed33df853a379fb0b4d0e","modified":1604221639050},{"_id":"source/images/llvm-1/FuncDef.png","hash":"b143a92571c35bffc93a79190d464ae5c2f9059c","modified":1604221639052},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1604222433816},{"_id":"themes/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1604222433817},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1604222433813},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1604222433813},{"_id":"source/assets/design/20161120.1-2.good.jpg","hash":"141c176a94ce420d4a597f336dd89777cff67b36","modified":1606572280455},{"_id":"source/assets/design/20161203.1-1.bad.jpg","hash":"57a05eaa44b2586d71a5181afb5c8f27842b1a98","modified":1606572280457},{"_id":"source/assets/design/20180218.1-1.good.jpg","hash":"b4dd5c9d5e50c7e70bbc0f10839ba63fe6effc94","modified":1606572280466},{"_id":"source/assets/tabs/夏威夷小曲子双音版.m4a","hash":"65ce1e8278d5fb06cefbb37072ecde2730ea632e","modified":1606572280484},{"_id":"source/assets/tabs/寂静之声.jpg","hash":"65daa4b56dc7505a30b64f1ca03309d16348b2b4","modified":1606572280490},{"_id":"source/assets/tabs/生日快乐歌-F调.jpg","hash":"50b7b5045136c5c37bd6b7620634c8de7496158d","modified":1606572280505},{"_id":"source/assets/tabs/生日快乐歌-G调.jpg","hash":"a80eacd47610cb9cca9a9319e091827266c71643","modified":1606572280506},{"_id":"source/images/llvm-1/AST-v2.png","hash":"201fd40968318ff6bb32bbd211d36c4552cbf3df","modified":1604221639049},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1604222433809},{"_id":"themes/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1604222433807},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1604222433812},{"_id":"source/assets/design/20161211.1-2.bad.jpg","hash":"42a379e53e449dc3a12fd3a75a5df5deadfbb04e","modified":1606572280461},{"_id":"source/assets/design/20161211.1-1.food.jpg","hash":"f49b65a758473253369887ce090f67e87db1627f","modified":1606572280460},{"_id":"source/assets/design/20161211.1-2.food.jpg","hash":"96a8460ba8ed0cec90179ee74c8ebbef32312daf","modified":1606572280463},{"_id":"source/assets/react-v15/react-update-render-component-element.png","hash":"4f2790db05c4e72fb3347e92459f5c867dfbfe92","modified":1606572280424},{"_id":"source/assets/tabs/青花瓷.m4a","hash":"c8d8f48d3aae103ae2297753d303506d73c1211b","modified":1606572280507},{"_id":"source/assets/design/20161120.1-3.good.jpg","hash":"0a0b5faf15647861685674f80dafc922788dbf90","modified":1606572280456},{"_id":"source/assets/react-v15/react-call.png","hash":"226da1748bc30300d9d4d307fac563fcfb30fd3b","modified":1606572280418},{"_id":"source/assets/react-v15/react-render.png","hash":"a1a90e9e0dbff79bb38af233d1e4603717664610","modified":1606572280422},{"_id":"source/assets/tabs/爬格子练习1.png","hash":"fef03fe1fce25d327bb507732d7721f90bcd320c","modified":1606572280501},{"_id":"source/assets/tabs/爬格子练习2.png","hash":"73b2cd233d2ab09c6d1070607fd6fc408fe6f72d","modified":1606572280503},{"_id":"source/assets/tabs/爬格子练习3.png","hash":"91293415086fe03a7ff9f81bcbe59463cc3eb28f","modified":1606572280504},{"_id":"source/assets/design/20161211.1-1.bad.jpg","hash":"0372d40cd53d415358d2f5b9dce17566e0b8dace","modified":1606572280458},{"_id":"themes/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1604222433815},{"_id":"source/assets/design/20161120.1-1.good.jpg","hash":"b1834d8185fb7884358e5bf540f082124e77f243","modified":1606572280454},{"_id":"source/assets/tabs/Do-Re-Mi.jpg","hash":"81999c9102fd8741d3feb6554facbbee92e8adc5","modified":1606572280482},{"_id":"source/assets/tabs/London-Bridge-is-Falling-Down.jpg","hash":"4e72cc5ac1cfb42d326e82046436b0d925af7267","modified":1606572280483},{"_id":"source/assets/tabs/欢乐颂（双音版）.jpg","hash":"82ceab09ee63046a15e19ed6b4607e6115d80ef7","modified":1606572280500},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1604222433811},{"_id":"source/assets/react-v15/find-best.jpeg","hash":"eb827ff33e0d37a623488ea07962440a936f66d8","modified":1606572280415},{"_id":"source/assets/tabs/小星星（双音版）.jpg","hash":"9f96f180366e33bfcd7775e43aa05dbb8798ea30","modified":1606572280491},{"_id":"source/assets/design/20180630.1-1.bad.jpg","hash":"b8e61b9f1b69b3c56888844d7023e8ace739aca0","modified":1606572280467},{"_id":"source/assets/tabs/新年快乐.jpg","hash":"4664f81526ec22cea7fa155b11d2db8c6cfa2909","modified":1606572280496},{"_id":"source/assets/design/20170702.1-1.good.jpg","hash":"b8d7166ae3e6999254521418898316b8685c4619","modified":1606572280465},{"_id":"source/assets/tabs/夏威夷小曲子（单音版）.jpg","hash":"57a5a5b8db1ddca4d390b2eaec1835ebc513959d","modified":1606572280486},{"_id":"source/assets/design/20170702.1-1.bad.jpg","hash":"f4b1e56180028c35c850e148864816eb9616956a","modified":1606572280464},{"_id":"source/assets/tabs/夏威夷小曲子（双音版）.jpg","hash":"f838f20f3f5628d7ace4f520dcc68d0bcc5d5e5d","modified":1606572280488},{"_id":"source/assets/tabs/拉伸手指练习.jpg","hash":"4bb01a5d3effb49d287f6e2ec5ed807e3b244809","modified":1606572280495},{"_id":"public/2020/07/02/quickjs/index.html","hash":"f6fefc231586f28c9daf58121671abac11c71453","modified":1606574517850},{"_id":"public/archives/index.html","hash":"37555630edcd18388b8dfa46506fb0ce6d8b3fa9","modified":1606574517850},{"_id":"public/archives/page/2/index.html","hash":"54de332d064dd182042f053f18a68bba80060548","modified":1606574517850},{"_id":"public/archives/page/3/index.html","hash":"0faab5428f2037c43b8031ca9e63414a06337a47","modified":1606574517850},{"_id":"public/archives/page/4/index.html","hash":"8fcca072030ab9c661afc7e2624ea900a64be495","modified":1606574517850},{"_id":"public/archives/page/5/index.html","hash":"f9d6a87455d5b3ed7e90888fe3a43b1a528c3860","modified":1606574517850},{"_id":"public/archives/page/6/index.html","hash":"1cf54972ab3eecfbd0b187057f41540a06bfe962","modified":1606574517850},{"_id":"public/archives/2016/index.html","hash":"37402f26379a2952dc44c45614dd9608a066ad61","modified":1606574517850},{"_id":"public/archives/2016/09/index.html","hash":"098118f2345b677d14699e672077bc0f022fcc97","modified":1606574517850},{"_id":"public/archives/2017/index.html","hash":"12ff8abef868ff22a61033d443b1951d1e1e699c","modified":1606574517850},{"_id":"public/archives/2017/page/2/index.html","hash":"28e8d2d5a3331f5277d09a8d494883a262a99f75","modified":1606574517850},{"_id":"public/archives/2017/02/index.html","hash":"d33b646c28fac7e5a84a0f3d9c53e246f7056486","modified":1606574517850},{"_id":"public/archives/2017/03/index.html","hash":"4a5622ab9c4c9269dabf873b256d92fec5e8fe1e","modified":1606574517850},{"_id":"public/archives/2017/10/index.html","hash":"2d5ab101d776532d39ab629619c8b72104e20775","modified":1606574517850},{"_id":"public/archives/2018/index.html","hash":"1af030f06057a282591e92d470b02269eca8ae60","modified":1606574517850},{"_id":"public/archives/2018/06/index.html","hash":"eaba840c748a8b390aee066da9f255d3dac72c2f","modified":1606574517850},{"_id":"public/archives/2018/11/index.html","hash":"88a55e4abb45a19f9cfa7ae6b0c411eb0c69a5d1","modified":1606574517850},{"_id":"public/archives/2019/index.html","hash":"d8d22ca8ab54721c13939474219dea1e83a07f07","modified":1606574517850},{"_id":"public/archives/2019/05/index.html","hash":"be2106a8b67f0dcdc15ba1b36d0e9bccec6efd00","modified":1606574517850},{"_id":"public/archives/2020/index.html","hash":"0f24ede881bd20c8fdbe2dcc3ee99914de90d710","modified":1606574517850},{"_id":"public/archives/2020/page/2/index.html","hash":"1aa38274ef13ee4806b7ba2c25ddb5286692864d","modified":1606574517850},{"_id":"public/archives/2020/06/index.html","hash":"47511dac8a84529dcfe50103d5c1904209436ed9","modified":1606574517850},{"_id":"public/archives/2020/07/index.html","hash":"53a6930f3f38ba417b31bd9a8ca3b8cebdc18509","modified":1606574517850},{"_id":"public/archives/2020/07/page/2/index.html","hash":"e35587b63f0bb46b6c10e0430a7bd9124d33bde0","modified":1606574517850},{"_id":"public/tags/llvm/index.html","hash":"8cce493162b5c836462a15a0b295c2818b09af50","modified":1606574517850},{"_id":"public/tags/java/index.html","hash":"ed4121309e89ed8e3619c45b945c1bfb0db0a74c","modified":1606574517850},{"_id":"public/tags/nand2tetris/index.html","hash":"fd6c1f26baea33ef8eaa987f28e260de7f528460","modified":1606574517850},{"_id":"public/tags/经济学/index.html","hash":"8aa57e2bb3df2172bdfaedc78c6220730b96f984","modified":1606574517850},{"_id":"public/tags/js/index.html","hash":"366688db0066517ade3792f933587a1c28d858ec","modified":1606574517850},{"_id":"public/tags/quickjs/index.html","hash":"fb4de9a6cb6da625eda8a93d77d1767caea8c217","modified":1606574517850},{"_id":"public/tags/design/index.html","hash":"a39e5bcb8b090d65d7d9324e0c9cceea6401de18","modified":1606574517850},{"_id":"public/tags/ukulele/index.html","hash":"968dda4a7771441b5867cb4e34a60d1044ee157d","modified":1606574517850},{"_id":"public/tags/econ/index.html","hash":"4d0e9a7d985da7fa0c832171da7f2d602d3077dd","modified":1606574517850},{"_id":"public/tags/note/index.html","hash":"fc52e12b708bb880a3a8f71551e9c7ef6232ad15","modified":1606574517850},{"_id":"public/tags/scheme/index.html","hash":"463f2a455657f6de7fa77e3e8ec368e4b538e1ef","modified":1606574517850},{"_id":"public/categories/llvm/index.html","hash":"4da45feab4cd23070083a50ac2ad1ef7e4a48536","modified":1606574517850},{"_id":"public/categories/note/index.html","hash":"7e65137b9307496b007c250ba33a34fcb15516f7","modified":1606574517850},{"_id":"public/categories/note/page/2/index.html","hash":"3ae8d2ae799c2dd0b974146ef49cef3596b8d3f0","modified":1606574517850},{"_id":"public/categories/note/page/3/index.html","hash":"1d3399172a642bdcc7401227b95b21f0ecb777ef","modified":1606574517850},{"_id":"public/categories/评论/index.html","hash":"e67ed60d9c0d3e6b9f806c456a8919597fe4fb09","modified":1606574517850},{"_id":"public/categories/js/index.html","hash":"3a215cd57969f1c188f37c704047a6236eea27d1","modified":1606574517850},{"_id":"public/categories/react/index.html","hash":"0c11ea2e137bb14c6a33546ce5153ef7615d71f3","modified":1606574517850},{"_id":"public/2020/07/17/nand2tetris-1/index.html","hash":"b9a746646e7b9936319155570f3e359269c4990b","modified":1606574517850},{"_id":"public/2020/07/09/llvm-1/index.html","hash":"83047142c50dcc14922da7e2d312302201ffd6a3","modified":1606574517850},{"_id":"public/2020/06/25/llvm-0/index.html","hash":"1687c92d0906a5f2eb62ba77a2871479dd108131","modified":1606574517850},{"_id":"public/2019/05/13/react-1/index.html","hash":"90f58140c6f87866e32a05d5cf9121451b81756a","modified":1606574517850},{"_id":"public/2018/11/04/ukulele/index.html","hash":"20aab27103e269df02485a549bc06aa862f652cd","modified":1606574517850},{"_id":"public/2018/06/30/the-design-of-everyday-things/index.html","hash":"a677826b1daf27f8d9a7f3ad4759f8a142905512","modified":1606574517850},{"_id":"public/2017/10/17/prize-in-economics-2017/index.html","hash":"63207935734d437594068fbd44c2d3d1b1fc8df1","modified":1606574517850},{"_id":"public/2017/03/15/java/index.html","hash":"1cdbfea40ea3ba2663e6c8e599179718c59dd0eb","modified":1606574517850},{"_id":"public/2017/02/04/tspl4/index.html","hash":"866d5528d83551b52be86a59a16d4de6de080807","modified":1606574517850},{"_id":"public/2016/09/22/economic-explanation-v1/index.html","hash":"b89090178636851f2349b6b5363d5997f1093f8b","modified":1606574517850},{"_id":"public/index.html","hash":"8071e20d4686c6ee47b2d7993c1b5b02088c1bac","modified":1606574517850},{"_id":"public/CNAME","hash":"d7686cf95b0c82fda99f18e53929e0b5b92ac862","modified":1606574517850},{"_id":"public/MP_verify_wzdj75tMmTqbmmXI.txt","hash":"9d656334e6f6777688f7d6307b35089d9833b013","modified":1606574517850},{"_id":"public/images/logo.jpg","hash":"576d1ad1ad886e33802a1071f678ca8af6575823","modified":1606574517850},{"_id":"public/assets/react-v15/diff2.png","hash":"b2afdef21e18ce8f7a90ff80d042ad0469b07b6d","modified":1606574517850},{"_id":"public/assets/react-v15/diff1.png","hash":"1ab418770d38e990cce6ad9687238ae9a77e1892","modified":1606574517850},{"_id":"public/assets/react-v15/react-first-render-component-element.svg","hash":"022d9469e2c3a0db3fe0f50e628dcbf81c4a2bcf","modified":1606574517850},{"_id":"public/assets/react-v15/react-first-render-host-element.svg","hash":"ab862cbad6b550dd8128da3fb6c2f886aade8cf2","modified":1606574517850},{"_id":"public/assets/react-v15/react-render.svg","hash":"3c65b974de871919c2f51c944dc646dc210b3b95","modified":1606574517850},{"_id":"public/assets/react-v15/react-update-render-component-element.svg","hash":"7159d0b9950ae5f4c8280889f4b310d7c1621d5f","modified":1606574517850},{"_id":"public/assets/react-v15/react-update-render-host-element.svg","hash":"677c9e349065d29c7e99164a6e44cbd926e4e19d","modified":1606574517850},{"_id":"public/assets/react-v15/react.drawio","hash":"ab64e43f7e10cf37c9f2138c32748c84637e275f","modified":1606574517850},{"_id":"public/assets/react-v15/update-children-2-demo.png","hash":"1dd8853e493e5dcc45ea5359d0febfcd023abc0b","modified":1606574517850},{"_id":"public/images/economic-explanation-v1/Steven.Cheung's.Demand.jpg","hash":"cc1c1aa94bda77d512428dc2c21202346416ace1","modified":1606574517850},{"_id":"public/images/llvm-1/Expr.png","hash":"adf1665e19ede9566372fdaba3ede07faea70af2","modified":1606574517850},{"_id":"public/images/nand2tetris-1/CPU.png","hash":"b9927effbf9978ebdeba813eb8263a3daca7ffd6","modified":1606574517850},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1606574517850},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1606574517850},{"_id":"public/assets/design/20161119.1-1.bad.jpg","hash":"358d88f40c800684568adef398cbb6b7b80cf3ff","modified":1606574517850},{"_id":"public/assets/design/20161119.2-1.good.jpg","hash":"504797a7f6763aa2e68301f51e6ab710081940a0","modified":1606574517850},{"_id":"public/assets/design/20161119.1-1.good.jpg","hash":"23e9e561b4149dd950d2dc179293ab66491284f5","modified":1606574517850},{"_id":"public/assets/design/20161119.2-2.bad.jpg","hash":"7e4214a17a452babe89fc27541e74a148446e8a9","modified":1606574517850},{"_id":"public/assets/react-v15/react-first-render-component-element.png","hash":"00ca95201c4adc8a11ab7d02d2c9f9b1d3a056c8","modified":1606574517850},{"_id":"public/assets/react-v15/react-first-render-host-element.png","hash":"269026d1b1c3a0d66f5a31b020445c29aacdcd83","modified":1606574517850},{"_id":"public/assets/react-v15/render-pass.jpg","hash":"ed07290b52120d74a4a818f83affa7369f8d394b","modified":1606574517850},{"_id":"public/assets/react-v15/update-children-demo.png","hash":"f957c6aa20fafa3c44af3f5aecede79234b3614a","modified":1606574517850},{"_id":"public/assets/tabs/生日歌.png","hash":"a0b23fdd8a9a1a284153a7d2b578b393ec74ff90","modified":1606574517850},{"_id":"public/images/llvm-1/FuncDef.png","hash":"b143a92571c35bffc93a79190d464ae5c2f9059c","modified":1606574517850},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1606574517850},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1606574517850},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1606574517850},{"_id":"public/assets/react-v15/best-demo.jpeg","hash":"873a38f914a69eb69915af12d97f420929f9a51a","modified":1606574517850},{"_id":"public/assets/react-v15/first-demo.jpeg","hash":"56a82e120491e5944b02148c8c6259ae32730574","modified":1606574517850},{"_id":"public/assets/react-v15/react-update-render-component-element.png","hash":"4f2790db05c4e72fb3347e92459f5c867dfbfe92","modified":1606574517850},{"_id":"public/assets/react-v15/react-update-render-host-element.png","hash":"7074ff21ec0ac776879823fae31e73dc81b9ea86","modified":1606574517850},{"_id":"public/assets/react-v15/render-demo-pass.png","hash":"1fc7dd674c0d941b89cfa67b7afaff45f4073bf1","modified":1606574517850},{"_id":"public/assets/tabs/月亮代表我的心.jpg","hash":"07f6850441119b1f1204d751e04fd077b2acf2ea","modified":1606574517850},{"_id":"public/assets/tabs/青花瓷.m4a","hash":"c8d8f48d3aae103ae2297753d303506d73c1211b","modified":1606574517850},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1606574517850},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1606574517850},{"_id":"public/css/style.css","hash":"16b8099853e77f52449a0e1201f4c113fdae36f4","modified":1606574517850},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1606574517850},{"_id":"public/assets/design/20161119.2-1.bad.jpg","hash":"26434e3a5ee6722e36923627d6cdbf174d7d972a","modified":1606574517850},{"_id":"public/assets/design/20161120.1-2.good.jpg","hash":"141c176a94ce420d4a597f336dd89777cff67b36","modified":1606574517850},{"_id":"public/assets/design/20161203.1-1.bad.jpg","hash":"57a05eaa44b2586d71a5181afb5c8f27842b1a98","modified":1606574517850},{"_id":"public/assets/design/20180218.1-1.good.jpg","hash":"b4dd5c9d5e50c7e70bbc0f10839ba63fe6effc94","modified":1606574517850},{"_id":"public/assets/tabs/夏威夷小曲子双音版.m4a","hash":"65ce1e8278d5fb06cefbb37072ecde2730ea632e","modified":1606574517850},{"_id":"public/assets/tabs/寂静之声.jpg","hash":"65daa4b56dc7505a30b64f1ca03309d16348b2b4","modified":1606574517850},{"_id":"public/assets/tabs/生日快乐歌-F调.jpg","hash":"50b7b5045136c5c37bd6b7620634c8de7496158d","modified":1606574517850},{"_id":"public/images/llvm-1/AST.png","hash":"54d56189987065bdcf2ed33df853a379fb0b4d0e","modified":1606574517850},{"_id":"public/assets/design/20161211.1-1.food.jpg","hash":"f49b65a758473253369887ce090f67e87db1627f","modified":1606574517850},{"_id":"public/assets/design/20161211.1-2.food.jpg","hash":"96a8460ba8ed0cec90179ee74c8ebbef32312daf","modified":1606574517850},{"_id":"public/assets/react-v15/react-call.png","hash":"226da1748bc30300d9d4d307fac563fcfb30fd3b","modified":1606574517850},{"_id":"public/assets/tabs/生日快乐歌-G调.jpg","hash":"a80eacd47610cb9cca9a9319e091827266c71643","modified":1606574517850},{"_id":"public/images/llvm-1/AST-v2.png","hash":"201fd40968318ff6bb32bbd211d36c4552cbf3df","modified":1606574517850},{"_id":"public/assets/design/20161211.1-1.bad.jpg","hash":"0372d40cd53d415358d2f5b9dce17566e0b8dace","modified":1606574517850},{"_id":"public/assets/tabs/爬格子练习1.png","hash":"fef03fe1fce25d327bb507732d7721f90bcd320c","modified":1606574517850},{"_id":"public/assets/tabs/爬格子练习2.png","hash":"73b2cd233d2ab09c6d1070607fd6fc408fe6f72d","modified":1606574517850},{"_id":"public/assets/tabs/爬格子练习3.png","hash":"91293415086fe03a7ff9f81bcbe59463cc3eb28f","modified":1606574517850},{"_id":"public/assets/design/20161120.1-3.good.jpg","hash":"0a0b5faf15647861685674f80dafc922788dbf90","modified":1606574517850},{"_id":"public/assets/design/20161211.1-2.bad.jpg","hash":"42a379e53e449dc3a12fd3a75a5df5deadfbb04e","modified":1606574517850},{"_id":"public/assets/react-v15/find-best.jpeg","hash":"eb827ff33e0d37a623488ea07962440a936f66d8","modified":1606574517850},{"_id":"public/assets/react-v15/react-render.png","hash":"a1a90e9e0dbff79bb38af233d1e4603717664610","modified":1606574517850},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1606574517850},{"_id":"public/assets/tabs/欢乐颂（双音版）.jpg","hash":"82ceab09ee63046a15e19ed6b4607e6115d80ef7","modified":1606574517850},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1606574517850},{"_id":"public/assets/tabs/Do-Re-Mi.jpg","hash":"81999c9102fd8741d3feb6554facbbee92e8adc5","modified":1606574517850},{"_id":"public/assets/tabs/小星星（双音版）.jpg","hash":"9f96f180366e33bfcd7775e43aa05dbb8798ea30","modified":1606574517850},{"_id":"public/assets/design/20161120.1-1.good.jpg","hash":"b1834d8185fb7884358e5bf540f082124e77f243","modified":1606574517850},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1606574517850},{"_id":"public/assets/tabs/London-Bridge-is-Falling-Down.jpg","hash":"4e72cc5ac1cfb42d326e82046436b0d925af7267","modified":1606574517850},{"_id":"public/assets/tabs/新年快乐.jpg","hash":"4664f81526ec22cea7fa155b11d2db8c6cfa2909","modified":1606574517850},{"_id":"public/assets/design/20170702.1-1.bad.jpg","hash":"f4b1e56180028c35c850e148864816eb9616956a","modified":1606574517850},{"_id":"public/assets/design/20170702.1-1.good.jpg","hash":"b8d7166ae3e6999254521418898316b8685c4619","modified":1606574517850},{"_id":"public/assets/design/20180630.1-1.bad.jpg","hash":"b8e61b9f1b69b3c56888844d7023e8ace739aca0","modified":1606574517850},{"_id":"public/assets/tabs/夏威夷小曲子（单音版）.jpg","hash":"57a5a5b8db1ddca4d390b2eaec1835ebc513959d","modified":1606574517850},{"_id":"public/assets/tabs/夏威夷小曲子（双音版）.jpg","hash":"f838f20f3f5628d7ace4f520dcc68d0bcc5d5e5d","modified":1606574517850},{"_id":"public/assets/tabs/拉伸手指练习.jpg","hash":"4bb01a5d3effb49d287f6e2ec5ed807e3b244809","modified":1606574517850}],"Category":[{"name":"llvm","_id":"cki1szjzs0002rnq70kjy6s6u"},{"name":"note","_id":"cki1szjzv0007rnq74tej3gmi"},{"name":"评论","_id":"cki1szk00000jrnq7dzqw97nz"},{"name":"js","_id":"cki1szk02000prnq72eabcaqw"},{"name":"guide","_id":"cki1szk03000urnq7gku82efl"},{"name":"software","_id":"cki1szk03000xrnq7cg7e10u0"},{"name":"笔记","_id":"cki1szk07001crnq7ax9hbuip"},{"name":"react","_id":"cki1szk0b001prnq78xkx15yt"}],"Data":[],"Page":[],"Post":[{"title":"学习LLVM第0篇：LLVM项目介绍","date":"2020-06-25T13:55:21.000Z","excerpt":"本文学习LLVM的第0篇文章，介绍LLVM项目的一些内容，包括如何构建命令行工具和本地文档、常用LLVM命令的使用。目的是为了后续研究LLVM作准备。","_content":"\n更全面的内容请直接参考[官方文档](https://llvm.org/docs)，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。\n\n\n\n## 编译项目\n\n1. 安装[CMake](https://cmake.org)、[Ninja](https://ninja-build.org)构建工具。\n   \n   这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。\n   \n   Mac系统建议使用[Brew](https://brew.sh)来安装，`brew install cmake ninja`，如果还需要编译文档，则需要安装doxygen、sphinx-doc，安装命令：`pip install sphinx=1.8.5`（使用brew安装时找不到这个版本的sphinx）、`brew install doxygen`。\n   \n2. 克隆LLVM仓库：`git clone https://github.com/llvm/llvm-project`\n\n   如果国内clone太慢，也可以使用Gitee提供的镜像仓库 https://gitee.com/mirrors/LLVM （注意：镜像仓库目前每天同步一次，所以内容会有延后）\n\n3. 创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：`mkdir build`，然后进到构建目录： `cd build`\n\n4. 生成构建系统：`cmake -G Ninja -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\" ../llvm`\n\n   常用参数：\n\n   - `LLVM_ENABLE_PROJECTS`：比如`\"clang;libcxx\"`。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如`clang`、`clang-tools-extra`、`libcxx`、`libc`等。\n\n     小提示：所有支持的项目可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_PROJECTS`变量的内容。当前的内容为：`clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl`\n\n   - `LLVM_TARGETS_TO_BUILD`：比如`\"X86;RISCV\"`。指定LLVM后端支持的目标架构，比如`X86`、`ARM`、`RISCV`、`WebAssembly`\n\n     小提示：所有支持的目标架构可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_TARGETS`变量的内容。当前的内容为：`AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore`\n\n   - `LLVM_ENABLE_SPHINX`：是否编译LLVM文档。`ON`表示启动。依赖[Sphinx](https://www.sphinx-doc.org)\n\n   - `LLVM_ENABLE_DOXYGEN`：是否编译LLVM API文档。`ON`表示启动。依赖[Doxygen](https://www.doxygen.nl)\n\n5. 进行构建：\n\n   - `cmake --build .` 表示编译默认目标包括LLVM和`LLVM_ENABLE_PROJECTS`指定的项目\n\n   - `cmake --build . --target docs-llvm-html` 表示只编译LLVM文档\n\n     小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：`llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef`，这是一个警告，但是因为编译的时候指定了`-W`，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报`llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info`。目前我的解决办法是去掉`-W`之后单独执行：`sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html`。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。\n\n     更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。\n\n   - `cmake --build . --target doxygen-llvm` 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。\n   \n   小提示：1. 想要查看有哪些target可以去查看生成的`build/CMakeFiles/TargetDirectories.txt`文件。像这里的`doxygen-llvm`我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。\n\n将前面的命令放在一起方便拷贝：\n\n```shell\ngit clone https://github.com/llvm/llvm-project\n// Gitee源：git clone https://gitee.com/mirrors/LLVM\ncd llvm-project && mkdir build && cd build\ncmake -G Ninja\\\n  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\\n  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\\n  -DLLVM_ENABLE_SPHINX=ON\\\n  -DLLVM_ENABLE_DOXYGEN=ON\\\n  ../llvm\ncmake --build . // 编译llvm、clang、libcxx\ncmake --build . --target docs-llvm-html // 编译LLVM文档\ncmake --build . --target doxygen-llvm // 编译LLVM API文档\n```\n\n官方文档参考：\n\n- [Getting Started with the LLVM System](https://llvm.org/docs/GettingStarted.html)：介绍了编译项目的基本步骤，常用参数\n- [Building LLVM with CMake](https://llvm.org/docs/CMake.html)：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数\n\n\n\n## 常用LLVM命令\n\n- clang\n  - `clang -S -emit-llvm input.c -o out.ll`：生成人可读的LLVM IR\n  - `clang -c -emit-llvm input.c -o out.bc`：生成二进制LLVM IR，也可以不加`-c`，默认编译为二进制IR\n- [opt](https://llvm.org/docs/CommandGuide/opt.html)\n  - `opt -load-pass-plugin=libHelloWorld.dylib -passes=\"hello-world\" a.ll`：使用HelloWorld Pass对`out.ll`进行处理。注意这是新的单独调用Pass的方式，老的方式为：`opt -load libHelloWorld.dylib -legacy-hello-world a.ll`\n  - `opt -analyze -view-cfg a.ll` 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。\n- [llvm-as](https://llvm.org/docs/CommandGuide/llvm-as.html)、[llvm-dis](https://llvm.org/docs/CommandGuide/llvm-dis.html)\n  - `llvm-as a.ll -o a.bc`：将人可读的LLVM IR编译为二进制LLVM IR\n  - `llvm-dis a.bc -o a.ll`：将二进制LLVM IR反编译为人可读的LLVM IR\n- [llc](https://llvm.org/docs/CommandGuide/llc.html)\n  - `llc a.ll -o a.out`：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件\n- [lli](https://llvm.org/docs/CommandGuide/lli.html)\n  - `lli a.ll`：直接解释执行LLVM IR\n- [llvm-link](https://llvm.org/docs/CommandGuide/llvm-link.html)\n  - `llvm-link -S add.ll main.ll -o all.ll`：链接多个LLVM IR为一个LLVM IR文件，`-S`表示输出的为人可读的LLVM IR，默认为二进制LLVM IR\n- [llvm-config](https://llvm.org/docs/CommandGuide/llvm-config.html)：使用`llvm-config --help`查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。\n  - `llvm-config --cxxflags`：生成编译时的头文件库参数，比如在我电脑上会输出`-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS`\n  - `llvm-config --ldflags`：生成链接时的LLVM库文件地址，比如在我电脑上会输出`-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names`\n  - `llvm-config --libs`：生成LLVM提供的库名称，结合`llvm-config --ldflags`，就可以让链接器找到对应的库文件。在`--libs`后面还可以添加各种组件名称，不添加表示所有组件。比如`--libs core native`，则只会输出core和native组件相关的库。通过下面的`llvm-config --components`命令可以列举出所有的LLVM组件列表\n  - `llvm-config --components`：输出所有的LLVM组件\n\n官方文档参考：\n\n- [LLVM Command Guide](https://llvm.org/docs/CommandGuide/index.html)：命令行工具使用说明\n\n\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->\n","source":"_posts/llvm-0.md","raw":"---\ntitle: 学习LLVM第0篇：LLVM项目介绍\ndate: 2020-06-25 21:55:21\ncategories:\n- llvm\ntags:\n- llvm\nexcerpt: 本文学习LLVM的第0篇文章，介绍LLVM项目的一些内容，包括如何构建命令行工具和本地文档、常用LLVM命令的使用。目的是为了后续研究LLVM作准备。\n---\n\n更全面的内容请直接参考[官方文档](https://llvm.org/docs)，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。\n\n\n\n## 编译项目\n\n1. 安装[CMake](https://cmake.org)、[Ninja](https://ninja-build.org)构建工具。\n   \n   这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。\n   \n   Mac系统建议使用[Brew](https://brew.sh)来安装，`brew install cmake ninja`，如果还需要编译文档，则需要安装doxygen、sphinx-doc，安装命令：`pip install sphinx=1.8.5`（使用brew安装时找不到这个版本的sphinx）、`brew install doxygen`。\n   \n2. 克隆LLVM仓库：`git clone https://github.com/llvm/llvm-project`\n\n   如果国内clone太慢，也可以使用Gitee提供的镜像仓库 https://gitee.com/mirrors/LLVM （注意：镜像仓库目前每天同步一次，所以内容会有延后）\n\n3. 创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：`mkdir build`，然后进到构建目录： `cd build`\n\n4. 生成构建系统：`cmake -G Ninja -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\" ../llvm`\n\n   常用参数：\n\n   - `LLVM_ENABLE_PROJECTS`：比如`\"clang;libcxx\"`。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如`clang`、`clang-tools-extra`、`libcxx`、`libc`等。\n\n     小提示：所有支持的项目可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_PROJECTS`变量的内容。当前的内容为：`clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl`\n\n   - `LLVM_TARGETS_TO_BUILD`：比如`\"X86;RISCV\"`。指定LLVM后端支持的目标架构，比如`X86`、`ARM`、`RISCV`、`WebAssembly`\n\n     小提示：所有支持的目标架构可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_TARGETS`变量的内容。当前的内容为：`AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore`\n\n   - `LLVM_ENABLE_SPHINX`：是否编译LLVM文档。`ON`表示启动。依赖[Sphinx](https://www.sphinx-doc.org)\n\n   - `LLVM_ENABLE_DOXYGEN`：是否编译LLVM API文档。`ON`表示启动。依赖[Doxygen](https://www.doxygen.nl)\n\n5. 进行构建：\n\n   - `cmake --build .` 表示编译默认目标包括LLVM和`LLVM_ENABLE_PROJECTS`指定的项目\n\n   - `cmake --build . --target docs-llvm-html` 表示只编译LLVM文档\n\n     小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：`llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef`，这是一个警告，但是因为编译的时候指定了`-W`，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报`llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info`。目前我的解决办法是去掉`-W`之后单独执行：`sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html`。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。\n\n     更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。\n\n   - `cmake --build . --target doxygen-llvm` 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。\n   \n   小提示：1. 想要查看有哪些target可以去查看生成的`build/CMakeFiles/TargetDirectories.txt`文件。像这里的`doxygen-llvm`我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。\n\n将前面的命令放在一起方便拷贝：\n\n```shell\ngit clone https://github.com/llvm/llvm-project\n// Gitee源：git clone https://gitee.com/mirrors/LLVM\ncd llvm-project && mkdir build && cd build\ncmake -G Ninja\\\n  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\\n  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\\n  -DLLVM_ENABLE_SPHINX=ON\\\n  -DLLVM_ENABLE_DOXYGEN=ON\\\n  ../llvm\ncmake --build . // 编译llvm、clang、libcxx\ncmake --build . --target docs-llvm-html // 编译LLVM文档\ncmake --build . --target doxygen-llvm // 编译LLVM API文档\n```\n\n官方文档参考：\n\n- [Getting Started with the LLVM System](https://llvm.org/docs/GettingStarted.html)：介绍了编译项目的基本步骤，常用参数\n- [Building LLVM with CMake](https://llvm.org/docs/CMake.html)：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数\n\n\n\n## 常用LLVM命令\n\n- clang\n  - `clang -S -emit-llvm input.c -o out.ll`：生成人可读的LLVM IR\n  - `clang -c -emit-llvm input.c -o out.bc`：生成二进制LLVM IR，也可以不加`-c`，默认编译为二进制IR\n- [opt](https://llvm.org/docs/CommandGuide/opt.html)\n  - `opt -load-pass-plugin=libHelloWorld.dylib -passes=\"hello-world\" a.ll`：使用HelloWorld Pass对`out.ll`进行处理。注意这是新的单独调用Pass的方式，老的方式为：`opt -load libHelloWorld.dylib -legacy-hello-world a.ll`\n  - `opt -analyze -view-cfg a.ll` 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。\n- [llvm-as](https://llvm.org/docs/CommandGuide/llvm-as.html)、[llvm-dis](https://llvm.org/docs/CommandGuide/llvm-dis.html)\n  - `llvm-as a.ll -o a.bc`：将人可读的LLVM IR编译为二进制LLVM IR\n  - `llvm-dis a.bc -o a.ll`：将二进制LLVM IR反编译为人可读的LLVM IR\n- [llc](https://llvm.org/docs/CommandGuide/llc.html)\n  - `llc a.ll -o a.out`：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件\n- [lli](https://llvm.org/docs/CommandGuide/lli.html)\n  - `lli a.ll`：直接解释执行LLVM IR\n- [llvm-link](https://llvm.org/docs/CommandGuide/llvm-link.html)\n  - `llvm-link -S add.ll main.ll -o all.ll`：链接多个LLVM IR为一个LLVM IR文件，`-S`表示输出的为人可读的LLVM IR，默认为二进制LLVM IR\n- [llvm-config](https://llvm.org/docs/CommandGuide/llvm-config.html)：使用`llvm-config --help`查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。\n  - `llvm-config --cxxflags`：生成编译时的头文件库参数，比如在我电脑上会输出`-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS`\n  - `llvm-config --ldflags`：生成链接时的LLVM库文件地址，比如在我电脑上会输出`-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names`\n  - `llvm-config --libs`：生成LLVM提供的库名称，结合`llvm-config --ldflags`，就可以让链接器找到对应的库文件。在`--libs`后面还可以添加各种组件名称，不添加表示所有组件。比如`--libs core native`，则只会输出core和native组件相关的库。通过下面的`llvm-config --components`命令可以列举出所有的LLVM组件列表\n  - `llvm-config --components`：输出所有的LLVM组件\n\n官方文档参考：\n\n- [LLVM Command Guide](https://llvm.org/docs/CommandGuide/index.html)：命令行工具使用说明\n\n\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->\n","slug":"llvm-0","published":1,"updated":"2020-11-11T02:48:27.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzn0000rnq750akh49k","content":"<p>更全面的内容请直接参考<a href=\"https://llvm.org/docs\">官方文档</a>，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。</p>\n<h2 id=\"编译项目\"><a href=\"#编译项目\" class=\"headerlink\" title=\"编译项目\"></a>编译项目</h2><ol>\n<li><p>安装<a href=\"https://cmake.org/\">CMake</a>、<a href=\"https://ninja-build.org/\">Ninja</a>构建工具。</p>\n<p>这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。</p>\n<p>Mac系统建议使用<a href=\"https://brew.sh/\">Brew</a>来安装，<code>brew install cmake ninja</code>，如果还需要编译文档，则需要安装doxygen、sphinx-doc，安装命令：<code>pip install sphinx=1.8.5</code>（使用brew安装时找不到这个版本的sphinx）、<code>brew install doxygen</code>。</p>\n</li>\n<li><p>克隆LLVM仓库：<code>git clone https://github.com/llvm/llvm-project</code></p>\n<p>如果国内clone太慢，也可以使用Gitee提供的镜像仓库 <a href=\"https://gitee.com/mirrors/LLVM\">https://gitee.com/mirrors/LLVM</a> （注意：镜像仓库目前每天同步一次，所以内容会有延后）</p>\n</li>\n<li><p>创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：<code>mkdir build</code>，然后进到构建目录： <code>cd build</code></p>\n</li>\n<li><p>生成构建系统：<code>cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot; ../llvm</code></p>\n<p>常用参数：</p>\n<ul>\n<li><p><code>LLVM_ENABLE_PROJECTS</code>：比如<code>&quot;clang;libcxx&quot;</code>。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如<code>clang</code>、<code>clang-tools-extra</code>、<code>libcxx</code>、<code>libc</code>等。</p>\n<p>小提示：所有支持的项目可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_PROJECTS</code>变量的内容。当前的内容为：<code>clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl</code></p>\n</li>\n<li><p><code>LLVM_TARGETS_TO_BUILD</code>：比如<code>&quot;X86;RISCV&quot;</code>。指定LLVM后端支持的目标架构，比如<code>X86</code>、<code>ARM</code>、<code>RISCV</code>、<code>WebAssembly</code></p>\n<p>小提示：所有支持的目标架构可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_TARGETS</code>变量的内容。当前的内容为：<code>AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore</code></p>\n</li>\n<li><p><code>LLVM_ENABLE_SPHINX</code>：是否编译LLVM文档。<code>ON</code>表示启动。依赖<a href=\"https://www.sphinx-doc.org/\">Sphinx</a></p>\n</li>\n<li><p><code>LLVM_ENABLE_DOXYGEN</code>：是否编译LLVM API文档。<code>ON</code>表示启动。依赖<a href=\"https://www.doxygen.nl/\">Doxygen</a></p>\n</li>\n</ul>\n</li>\n<li><p>进行构建：</p>\n<ul>\n<li><p><code>cmake --build .</code> 表示编译默认目标包括LLVM和<code>LLVM_ENABLE_PROJECTS</code>指定的项目</p>\n</li>\n<li><p><code>cmake --build . --target docs-llvm-html</code> 表示只编译LLVM文档</p>\n<p>小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：<code>llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef</code>，这是一个警告，但是因为编译的时候指定了<code>-W</code>，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报<code>llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info</code>。目前我的解决办法是去掉<code>-W</code>之后单独执行：<code>sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html</code>。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。</p>\n<p>更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。</p>\n</li>\n<li><p><code>cmake --build . --target doxygen-llvm</code> 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。</p>\n</li>\n</ul>\n<p>小提示：1. 想要查看有哪些target可以去查看生成的<code>build/CMakeFiles/TargetDirectories.txt</code>文件。像这里的<code>doxygen-llvm</code>我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。</p>\n</li>\n</ol>\n<p>将前面的命令放在一起方便拷贝：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/llvm/llvm-project</span><br><span class=\"line\">// Gitee源：git clone https://gitee.com/mirrors/LLVM</span><br><span class=\"line\">cd llvm-project &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class=\"line\">cmake -G Ninja\\</span><br><span class=\"line\">  -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot;\\</span><br><span class=\"line\">  -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot;\\</span><br><span class=\"line\">  -DLLVM_ENABLE_SPHINX=ON\\</span><br><span class=\"line\">  -DLLVM_ENABLE_DOXYGEN=ON\\</span><br><span class=\"line\">  ../llvm</span><br><span class=\"line\">cmake --build . // 编译llvm、clang、libcxx</span><br><span class=\"line\">cmake --build . --target docs-llvm-html // 编译LLVM文档</span><br><span class=\"line\">cmake --build . --target doxygen-llvm // 编译LLVM API文档</span><br></pre></td></tr></table></figure>\n\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/GettingStarted.html\">Getting Started with the LLVM System</a>：介绍了编译项目的基本步骤，常用参数</li>\n<li><a href=\"https://llvm.org/docs/CMake.html\">Building LLVM with CMake</a>：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数</li>\n</ul>\n<h2 id=\"常用LLVM命令\"><a href=\"#常用LLVM命令\" class=\"headerlink\" title=\"常用LLVM命令\"></a>常用LLVM命令</h2><ul>\n<li>clang<ul>\n<li><code>clang -S -emit-llvm input.c -o out.ll</code>：生成人可读的LLVM IR</li>\n<li><code>clang -c -emit-llvm input.c -o out.bc</code>：生成二进制LLVM IR，也可以不加<code>-c</code>，默认编译为二进制IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/opt.html\">opt</a><ul>\n<li><code>opt -load-pass-plugin=libHelloWorld.dylib -passes=&quot;hello-world&quot; a.ll</code>：使用HelloWorld Pass对<code>out.ll</code>进行处理。注意这是新的单独调用Pass的方式，老的方式为：<code>opt -load libHelloWorld.dylib -legacy-hello-world a.ll</code></li>\n<li><code>opt -analyze -view-cfg a.ll</code> 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-as.html\">llvm-as</a>、<a href=\"https://llvm.org/docs/CommandGuide/llvm-dis.html\">llvm-dis</a><ul>\n<li><code>llvm-as a.ll -o a.bc</code>：将人可读的LLVM IR编译为二进制LLVM IR</li>\n<li><code>llvm-dis a.bc -o a.ll</code>：将二进制LLVM IR反编译为人可读的LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llc.html\">llc</a><ul>\n<li><code>llc a.ll -o a.out</code>：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/lli.html\">lli</a><ul>\n<li><code>lli a.ll</code>：直接解释执行LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-link.html\">llvm-link</a><ul>\n<li><code>llvm-link -S add.ll main.ll -o all.ll</code>：链接多个LLVM IR为一个LLVM IR文件，<code>-S</code>表示输出的为人可读的LLVM IR，默认为二进制LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-config.html\">llvm-config</a>：使用<code>llvm-config --help</code>查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。<ul>\n<li><code>llvm-config --cxxflags</code>：生成编译时的头文件库参数，比如在我电脑上会输出<code>-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS</code></li>\n<li><code>llvm-config --ldflags</code>：生成链接时的LLVM库文件地址，比如在我电脑上会输出<code>-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names</code></li>\n<li><code>llvm-config --libs</code>：生成LLVM提供的库名称，结合<code>llvm-config --ldflags</code>，就可以让链接器找到对应的库文件。在<code>--libs</code>后面还可以添加各种组件名称，不添加表示所有组件。比如<code>--libs core native</code>，则只会输出core和native组件相关的库。通过下面的<code>llvm-config --components</code>命令可以列举出所有的LLVM组件列表</li>\n<li><code>llvm-config --components</code>：输出所有的LLVM组件</li>\n</ul>\n</li>\n</ul>\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/CommandGuide/index.html\">LLVM Command Guide</a>：命令行工具使用说明</li>\n</ul>\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->\n","site":{"data":{}},"more":"<p>更全面的内容请直接参考<a href=\"https://llvm.org/docs\">官方文档</a>，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。</p>\n<h2 id=\"编译项目\"><a href=\"#编译项目\" class=\"headerlink\" title=\"编译项目\"></a>编译项目</h2><ol>\n<li><p>安装<a href=\"https://cmake.org/\">CMake</a>、<a href=\"https://ninja-build.org/\">Ninja</a>构建工具。</p>\n<p>这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。</p>\n<p>Mac系统建议使用<a href=\"https://brew.sh/\">Brew</a>来安装，<code>brew install cmake ninja</code>，如果还需要编译文档，则需要安装doxygen、sphinx-doc，安装命令：<code>pip install sphinx=1.8.5</code>（使用brew安装时找不到这个版本的sphinx）、<code>brew install doxygen</code>。</p>\n</li>\n<li><p>克隆LLVM仓库：<code>git clone https://github.com/llvm/llvm-project</code></p>\n<p>如果国内clone太慢，也可以使用Gitee提供的镜像仓库 <a href=\"https://gitee.com/mirrors/LLVM\">https://gitee.com/mirrors/LLVM</a> （注意：镜像仓库目前每天同步一次，所以内容会有延后）</p>\n</li>\n<li><p>创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：<code>mkdir build</code>，然后进到构建目录： <code>cd build</code></p>\n</li>\n<li><p>生成构建系统：<code>cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot; ../llvm</code></p>\n<p>常用参数：</p>\n<ul>\n<li><p><code>LLVM_ENABLE_PROJECTS</code>：比如<code>&quot;clang;libcxx&quot;</code>。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如<code>clang</code>、<code>clang-tools-extra</code>、<code>libcxx</code>、<code>libc</code>等。</p>\n<p>小提示：所有支持的项目可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_PROJECTS</code>变量的内容。当前的内容为：<code>clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl</code></p>\n</li>\n<li><p><code>LLVM_TARGETS_TO_BUILD</code>：比如<code>&quot;X86;RISCV&quot;</code>。指定LLVM后端支持的目标架构，比如<code>X86</code>、<code>ARM</code>、<code>RISCV</code>、<code>WebAssembly</code></p>\n<p>小提示：所有支持的目标架构可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_TARGETS</code>变量的内容。当前的内容为：<code>AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore</code></p>\n</li>\n<li><p><code>LLVM_ENABLE_SPHINX</code>：是否编译LLVM文档。<code>ON</code>表示启动。依赖<a href=\"https://www.sphinx-doc.org/\">Sphinx</a></p>\n</li>\n<li><p><code>LLVM_ENABLE_DOXYGEN</code>：是否编译LLVM API文档。<code>ON</code>表示启动。依赖<a href=\"https://www.doxygen.nl/\">Doxygen</a></p>\n</li>\n</ul>\n</li>\n<li><p>进行构建：</p>\n<ul>\n<li><p><code>cmake --build .</code> 表示编译默认目标包括LLVM和<code>LLVM_ENABLE_PROJECTS</code>指定的项目</p>\n</li>\n<li><p><code>cmake --build . --target docs-llvm-html</code> 表示只编译LLVM文档</p>\n<p>小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：<code>llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef</code>，这是一个警告，但是因为编译的时候指定了<code>-W</code>，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报<code>llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info</code>。目前我的解决办法是去掉<code>-W</code>之后单独执行：<code>sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html</code>。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。</p>\n<p>更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。</p>\n</li>\n<li><p><code>cmake --build . --target doxygen-llvm</code> 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。</p>\n</li>\n</ul>\n<p>小提示：1. 想要查看有哪些target可以去查看生成的<code>build/CMakeFiles/TargetDirectories.txt</code>文件。像这里的<code>doxygen-llvm</code>我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。</p>\n</li>\n</ol>\n<p>将前面的命令放在一起方便拷贝：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/llvm/llvm-project</span><br><span class=\"line\">// Gitee源：git clone https://gitee.com/mirrors/LLVM</span><br><span class=\"line\">cd llvm-project &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class=\"line\">cmake -G Ninja\\</span><br><span class=\"line\">  -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot;\\</span><br><span class=\"line\">  -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot;\\</span><br><span class=\"line\">  -DLLVM_ENABLE_SPHINX=ON\\</span><br><span class=\"line\">  -DLLVM_ENABLE_DOXYGEN=ON\\</span><br><span class=\"line\">  ../llvm</span><br><span class=\"line\">cmake --build . // 编译llvm、clang、libcxx</span><br><span class=\"line\">cmake --build . --target docs-llvm-html // 编译LLVM文档</span><br><span class=\"line\">cmake --build . --target doxygen-llvm // 编译LLVM API文档</span><br></pre></td></tr></table></figure>\n\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/GettingStarted.html\">Getting Started with the LLVM System</a>：介绍了编译项目的基本步骤，常用参数</li>\n<li><a href=\"https://llvm.org/docs/CMake.html\">Building LLVM with CMake</a>：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数</li>\n</ul>\n<h2 id=\"常用LLVM命令\"><a href=\"#常用LLVM命令\" class=\"headerlink\" title=\"常用LLVM命令\"></a>常用LLVM命令</h2><ul>\n<li>clang<ul>\n<li><code>clang -S -emit-llvm input.c -o out.ll</code>：生成人可读的LLVM IR</li>\n<li><code>clang -c -emit-llvm input.c -o out.bc</code>：生成二进制LLVM IR，也可以不加<code>-c</code>，默认编译为二进制IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/opt.html\">opt</a><ul>\n<li><code>opt -load-pass-plugin=libHelloWorld.dylib -passes=&quot;hello-world&quot; a.ll</code>：使用HelloWorld Pass对<code>out.ll</code>进行处理。注意这是新的单独调用Pass的方式，老的方式为：<code>opt -load libHelloWorld.dylib -legacy-hello-world a.ll</code></li>\n<li><code>opt -analyze -view-cfg a.ll</code> 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-as.html\">llvm-as</a>、<a href=\"https://llvm.org/docs/CommandGuide/llvm-dis.html\">llvm-dis</a><ul>\n<li><code>llvm-as a.ll -o a.bc</code>：将人可读的LLVM IR编译为二进制LLVM IR</li>\n<li><code>llvm-dis a.bc -o a.ll</code>：将二进制LLVM IR反编译为人可读的LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llc.html\">llc</a><ul>\n<li><code>llc a.ll -o a.out</code>：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/lli.html\">lli</a><ul>\n<li><code>lli a.ll</code>：直接解释执行LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-link.html\">llvm-link</a><ul>\n<li><code>llvm-link -S add.ll main.ll -o all.ll</code>：链接多个LLVM IR为一个LLVM IR文件，<code>-S</code>表示输出的为人可读的LLVM IR，默认为二进制LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-config.html\">llvm-config</a>：使用<code>llvm-config --help</code>查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。<ul>\n<li><code>llvm-config --cxxflags</code>：生成编译时的头文件库参数，比如在我电脑上会输出<code>-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS</code></li>\n<li><code>llvm-config --ldflags</code>：生成链接时的LLVM库文件地址，比如在我电脑上会输出<code>-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names</code></li>\n<li><code>llvm-config --libs</code>：生成LLVM提供的库名称，结合<code>llvm-config --ldflags</code>，就可以让链接器找到对应的库文件。在<code>--libs</code>后面还可以添加各种组件名称，不添加表示所有组件。比如<code>--libs core native</code>，则只会输出core和native组件相关的库。通过下面的<code>llvm-config --components</code>命令可以列举出所有的LLVM组件列表</li>\n<li><code>llvm-config --components</code>：输出所有的LLVM组件</li>\n</ul>\n</li>\n</ul>\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/CommandGuide/index.html\">LLVM Command Guide</a>：命令行工具使用说明</li>\n</ul>\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->\n"},{"title":"Java 笔记","date":"2017-03-14T16:00:00.000Z","excerpt":"本文为我学习Java的笔记","_content":"\n阅读材料：\n\n- [The Java Tutorials](http://docs.oracle.com/javase/tutorial/)\n\n## Getting Started\n\n### About the Java Technology\n\nJava technology is both a programming language and a platform.\n\n#### The Java Programming Language\n\nJava 语言的特点: Simple, Architecture neutral, Object oriented, Portable, Distributed, High performance, Multithreaded, Robust, Dynamic, Secure. Each of the buzzwords explained in [The Java Language Environment](http://www.oracle.com/technetwork/java/langenv-140151.html)\n\n`file.java` -- 由 javac 编译 -> `file.class`(bytecode) -- 由 Java VM 运行 -> 得到运行结果\n\n[Java SE HotSpot at a Glance](Java SE HotSpot at a Glance)\n\n#### The Java Platform\n\nA *platform* is the hardware or software environment in which a program runs.\n\nJava 平台是一个软件平台。\n\nThe Java platform has two components:\n\n- The Java Virtual Machine\n- The Java Application Programming Interface (API)\n\n作为平台独立的运行环境，Java 平台比原生平台运行的更慢些。\n\n### What can Java Technology Do?\n\n### How Will Java Technology Change My Life?\n\n## Learning the Java Language\n\n### Object-Oriented Programming Concepts\n\n#### What Is an Object?\n\n对象由**状态(fields)**和相应的**行为(methods)**组成。是对真实世界中的物体的模拟。\n\n面向对象编程的基础概念是**数据封装(data encapsulation)**，也就是说对象把自己的内部变量隐藏，只通过自己的方法和外界进行交互。\n\n对象化所带来的好处：模块化、信息隐藏、代码复用、可插拔性和易于调试。\n\n#### What Is a Class?\n\n类是对象创建时所参考的蓝图，对象也可以叫做类的实例。\n\n#### What Is Inheritance?\n\n**继承**用于抽象不同类之间的相似之处，使类之间层次清楚，代码易读。\n\n#### What Is an Interface?\n\n对象通过**接口**与外界（其他对象）进行交互。\n\n#### What Is a Package?\n\n**包**是用于组织一系列相关**类**和**接口**的命名空间。\n\n## Language Basics\n\n### Variables\n\nJava 中存在以下几种变量：\n\n- **实例变量 (Instance Variables, Non-Static Fields)**\n- **类变量 (Class Variables, Static Fields)**：使用 `static` 修饰符(modifiers)修饰的 fields\n- **局部变量 (Local Variables)**\n- **参数 (Parameters)**\n\n### Primitive Data Types\n\n> The Java programming language is statically-typed, which means that all variables must first be declared before they can be used. This involves stating the variable's type and name.\n\n八种原始数据类型：`byte`(8-bit), `short`(16-bit), `int`(32-bit), `long`(64-bit), `float`(32-bit IEEE 754), `double`(64-bit IEEE 754), `boolean`, `char`(16-bit Unicode character).\n\n```\nint decVal = 26; // 十进制\nint hexVal = 0x1a; // 十六进制\nint binVal = 0b11010; // 二进制\n```\n\n### Array\n\n```\nint[] a = new int[10];\n\nint[] b = {1, 2, 3, 4};\n\nint[][] xy = {\n    {1, 2},\n    {2, 4},\n    {3, 9}\n}\n```\n\n### Operators\n\n### Expressions, Statements, and Blocks\n\n**语句**包括**表达式语句**、**声明语句**、**流程控制语句**。\n\n### Constrol Flow Statement\n\n常见流程控制语句：`if-then`, `switch`, `while`, `do-while`, `for`.\n\n## Classes and Objects\n\n### Classes\n\n#### Declaring Member Variables\n\n字段**访问修饰符**(Access Modifiers)：\n\n- `public`：所有类都可以访问\n- `private`：只能字段所属类访问\n\n#### Defining Methods\n\n方法**重载**(overloading)\n\n> Note: Overloaded methods should be used sparingly, as they can make code much less readable.\n\n#### Providing Constructors for Your Classes\n\n如果没有给类提供**构造器**，Java 编译器会自动补加一个默认的构造器，该构造器会调用父类的无参构造器。因此，如果父类提供无参构造器，编译器将会报错。\n\n形参(parameter)，实参(argument)。\n\n#### Controlling Access to Members of a Class\n\n**成员**(members)指类中的字段和方法，包括类成员和实例成员。\n\n修饰符对成员的访问控制权限表：\n\nModifier      | Class | Package | Subclass | World\n------------- | ----- | ------- | -------- | -----\n`public`      | Y     | Y       | Y        | Y\n`protected`   | Y     | Y       | Y        | N\n*no modifier* | Y     | Y       | N        | N\n`private`     | Y     | N       | N        | N\n\n**修饰符**(modifier)使用时请遵循最严原则，也就是说优先使用 `private`，有理由使用其它修饰符除外。除了常量外，避免使用 `public` 修饰符。使用 `public` 修饰符会导致暴露过多的细节给类使用者，限制了类的具体实现，影响了之后修改代码的灵活性。\n\n#### Understanding Class Members\n\n类变量可以直接通过类访问到，而不需要先初始化。类方法也是如此，并且类方法的调用只建议从类上调用，而不要在实例上调用，方便和实例方法做区分。\n\n类方法只能访问类变量和类方法，而实例方法可以访问实例变量、实例方法、类变量、类方法。\n\n通过 `static` 和 `final` 修饰符定义常量。常量在编译成字节码之后，就固定不变了。也就是说，假如修改了某个类中的常量，其他使用这个常量的类也需要重现编译。\n\n### Nested Classes\n\n为什么要使用嵌套类：\n\n- 对类进行逻辑上的分类：只在某个类中使用的类就声明在这个类里面\n- 增加封装性：嵌套类可以访问包裹类中的所有成员\n- 使代码易读和维护：代码上挨的更近\n\n注：我觉得这几点还有待商榷。\n\n嵌套类分为 Static Nested Classes 和 Inner Classes。\n\n> Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.\n\n方法中定义类(Local and Anonymous Classes)\n\n### Lambda Expressions\n\n> The operations filter, map, and forEach are *aggregate operations*.\n\n注意，Lambda 表达式不会引入新的作用域，也就意味着在表达式中不能重复定义外面出现过的变量。\n\n### When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions\n\n### Enum Types\n\n```\npublic enum Planet {\n    MERCURY (3.303e+23, 2.4397e6),\n    VENUS   (4.869e+24, 6.0518e6),\n    EARTH   (5.976e+24, 6.37814e6),\n    MARS    (6.421e+23, 3.3972e6),\n    JUPITER (1.9e+27,   7.1492e7),\n    SATURN  (5.688e+26, 6.0268e7),\n    URANUS  (8.686e+25, 2.5559e7),\n    NEPTUNE (1.024e+26, 2.4746e7);\n\n    private final double mass;   // in kilograms\n    private final double radius; // in meters\n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n    private double mass() { return mass; }\n    private double radius() { return radius; }\n\n    // universal gravitational constant  (m3 kg-1 s-2)\n    public static final double G = 6.67300E-11;\n\n    double surfaceGravity() {\n        return G * mass / (radius * radius);\n    }\n    double surfaceWeight(double otherMass) {\n        return otherMass * surfaceGravity();\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java Planet <earth_weight>\");\n            System.exit(-1);\n        }\n        double earthWeight = Double.parseDouble(args[0]);\n        double mass = earthWeight/EARTH.surfaceGravity();\n        for (Planet p : Planet.values())\n           System.out.printf(\"Your weight on %s is %f%n\",\n                             p, p.surfaceWeight(mass));\n    }\n}\n```\n\n## Annotations\n\n**注解**(*annotation*)，给程序提供元数据，但不是程序的一部分。\n\n作用：\n\n- 给编译器提供信息\n- 编译和部署时处理，生成代码，XML文件等\n- 运行时处理\n\n一些注解用于替代代码中的**注释**(*comment*)。\n\n一些注解用于其他注解上面，称为**元注解**(*meta-annotation*)。\n\n## Interfaces\n\n**接口**(*interface*)是**引用类型**(*reference type*)，可以包含**抽象方法**(*abstract method*)、**默认方法**(*default method*)、**静态方法**(*static method*)、**常量**(*constant*)。\n\n当需要扩充接口，但又不希望之前实现该接口的类进行修改时，可以通过定义默认方法或者静态方法来达到目的。\n\n## Inheritance\n\n子类**继承**(*inheritance**)父类中被 `public` 和 `protected` 修饰的成员(members)。如果子类和父类属于同一个 package，那么子类还继承了父类中的 *package-private* 成员。\n\n作为所有类的祖先 Object 类（它自己没有父类了），它含有的以下方法会被继承：\n\n- `protected Object clone() throws CloneNotSupportedException`\n- `public boolean equals(Object obj)`\n- `protected void finalize() throws Throwable`\n- `public final Class getClass()`\n- `public int hashCode()`\n- `public String toString()`\n\n### Polymorphism\n\n**多态**(*polymorphism*)\n\n> The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable's type. This behavior is referred to as *virtual method invocation* and demonstrates an aspect of the important polymorphism features in the Java language.\n\n## Packages\n\n> Definition: A *package* is a grouping of related types providing access protection and name space management. Note that *types* refers to classes, interfaces, enumerations, and annotation types.\n\n> For convenience, the Java compiler automatically imports two entire packages for each source file: (1) the java.lang package and (2) the current package (the package for the current file).\n\n> Both the compiler and the JVM construct the path to your .class files by adding the package name to the *class path*.\n\n## 泛型(Generics)\n\n> In a nutshell, generics enable *types* (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar *formal parameters* used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\n> Code that uses generics has many benefits over non-generic code:\n>\n> - Stronger type checks at compile time.\n> - Elimination of casts.\n> - Enabling programmers to implement generic algorithms.\n\n动态指定类型，可以在类中，也可以在方法中。\n\n\n\n\n","source":"_posts/java.md","raw":"---\ntitle: Java 笔记\ndate: 2017/03/15\ntag:\n- java\ncategory:\n- note\nexcerpt: 本文为我学习Java的笔记\n---\n\n阅读材料：\n\n- [The Java Tutorials](http://docs.oracle.com/javase/tutorial/)\n\n## Getting Started\n\n### About the Java Technology\n\nJava technology is both a programming language and a platform.\n\n#### The Java Programming Language\n\nJava 语言的特点: Simple, Architecture neutral, Object oriented, Portable, Distributed, High performance, Multithreaded, Robust, Dynamic, Secure. Each of the buzzwords explained in [The Java Language Environment](http://www.oracle.com/technetwork/java/langenv-140151.html)\n\n`file.java` -- 由 javac 编译 -> `file.class`(bytecode) -- 由 Java VM 运行 -> 得到运行结果\n\n[Java SE HotSpot at a Glance](Java SE HotSpot at a Glance)\n\n#### The Java Platform\n\nA *platform* is the hardware or software environment in which a program runs.\n\nJava 平台是一个软件平台。\n\nThe Java platform has two components:\n\n- The Java Virtual Machine\n- The Java Application Programming Interface (API)\n\n作为平台独立的运行环境，Java 平台比原生平台运行的更慢些。\n\n### What can Java Technology Do?\n\n### How Will Java Technology Change My Life?\n\n## Learning the Java Language\n\n### Object-Oriented Programming Concepts\n\n#### What Is an Object?\n\n对象由**状态(fields)**和相应的**行为(methods)**组成。是对真实世界中的物体的模拟。\n\n面向对象编程的基础概念是**数据封装(data encapsulation)**，也就是说对象把自己的内部变量隐藏，只通过自己的方法和外界进行交互。\n\n对象化所带来的好处：模块化、信息隐藏、代码复用、可插拔性和易于调试。\n\n#### What Is a Class?\n\n类是对象创建时所参考的蓝图，对象也可以叫做类的实例。\n\n#### What Is Inheritance?\n\n**继承**用于抽象不同类之间的相似之处，使类之间层次清楚，代码易读。\n\n#### What Is an Interface?\n\n对象通过**接口**与外界（其他对象）进行交互。\n\n#### What Is a Package?\n\n**包**是用于组织一系列相关**类**和**接口**的命名空间。\n\n## Language Basics\n\n### Variables\n\nJava 中存在以下几种变量：\n\n- **实例变量 (Instance Variables, Non-Static Fields)**\n- **类变量 (Class Variables, Static Fields)**：使用 `static` 修饰符(modifiers)修饰的 fields\n- **局部变量 (Local Variables)**\n- **参数 (Parameters)**\n\n### Primitive Data Types\n\n> The Java programming language is statically-typed, which means that all variables must first be declared before they can be used. This involves stating the variable's type and name.\n\n八种原始数据类型：`byte`(8-bit), `short`(16-bit), `int`(32-bit), `long`(64-bit), `float`(32-bit IEEE 754), `double`(64-bit IEEE 754), `boolean`, `char`(16-bit Unicode character).\n\n```\nint decVal = 26; // 十进制\nint hexVal = 0x1a; // 十六进制\nint binVal = 0b11010; // 二进制\n```\n\n### Array\n\n```\nint[] a = new int[10];\n\nint[] b = {1, 2, 3, 4};\n\nint[][] xy = {\n    {1, 2},\n    {2, 4},\n    {3, 9}\n}\n```\n\n### Operators\n\n### Expressions, Statements, and Blocks\n\n**语句**包括**表达式语句**、**声明语句**、**流程控制语句**。\n\n### Constrol Flow Statement\n\n常见流程控制语句：`if-then`, `switch`, `while`, `do-while`, `for`.\n\n## Classes and Objects\n\n### Classes\n\n#### Declaring Member Variables\n\n字段**访问修饰符**(Access Modifiers)：\n\n- `public`：所有类都可以访问\n- `private`：只能字段所属类访问\n\n#### Defining Methods\n\n方法**重载**(overloading)\n\n> Note: Overloaded methods should be used sparingly, as they can make code much less readable.\n\n#### Providing Constructors for Your Classes\n\n如果没有给类提供**构造器**，Java 编译器会自动补加一个默认的构造器，该构造器会调用父类的无参构造器。因此，如果父类提供无参构造器，编译器将会报错。\n\n形参(parameter)，实参(argument)。\n\n#### Controlling Access to Members of a Class\n\n**成员**(members)指类中的字段和方法，包括类成员和实例成员。\n\n修饰符对成员的访问控制权限表：\n\nModifier      | Class | Package | Subclass | World\n------------- | ----- | ------- | -------- | -----\n`public`      | Y     | Y       | Y        | Y\n`protected`   | Y     | Y       | Y        | N\n*no modifier* | Y     | Y       | N        | N\n`private`     | Y     | N       | N        | N\n\n**修饰符**(modifier)使用时请遵循最严原则，也就是说优先使用 `private`，有理由使用其它修饰符除外。除了常量外，避免使用 `public` 修饰符。使用 `public` 修饰符会导致暴露过多的细节给类使用者，限制了类的具体实现，影响了之后修改代码的灵活性。\n\n#### Understanding Class Members\n\n类变量可以直接通过类访问到，而不需要先初始化。类方法也是如此，并且类方法的调用只建议从类上调用，而不要在实例上调用，方便和实例方法做区分。\n\n类方法只能访问类变量和类方法，而实例方法可以访问实例变量、实例方法、类变量、类方法。\n\n通过 `static` 和 `final` 修饰符定义常量。常量在编译成字节码之后，就固定不变了。也就是说，假如修改了某个类中的常量，其他使用这个常量的类也需要重现编译。\n\n### Nested Classes\n\n为什么要使用嵌套类：\n\n- 对类进行逻辑上的分类：只在某个类中使用的类就声明在这个类里面\n- 增加封装性：嵌套类可以访问包裹类中的所有成员\n- 使代码易读和维护：代码上挨的更近\n\n注：我觉得这几点还有待商榷。\n\n嵌套类分为 Static Nested Classes 和 Inner Classes。\n\n> Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.\n\n方法中定义类(Local and Anonymous Classes)\n\n### Lambda Expressions\n\n> The operations filter, map, and forEach are *aggregate operations*.\n\n注意，Lambda 表达式不会引入新的作用域，也就意味着在表达式中不能重复定义外面出现过的变量。\n\n### When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions\n\n### Enum Types\n\n```\npublic enum Planet {\n    MERCURY (3.303e+23, 2.4397e6),\n    VENUS   (4.869e+24, 6.0518e6),\n    EARTH   (5.976e+24, 6.37814e6),\n    MARS    (6.421e+23, 3.3972e6),\n    JUPITER (1.9e+27,   7.1492e7),\n    SATURN  (5.688e+26, 6.0268e7),\n    URANUS  (8.686e+25, 2.5559e7),\n    NEPTUNE (1.024e+26, 2.4746e7);\n\n    private final double mass;   // in kilograms\n    private final double radius; // in meters\n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n    private double mass() { return mass; }\n    private double radius() { return radius; }\n\n    // universal gravitational constant  (m3 kg-1 s-2)\n    public static final double G = 6.67300E-11;\n\n    double surfaceGravity() {\n        return G * mass / (radius * radius);\n    }\n    double surfaceWeight(double otherMass) {\n        return otherMass * surfaceGravity();\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java Planet <earth_weight>\");\n            System.exit(-1);\n        }\n        double earthWeight = Double.parseDouble(args[0]);\n        double mass = earthWeight/EARTH.surfaceGravity();\n        for (Planet p : Planet.values())\n           System.out.printf(\"Your weight on %s is %f%n\",\n                             p, p.surfaceWeight(mass));\n    }\n}\n```\n\n## Annotations\n\n**注解**(*annotation*)，给程序提供元数据，但不是程序的一部分。\n\n作用：\n\n- 给编译器提供信息\n- 编译和部署时处理，生成代码，XML文件等\n- 运行时处理\n\n一些注解用于替代代码中的**注释**(*comment*)。\n\n一些注解用于其他注解上面，称为**元注解**(*meta-annotation*)。\n\n## Interfaces\n\n**接口**(*interface*)是**引用类型**(*reference type*)，可以包含**抽象方法**(*abstract method*)、**默认方法**(*default method*)、**静态方法**(*static method*)、**常量**(*constant*)。\n\n当需要扩充接口，但又不希望之前实现该接口的类进行修改时，可以通过定义默认方法或者静态方法来达到目的。\n\n## Inheritance\n\n子类**继承**(*inheritance**)父类中被 `public` 和 `protected` 修饰的成员(members)。如果子类和父类属于同一个 package，那么子类还继承了父类中的 *package-private* 成员。\n\n作为所有类的祖先 Object 类（它自己没有父类了），它含有的以下方法会被继承：\n\n- `protected Object clone() throws CloneNotSupportedException`\n- `public boolean equals(Object obj)`\n- `protected void finalize() throws Throwable`\n- `public final Class getClass()`\n- `public int hashCode()`\n- `public String toString()`\n\n### Polymorphism\n\n**多态**(*polymorphism*)\n\n> The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable's type. This behavior is referred to as *virtual method invocation* and demonstrates an aspect of the important polymorphism features in the Java language.\n\n## Packages\n\n> Definition: A *package* is a grouping of related types providing access protection and name space management. Note that *types* refers to classes, interfaces, enumerations, and annotation types.\n\n> For convenience, the Java compiler automatically imports two entire packages for each source file: (1) the java.lang package and (2) the current package (the package for the current file).\n\n> Both the compiler and the JVM construct the path to your .class files by adding the package name to the *class path*.\n\n## 泛型(Generics)\n\n> In a nutshell, generics enable *types* (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar *formal parameters* used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\n> Code that uses generics has many benefits over non-generic code:\n>\n> - Stronger type checks at compile time.\n> - Elimination of casts.\n> - Enabling programmers to implement generic algorithms.\n\n动态指定类型，可以在类中，也可以在方法中。\n\n\n\n\n","slug":"java","published":1,"updated":"2020-11-28T14:23:02.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzq0001rnq72p3te9xv","content":"<p>阅读材料：</p>\n<ul>\n<li><a href=\"http://docs.oracle.com/javase/tutorial/\">The Java Tutorials</a></li>\n</ul>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><h3 id=\"About-the-Java-Technology\"><a href=\"#About-the-Java-Technology\" class=\"headerlink\" title=\"About the Java Technology\"></a>About the Java Technology</h3><p>Java technology is both a programming language and a platform.</p>\n<h4 id=\"The-Java-Programming-Language\"><a href=\"#The-Java-Programming-Language\" class=\"headerlink\" title=\"The Java Programming Language\"></a>The Java Programming Language</h4><p>Java 语言的特点: Simple, Architecture neutral, Object oriented, Portable, Distributed, High performance, Multithreaded, Robust, Dynamic, Secure. Each of the buzzwords explained in <a href=\"http://www.oracle.com/technetwork/java/langenv-140151.html\">The Java Language Environment</a></p>\n<p><code>file.java</code> – 由 javac 编译 -&gt; <code>file.class</code>(bytecode) – 由 Java VM 运行 -&gt; 得到运行结果</p>\n<p>[Java SE HotSpot at a Glance](Java SE HotSpot at a Glance)</p>\n<h4 id=\"The-Java-Platform\"><a href=\"#The-Java-Platform\" class=\"headerlink\" title=\"The Java Platform\"></a>The Java Platform</h4><p>A <em>platform</em> is the hardware or software environment in which a program runs.</p>\n<p>Java 平台是一个软件平台。</p>\n<p>The Java platform has two components:</p>\n<ul>\n<li>The Java Virtual Machine</li>\n<li>The Java Application Programming Interface (API)</li>\n</ul>\n<p>作为平台独立的运行环境，Java 平台比原生平台运行的更慢些。</p>\n<h3 id=\"What-can-Java-Technology-Do\"><a href=\"#What-can-Java-Technology-Do\" class=\"headerlink\" title=\"What can Java Technology Do?\"></a>What can Java Technology Do?</h3><h3 id=\"How-Will-Java-Technology-Change-My-Life\"><a href=\"#How-Will-Java-Technology-Change-My-Life\" class=\"headerlink\" title=\"How Will Java Technology Change My Life?\"></a>How Will Java Technology Change My Life?</h3><h2 id=\"Learning-the-Java-Language\"><a href=\"#Learning-the-Java-Language\" class=\"headerlink\" title=\"Learning the Java Language\"></a>Learning the Java Language</h2><h3 id=\"Object-Oriented-Programming-Concepts\"><a href=\"#Object-Oriented-Programming-Concepts\" class=\"headerlink\" title=\"Object-Oriented Programming Concepts\"></a>Object-Oriented Programming Concepts</h3><h4 id=\"What-Is-an-Object\"><a href=\"#What-Is-an-Object\" class=\"headerlink\" title=\"What Is an Object?\"></a>What Is an Object?</h4><p>对象由<strong>状态(fields)**和相应的</strong>行为(methods)**组成。是对真实世界中的物体的模拟。</p>\n<p>面向对象编程的基础概念是**数据封装(data encapsulation)**，也就是说对象把自己的内部变量隐藏，只通过自己的方法和外界进行交互。</p>\n<p>对象化所带来的好处：模块化、信息隐藏、代码复用、可插拔性和易于调试。</p>\n<h4 id=\"What-Is-a-Class\"><a href=\"#What-Is-a-Class\" class=\"headerlink\" title=\"What Is a Class?\"></a>What Is a Class?</h4><p>类是对象创建时所参考的蓝图，对象也可以叫做类的实例。</p>\n<h4 id=\"What-Is-Inheritance\"><a href=\"#What-Is-Inheritance\" class=\"headerlink\" title=\"What Is Inheritance?\"></a>What Is Inheritance?</h4><p><strong>继承</strong>用于抽象不同类之间的相似之处，使类之间层次清楚，代码易读。</p>\n<h4 id=\"What-Is-an-Interface\"><a href=\"#What-Is-an-Interface\" class=\"headerlink\" title=\"What Is an Interface?\"></a>What Is an Interface?</h4><p>对象通过<strong>接口</strong>与外界（其他对象）进行交互。</p>\n<h4 id=\"What-Is-a-Package\"><a href=\"#What-Is-a-Package\" class=\"headerlink\" title=\"What Is a Package?\"></a>What Is a Package?</h4><p><strong>包</strong>是用于组织一系列相关<strong>类</strong>和<strong>接口</strong>的命名空间。</p>\n<h2 id=\"Language-Basics\"><a href=\"#Language-Basics\" class=\"headerlink\" title=\"Language Basics\"></a>Language Basics</h2><h3 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h3><p>Java 中存在以下几种变量：</p>\n<ul>\n<li><strong>实例变量 (Instance Variables, Non-Static Fields)</strong></li>\n<li>**类变量 (Class Variables, Static Fields)**：使用 <code>static</code> 修饰符(modifiers)修饰的 fields</li>\n<li><strong>局部变量 (Local Variables)</strong></li>\n<li><strong>参数 (Parameters)</strong></li>\n</ul>\n<h3 id=\"Primitive-Data-Types\"><a href=\"#Primitive-Data-Types\" class=\"headerlink\" title=\"Primitive Data Types\"></a>Primitive Data Types</h3><blockquote>\n<p>The Java programming language is statically-typed, which means that all variables must first be declared before they can be used. This involves stating the variable’s type and name.</p>\n</blockquote>\n<p>八种原始数据类型：<code>byte</code>(8-bit), <code>short</code>(16-bit), <code>int</code>(32-bit), <code>long</code>(64-bit), <code>float</code>(32-bit IEEE 754), <code>double</code>(64-bit IEEE 754), <code>boolean</code>, <code>char</code>(16-bit Unicode character).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int decVal &#x3D; 26; &#x2F;&#x2F; 十进制</span><br><span class=\"line\">int hexVal &#x3D; 0x1a; &#x2F;&#x2F; 十六进制</span><br><span class=\"line\">int binVal &#x3D; 0b11010; &#x2F;&#x2F; 二进制</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] a &#x3D; new int[10];</span><br><span class=\"line\"></span><br><span class=\"line\">int[] b &#x3D; &#123;1, 2, 3, 4&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int[][] xy &#x3D; &#123;</span><br><span class=\"line\">    &#123;1, 2&#125;,</span><br><span class=\"line\">    &#123;2, 4&#125;,</span><br><span class=\"line\">    &#123;3, 9&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h3><h3 id=\"Expressions-Statements-and-Blocks\"><a href=\"#Expressions-Statements-and-Blocks\" class=\"headerlink\" title=\"Expressions, Statements, and Blocks\"></a>Expressions, Statements, and Blocks</h3><p><strong>语句</strong>包括<strong>表达式语句</strong>、<strong>声明语句</strong>、<strong>流程控制语句</strong>。</p>\n<h3 id=\"Constrol-Flow-Statement\"><a href=\"#Constrol-Flow-Statement\" class=\"headerlink\" title=\"Constrol Flow Statement\"></a>Constrol Flow Statement</h3><p>常见流程控制语句：<code>if-then</code>, <code>switch</code>, <code>while</code>, <code>do-while</code>, <code>for</code>.</p>\n<h2 id=\"Classes-and-Objects\"><a href=\"#Classes-and-Objects\" class=\"headerlink\" title=\"Classes and Objects\"></a>Classes and Objects</h2><h3 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h3><h4 id=\"Declaring-Member-Variables\"><a href=\"#Declaring-Member-Variables\" class=\"headerlink\" title=\"Declaring Member Variables\"></a>Declaring Member Variables</h4><p>字段<strong>访问修饰符</strong>(Access Modifiers)：</p>\n<ul>\n<li><code>public</code>：所有类都可以访问</li>\n<li><code>private</code>：只能字段所属类访问</li>\n</ul>\n<h4 id=\"Defining-Methods\"><a href=\"#Defining-Methods\" class=\"headerlink\" title=\"Defining Methods\"></a>Defining Methods</h4><p>方法<strong>重载</strong>(overloading)</p>\n<blockquote>\n<p>Note: Overloaded methods should be used sparingly, as they can make code much less readable.</p>\n</blockquote>\n<h4 id=\"Providing-Constructors-for-Your-Classes\"><a href=\"#Providing-Constructors-for-Your-Classes\" class=\"headerlink\" title=\"Providing Constructors for Your Classes\"></a>Providing Constructors for Your Classes</h4><p>如果没有给类提供<strong>构造器</strong>，Java 编译器会自动补加一个默认的构造器，该构造器会调用父类的无参构造器。因此，如果父类提供无参构造器，编译器将会报错。</p>\n<p>形参(parameter)，实参(argument)。</p>\n<h4 id=\"Controlling-Access-to-Members-of-a-Class\"><a href=\"#Controlling-Access-to-Members-of-a-Class\" class=\"headerlink\" title=\"Controlling Access to Members of a Class\"></a>Controlling Access to Members of a Class</h4><p><strong>成员</strong>(members)指类中的字段和方法，包括类成员和实例成员。</p>\n<p>修饰符对成员的访问控制权限表：</p>\n<table>\n<thead>\n<tr>\n<th>Modifier</th>\n<th>Class</th>\n<th>Package</th>\n<th>Subclass</th>\n<th>World</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>public</code></td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td><code>protected</code></td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td><em>no modifier</em></td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td><code>private</code></td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p><strong>修饰符</strong>(modifier)使用时请遵循最严原则，也就是说优先使用 <code>private</code>，有理由使用其它修饰符除外。除了常量外，避免使用 <code>public</code> 修饰符。使用 <code>public</code> 修饰符会导致暴露过多的细节给类使用者，限制了类的具体实现，影响了之后修改代码的灵活性。</p>\n<h4 id=\"Understanding-Class-Members\"><a href=\"#Understanding-Class-Members\" class=\"headerlink\" title=\"Understanding Class Members\"></a>Understanding Class Members</h4><p>类变量可以直接通过类访问到，而不需要先初始化。类方法也是如此，并且类方法的调用只建议从类上调用，而不要在实例上调用，方便和实例方法做区分。</p>\n<p>类方法只能访问类变量和类方法，而实例方法可以访问实例变量、实例方法、类变量、类方法。</p>\n<p>通过 <code>static</code> 和 <code>final</code> 修饰符定义常量。常量在编译成字节码之后，就固定不变了。也就是说，假如修改了某个类中的常量，其他使用这个常量的类也需要重现编译。</p>\n<h3 id=\"Nested-Classes\"><a href=\"#Nested-Classes\" class=\"headerlink\" title=\"Nested Classes\"></a>Nested Classes</h3><p>为什么要使用嵌套类：</p>\n<ul>\n<li>对类进行逻辑上的分类：只在某个类中使用的类就声明在这个类里面</li>\n<li>增加封装性：嵌套类可以访问包裹类中的所有成员</li>\n<li>使代码易读和维护：代码上挨的更近</li>\n</ul>\n<p>注：我觉得这几点还有待商榷。</p>\n<p>嵌套类分为 Static Nested Classes 和 Inner Classes。</p>\n<blockquote>\n<p>Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.</p>\n</blockquote>\n<p>方法中定义类(Local and Anonymous Classes)</p>\n<h3 id=\"Lambda-Expressions\"><a href=\"#Lambda-Expressions\" class=\"headerlink\" title=\"Lambda Expressions\"></a>Lambda Expressions</h3><blockquote>\n<p>The operations filter, map, and forEach are <em>aggregate operations</em>.</p>\n</blockquote>\n<p>注意，Lambda 表达式不会引入新的作用域，也就意味着在表达式中不能重复定义外面出现过的变量。</p>\n<h3 id=\"When-to-Use-Nested-Classes-Local-Classes-Anonymous-Classes-and-Lambda-Expressions\"><a href=\"#When-to-Use-Nested-Classes-Local-Classes-Anonymous-Classes-and-Lambda-Expressions\" class=\"headerlink\" title=\"When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions\"></a>When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions</h3><h3 id=\"Enum-Types\"><a href=\"#Enum-Types\" class=\"headerlink\" title=\"Enum Types\"></a>Enum Types</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Planet &#123;</span><br><span class=\"line\">    MERCURY (3.303e+23, 2.4397e6),</span><br><span class=\"line\">    VENUS   (4.869e+24, 6.0518e6),</span><br><span class=\"line\">    EARTH   (5.976e+24, 6.37814e6),</span><br><span class=\"line\">    MARS    (6.421e+23, 3.3972e6),</span><br><span class=\"line\">    JUPITER (1.9e+27,   7.1492e7),</span><br><span class=\"line\">    SATURN  (5.688e+26, 6.0268e7),</span><br><span class=\"line\">    URANUS  (8.686e+25, 2.5559e7),</span><br><span class=\"line\">    NEPTUNE (1.024e+26, 2.4746e7);</span><br><span class=\"line\"></span><br><span class=\"line\">    private final double mass;   &#x2F;&#x2F; in kilograms</span><br><span class=\"line\">    private final double radius; &#x2F;&#x2F; in meters</span><br><span class=\"line\">    Planet(double mass, double radius) &#123;</span><br><span class=\"line\">        this.mass &#x3D; mass;</span><br><span class=\"line\">        this.radius &#x3D; radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private double mass() &#123; return mass; &#125;</span><br><span class=\"line\">    private double radius() &#123; return radius; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; universal gravitational constant  (m3 kg-1 s-2)</span><br><span class=\"line\">    public static final double G &#x3D; 6.67300E-11;</span><br><span class=\"line\"></span><br><span class=\"line\">    double surfaceGravity() &#123;</span><br><span class=\"line\">        return G * mass &#x2F; (radius * radius);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    double surfaceWeight(double otherMass) &#123;</span><br><span class=\"line\">        return otherMass * surfaceGravity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        if (args.length !&#x3D; 1) &#123;</span><br><span class=\"line\">            System.err.println(&quot;Usage: java Planet &lt;earth_weight&gt;&quot;);</span><br><span class=\"line\">            System.exit(-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        double earthWeight &#x3D; Double.parseDouble(args[0]);</span><br><span class=\"line\">        double mass &#x3D; earthWeight&#x2F;EARTH.surfaceGravity();</span><br><span class=\"line\">        for (Planet p : Planet.values())</span><br><span class=\"line\">           System.out.printf(&quot;Your weight on %s is %f%n&quot;,</span><br><span class=\"line\">                             p, p.surfaceWeight(mass));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Annotations\"><a href=\"#Annotations\" class=\"headerlink\" title=\"Annotations\"></a>Annotations</h2><p><strong>注解</strong>(<em>annotation</em>)，给程序提供元数据，但不是程序的一部分。</p>\n<p>作用：</p>\n<ul>\n<li>给编译器提供信息</li>\n<li>编译和部署时处理，生成代码，XML文件等</li>\n<li>运行时处理</li>\n</ul>\n<p>一些注解用于替代代码中的<strong>注释</strong>(<em>comment</em>)。</p>\n<p>一些注解用于其他注解上面，称为<strong>元注解</strong>(<em>meta-annotation</em>)。</p>\n<h2 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h2><p><strong>接口</strong>(<em>interface</em>)是<strong>引用类型</strong>(<em>reference type</em>)，可以包含<strong>抽象方法</strong>(<em>abstract method</em>)、<strong>默认方法</strong>(<em>default method</em>)、<strong>静态方法</strong>(<em>static method</em>)、<strong>常量</strong>(<em>constant</em>)。</p>\n<p>当需要扩充接口，但又不希望之前实现该接口的类进行修改时，可以通过定义默认方法或者静态方法来达到目的。</p>\n<h2 id=\"Inheritance\"><a href=\"#Inheritance\" class=\"headerlink\" title=\"Inheritance\"></a>Inheritance</h2><p>子类<strong>继承</strong>(*inheritance**)父类中被 <code>public</code> 和 <code>protected</code> 修饰的成员(members)。如果子类和父类属于同一个 package，那么子类还继承了父类中的 <em>package-private</em> 成员。</p>\n<p>作为所有类的祖先 Object 类（它自己没有父类了），它含有的以下方法会被继承：</p>\n<ul>\n<li><code>protected Object clone() throws CloneNotSupportedException</code></li>\n<li><code>public boolean equals(Object obj)</code></li>\n<li><code>protected void finalize() throws Throwable</code></li>\n<li><code>public final Class getClass()</code></li>\n<li><code>public int hashCode()</code></li>\n<li><code>public String toString()</code></li>\n</ul>\n<h3 id=\"Polymorphism\"><a href=\"#Polymorphism\" class=\"headerlink\" title=\"Polymorphism\"></a>Polymorphism</h3><p><strong>多态</strong>(<em>polymorphism</em>)</p>\n<blockquote>\n<p>The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable’s type. This behavior is referred to as <em>virtual method invocation</em> and demonstrates an aspect of the important polymorphism features in the Java language.</p>\n</blockquote>\n<h2 id=\"Packages\"><a href=\"#Packages\" class=\"headerlink\" title=\"Packages\"></a>Packages</h2><blockquote>\n<p>Definition: A <em>package</em> is a grouping of related types providing access protection and name space management. Note that <em>types</em> refers to classes, interfaces, enumerations, and annotation types.</p>\n</blockquote>\n<blockquote>\n<p>For convenience, the Java compiler automatically imports two entire packages for each source file: (1) the java.lang package and (2) the current package (the package for the current file).</p>\n</blockquote>\n<blockquote>\n<p>Both the compiler and the JVM construct the path to your .class files by adding the package name to the <em>class path</em>.</p>\n</blockquote>\n<h2 id=\"泛型-Generics\"><a href=\"#泛型-Generics\" class=\"headerlink\" title=\"泛型(Generics)\"></a>泛型(Generics)</h2><blockquote>\n<p>In a nutshell, generics enable <em>types</em> (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar <em>formal parameters</em> used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.</p>\n</blockquote>\n<blockquote>\n<p>Code that uses generics has many benefits over non-generic code:</p>\n<ul>\n<li>Stronger type checks at compile time.</li>\n<li>Elimination of casts.</li>\n<li>Enabling programmers to implement generic algorithms.</li>\n</ul>\n</blockquote>\n<p>动态指定类型，可以在类中，也可以在方法中。</p>\n","site":{"data":{}},"more":"<p>阅读材料：</p>\n<ul>\n<li><a href=\"http://docs.oracle.com/javase/tutorial/\">The Java Tutorials</a></li>\n</ul>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><h3 id=\"About-the-Java-Technology\"><a href=\"#About-the-Java-Technology\" class=\"headerlink\" title=\"About the Java Technology\"></a>About the Java Technology</h3><p>Java technology is both a programming language and a platform.</p>\n<h4 id=\"The-Java-Programming-Language\"><a href=\"#The-Java-Programming-Language\" class=\"headerlink\" title=\"The Java Programming Language\"></a>The Java Programming Language</h4><p>Java 语言的特点: Simple, Architecture neutral, Object oriented, Portable, Distributed, High performance, Multithreaded, Robust, Dynamic, Secure. Each of the buzzwords explained in <a href=\"http://www.oracle.com/technetwork/java/langenv-140151.html\">The Java Language Environment</a></p>\n<p><code>file.java</code> – 由 javac 编译 -&gt; <code>file.class</code>(bytecode) – 由 Java VM 运行 -&gt; 得到运行结果</p>\n<p>[Java SE HotSpot at a Glance](Java SE HotSpot at a Glance)</p>\n<h4 id=\"The-Java-Platform\"><a href=\"#The-Java-Platform\" class=\"headerlink\" title=\"The Java Platform\"></a>The Java Platform</h4><p>A <em>platform</em> is the hardware or software environment in which a program runs.</p>\n<p>Java 平台是一个软件平台。</p>\n<p>The Java platform has two components:</p>\n<ul>\n<li>The Java Virtual Machine</li>\n<li>The Java Application Programming Interface (API)</li>\n</ul>\n<p>作为平台独立的运行环境，Java 平台比原生平台运行的更慢些。</p>\n<h3 id=\"What-can-Java-Technology-Do\"><a href=\"#What-can-Java-Technology-Do\" class=\"headerlink\" title=\"What can Java Technology Do?\"></a>What can Java Technology Do?</h3><h3 id=\"How-Will-Java-Technology-Change-My-Life\"><a href=\"#How-Will-Java-Technology-Change-My-Life\" class=\"headerlink\" title=\"How Will Java Technology Change My Life?\"></a>How Will Java Technology Change My Life?</h3><h2 id=\"Learning-the-Java-Language\"><a href=\"#Learning-the-Java-Language\" class=\"headerlink\" title=\"Learning the Java Language\"></a>Learning the Java Language</h2><h3 id=\"Object-Oriented-Programming-Concepts\"><a href=\"#Object-Oriented-Programming-Concepts\" class=\"headerlink\" title=\"Object-Oriented Programming Concepts\"></a>Object-Oriented Programming Concepts</h3><h4 id=\"What-Is-an-Object\"><a href=\"#What-Is-an-Object\" class=\"headerlink\" title=\"What Is an Object?\"></a>What Is an Object?</h4><p>对象由<strong>状态(fields)**和相应的</strong>行为(methods)**组成。是对真实世界中的物体的模拟。</p>\n<p>面向对象编程的基础概念是**数据封装(data encapsulation)**，也就是说对象把自己的内部变量隐藏，只通过自己的方法和外界进行交互。</p>\n<p>对象化所带来的好处：模块化、信息隐藏、代码复用、可插拔性和易于调试。</p>\n<h4 id=\"What-Is-a-Class\"><a href=\"#What-Is-a-Class\" class=\"headerlink\" title=\"What Is a Class?\"></a>What Is a Class?</h4><p>类是对象创建时所参考的蓝图，对象也可以叫做类的实例。</p>\n<h4 id=\"What-Is-Inheritance\"><a href=\"#What-Is-Inheritance\" class=\"headerlink\" title=\"What Is Inheritance?\"></a>What Is Inheritance?</h4><p><strong>继承</strong>用于抽象不同类之间的相似之处，使类之间层次清楚，代码易读。</p>\n<h4 id=\"What-Is-an-Interface\"><a href=\"#What-Is-an-Interface\" class=\"headerlink\" title=\"What Is an Interface?\"></a>What Is an Interface?</h4><p>对象通过<strong>接口</strong>与外界（其他对象）进行交互。</p>\n<h4 id=\"What-Is-a-Package\"><a href=\"#What-Is-a-Package\" class=\"headerlink\" title=\"What Is a Package?\"></a>What Is a Package?</h4><p><strong>包</strong>是用于组织一系列相关<strong>类</strong>和<strong>接口</strong>的命名空间。</p>\n<h2 id=\"Language-Basics\"><a href=\"#Language-Basics\" class=\"headerlink\" title=\"Language Basics\"></a>Language Basics</h2><h3 id=\"Variables\"><a href=\"#Variables\" class=\"headerlink\" title=\"Variables\"></a>Variables</h3><p>Java 中存在以下几种变量：</p>\n<ul>\n<li><strong>实例变量 (Instance Variables, Non-Static Fields)</strong></li>\n<li>**类变量 (Class Variables, Static Fields)**：使用 <code>static</code> 修饰符(modifiers)修饰的 fields</li>\n<li><strong>局部变量 (Local Variables)</strong></li>\n<li><strong>参数 (Parameters)</strong></li>\n</ul>\n<h3 id=\"Primitive-Data-Types\"><a href=\"#Primitive-Data-Types\" class=\"headerlink\" title=\"Primitive Data Types\"></a>Primitive Data Types</h3><blockquote>\n<p>The Java programming language is statically-typed, which means that all variables must first be declared before they can be used. This involves stating the variable’s type and name.</p>\n</blockquote>\n<p>八种原始数据类型：<code>byte</code>(8-bit), <code>short</code>(16-bit), <code>int</code>(32-bit), <code>long</code>(64-bit), <code>float</code>(32-bit IEEE 754), <code>double</code>(64-bit IEEE 754), <code>boolean</code>, <code>char</code>(16-bit Unicode character).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int decVal &#x3D; 26; &#x2F;&#x2F; 十进制</span><br><span class=\"line\">int hexVal &#x3D; 0x1a; &#x2F;&#x2F; 十六进制</span><br><span class=\"line\">int binVal &#x3D; 0b11010; &#x2F;&#x2F; 二进制</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] a &#x3D; new int[10];</span><br><span class=\"line\"></span><br><span class=\"line\">int[] b &#x3D; &#123;1, 2, 3, 4&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int[][] xy &#x3D; &#123;</span><br><span class=\"line\">    &#123;1, 2&#125;,</span><br><span class=\"line\">    &#123;2, 4&#125;,</span><br><span class=\"line\">    &#123;3, 9&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h3><h3 id=\"Expressions-Statements-and-Blocks\"><a href=\"#Expressions-Statements-and-Blocks\" class=\"headerlink\" title=\"Expressions, Statements, and Blocks\"></a>Expressions, Statements, and Blocks</h3><p><strong>语句</strong>包括<strong>表达式语句</strong>、<strong>声明语句</strong>、<strong>流程控制语句</strong>。</p>\n<h3 id=\"Constrol-Flow-Statement\"><a href=\"#Constrol-Flow-Statement\" class=\"headerlink\" title=\"Constrol Flow Statement\"></a>Constrol Flow Statement</h3><p>常见流程控制语句：<code>if-then</code>, <code>switch</code>, <code>while</code>, <code>do-while</code>, <code>for</code>.</p>\n<h2 id=\"Classes-and-Objects\"><a href=\"#Classes-and-Objects\" class=\"headerlink\" title=\"Classes and Objects\"></a>Classes and Objects</h2><h3 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h3><h4 id=\"Declaring-Member-Variables\"><a href=\"#Declaring-Member-Variables\" class=\"headerlink\" title=\"Declaring Member Variables\"></a>Declaring Member Variables</h4><p>字段<strong>访问修饰符</strong>(Access Modifiers)：</p>\n<ul>\n<li><code>public</code>：所有类都可以访问</li>\n<li><code>private</code>：只能字段所属类访问</li>\n</ul>\n<h4 id=\"Defining-Methods\"><a href=\"#Defining-Methods\" class=\"headerlink\" title=\"Defining Methods\"></a>Defining Methods</h4><p>方法<strong>重载</strong>(overloading)</p>\n<blockquote>\n<p>Note: Overloaded methods should be used sparingly, as they can make code much less readable.</p>\n</blockquote>\n<h4 id=\"Providing-Constructors-for-Your-Classes\"><a href=\"#Providing-Constructors-for-Your-Classes\" class=\"headerlink\" title=\"Providing Constructors for Your Classes\"></a>Providing Constructors for Your Classes</h4><p>如果没有给类提供<strong>构造器</strong>，Java 编译器会自动补加一个默认的构造器，该构造器会调用父类的无参构造器。因此，如果父类提供无参构造器，编译器将会报错。</p>\n<p>形参(parameter)，实参(argument)。</p>\n<h4 id=\"Controlling-Access-to-Members-of-a-Class\"><a href=\"#Controlling-Access-to-Members-of-a-Class\" class=\"headerlink\" title=\"Controlling Access to Members of a Class\"></a>Controlling Access to Members of a Class</h4><p><strong>成员</strong>(members)指类中的字段和方法，包括类成员和实例成员。</p>\n<p>修饰符对成员的访问控制权限表：</p>\n<table>\n<thead>\n<tr>\n<th>Modifier</th>\n<th>Class</th>\n<th>Package</th>\n<th>Subclass</th>\n<th>World</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>public</code></td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td><code>protected</code></td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td><em>no modifier</em></td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td><code>private</code></td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p><strong>修饰符</strong>(modifier)使用时请遵循最严原则，也就是说优先使用 <code>private</code>，有理由使用其它修饰符除外。除了常量外，避免使用 <code>public</code> 修饰符。使用 <code>public</code> 修饰符会导致暴露过多的细节给类使用者，限制了类的具体实现，影响了之后修改代码的灵活性。</p>\n<h4 id=\"Understanding-Class-Members\"><a href=\"#Understanding-Class-Members\" class=\"headerlink\" title=\"Understanding Class Members\"></a>Understanding Class Members</h4><p>类变量可以直接通过类访问到，而不需要先初始化。类方法也是如此，并且类方法的调用只建议从类上调用，而不要在实例上调用，方便和实例方法做区分。</p>\n<p>类方法只能访问类变量和类方法，而实例方法可以访问实例变量、实例方法、类变量、类方法。</p>\n<p>通过 <code>static</code> 和 <code>final</code> 修饰符定义常量。常量在编译成字节码之后，就固定不变了。也就是说，假如修改了某个类中的常量，其他使用这个常量的类也需要重现编译。</p>\n<h3 id=\"Nested-Classes\"><a href=\"#Nested-Classes\" class=\"headerlink\" title=\"Nested Classes\"></a>Nested Classes</h3><p>为什么要使用嵌套类：</p>\n<ul>\n<li>对类进行逻辑上的分类：只在某个类中使用的类就声明在这个类里面</li>\n<li>增加封装性：嵌套类可以访问包裹类中的所有成员</li>\n<li>使代码易读和维护：代码上挨的更近</li>\n</ul>\n<p>注：我觉得这几点还有待商榷。</p>\n<p>嵌套类分为 Static Nested Classes 和 Inner Classes。</p>\n<blockquote>\n<p>Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.</p>\n</blockquote>\n<p>方法中定义类(Local and Anonymous Classes)</p>\n<h3 id=\"Lambda-Expressions\"><a href=\"#Lambda-Expressions\" class=\"headerlink\" title=\"Lambda Expressions\"></a>Lambda Expressions</h3><blockquote>\n<p>The operations filter, map, and forEach are <em>aggregate operations</em>.</p>\n</blockquote>\n<p>注意，Lambda 表达式不会引入新的作用域，也就意味着在表达式中不能重复定义外面出现过的变量。</p>\n<h3 id=\"When-to-Use-Nested-Classes-Local-Classes-Anonymous-Classes-and-Lambda-Expressions\"><a href=\"#When-to-Use-Nested-Classes-Local-Classes-Anonymous-Classes-and-Lambda-Expressions\" class=\"headerlink\" title=\"When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions\"></a>When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions</h3><h3 id=\"Enum-Types\"><a href=\"#Enum-Types\" class=\"headerlink\" title=\"Enum Types\"></a>Enum Types</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Planet &#123;</span><br><span class=\"line\">    MERCURY (3.303e+23, 2.4397e6),</span><br><span class=\"line\">    VENUS   (4.869e+24, 6.0518e6),</span><br><span class=\"line\">    EARTH   (5.976e+24, 6.37814e6),</span><br><span class=\"line\">    MARS    (6.421e+23, 3.3972e6),</span><br><span class=\"line\">    JUPITER (1.9e+27,   7.1492e7),</span><br><span class=\"line\">    SATURN  (5.688e+26, 6.0268e7),</span><br><span class=\"line\">    URANUS  (8.686e+25, 2.5559e7),</span><br><span class=\"line\">    NEPTUNE (1.024e+26, 2.4746e7);</span><br><span class=\"line\"></span><br><span class=\"line\">    private final double mass;   &#x2F;&#x2F; in kilograms</span><br><span class=\"line\">    private final double radius; &#x2F;&#x2F; in meters</span><br><span class=\"line\">    Planet(double mass, double radius) &#123;</span><br><span class=\"line\">        this.mass &#x3D; mass;</span><br><span class=\"line\">        this.radius &#x3D; radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private double mass() &#123; return mass; &#125;</span><br><span class=\"line\">    private double radius() &#123; return radius; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; universal gravitational constant  (m3 kg-1 s-2)</span><br><span class=\"line\">    public static final double G &#x3D; 6.67300E-11;</span><br><span class=\"line\"></span><br><span class=\"line\">    double surfaceGravity() &#123;</span><br><span class=\"line\">        return G * mass &#x2F; (radius * radius);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    double surfaceWeight(double otherMass) &#123;</span><br><span class=\"line\">        return otherMass * surfaceGravity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        if (args.length !&#x3D; 1) &#123;</span><br><span class=\"line\">            System.err.println(&quot;Usage: java Planet &lt;earth_weight&gt;&quot;);</span><br><span class=\"line\">            System.exit(-1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        double earthWeight &#x3D; Double.parseDouble(args[0]);</span><br><span class=\"line\">        double mass &#x3D; earthWeight&#x2F;EARTH.surfaceGravity();</span><br><span class=\"line\">        for (Planet p : Planet.values())</span><br><span class=\"line\">           System.out.printf(&quot;Your weight on %s is %f%n&quot;,</span><br><span class=\"line\">                             p, p.surfaceWeight(mass));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Annotations\"><a href=\"#Annotations\" class=\"headerlink\" title=\"Annotations\"></a>Annotations</h2><p><strong>注解</strong>(<em>annotation</em>)，给程序提供元数据，但不是程序的一部分。</p>\n<p>作用：</p>\n<ul>\n<li>给编译器提供信息</li>\n<li>编译和部署时处理，生成代码，XML文件等</li>\n<li>运行时处理</li>\n</ul>\n<p>一些注解用于替代代码中的<strong>注释</strong>(<em>comment</em>)。</p>\n<p>一些注解用于其他注解上面，称为<strong>元注解</strong>(<em>meta-annotation</em>)。</p>\n<h2 id=\"Interfaces\"><a href=\"#Interfaces\" class=\"headerlink\" title=\"Interfaces\"></a>Interfaces</h2><p><strong>接口</strong>(<em>interface</em>)是<strong>引用类型</strong>(<em>reference type</em>)，可以包含<strong>抽象方法</strong>(<em>abstract method</em>)、<strong>默认方法</strong>(<em>default method</em>)、<strong>静态方法</strong>(<em>static method</em>)、<strong>常量</strong>(<em>constant</em>)。</p>\n<p>当需要扩充接口，但又不希望之前实现该接口的类进行修改时，可以通过定义默认方法或者静态方法来达到目的。</p>\n<h2 id=\"Inheritance\"><a href=\"#Inheritance\" class=\"headerlink\" title=\"Inheritance\"></a>Inheritance</h2><p>子类<strong>继承</strong>(*inheritance**)父类中被 <code>public</code> 和 <code>protected</code> 修饰的成员(members)。如果子类和父类属于同一个 package，那么子类还继承了父类中的 <em>package-private</em> 成员。</p>\n<p>作为所有类的祖先 Object 类（它自己没有父类了），它含有的以下方法会被继承：</p>\n<ul>\n<li><code>protected Object clone() throws CloneNotSupportedException</code></li>\n<li><code>public boolean equals(Object obj)</code></li>\n<li><code>protected void finalize() throws Throwable</code></li>\n<li><code>public final Class getClass()</code></li>\n<li><code>public int hashCode()</code></li>\n<li><code>public String toString()</code></li>\n</ul>\n<h3 id=\"Polymorphism\"><a href=\"#Polymorphism\" class=\"headerlink\" title=\"Polymorphism\"></a>Polymorphism</h3><p><strong>多态</strong>(<em>polymorphism</em>)</p>\n<blockquote>\n<p>The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable’s type. This behavior is referred to as <em>virtual method invocation</em> and demonstrates an aspect of the important polymorphism features in the Java language.</p>\n</blockquote>\n<h2 id=\"Packages\"><a href=\"#Packages\" class=\"headerlink\" title=\"Packages\"></a>Packages</h2><blockquote>\n<p>Definition: A <em>package</em> is a grouping of related types providing access protection and name space management. Note that <em>types</em> refers to classes, interfaces, enumerations, and annotation types.</p>\n</blockquote>\n<blockquote>\n<p>For convenience, the Java compiler automatically imports two entire packages for each source file: (1) the java.lang package and (2) the current package (the package for the current file).</p>\n</blockquote>\n<blockquote>\n<p>Both the compiler and the JVM construct the path to your .class files by adding the package name to the <em>class path</em>.</p>\n</blockquote>\n<h2 id=\"泛型-Generics\"><a href=\"#泛型-Generics\" class=\"headerlink\" title=\"泛型(Generics)\"></a>泛型(Generics)</h2><blockquote>\n<p>In a nutshell, generics enable <em>types</em> (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar <em>formal parameters</em> used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.</p>\n</blockquote>\n<blockquote>\n<p>Code that uses generics has many benefits over non-generic code:</p>\n<ul>\n<li>Stronger type checks at compile time.</li>\n<li>Elimination of casts.</li>\n<li>Enabling programmers to implement generic algorithms.</li>\n</ul>\n</blockquote>\n<p>动态指定类型，可以在类中，也可以在方法中。</p>\n"},{"title":"Nand2Tetris Part 1 课程总结","date":"2020-07-16T16:00:00.000Z","excerpt":"按：本文记录我在学习完Coursera上的 Nand2Tetris Part 1 课程之后的总结与思考。","_content":"\n\n\n今天完成了Coursera上的 [Nand2Tetris Part 1](https://www.coursera.org/learn/build-a-computer) 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在[这里](https://gitee.com/lhtin/Nand2TetrisLabs)可以看到我完成的答案。\n\n每个Project完成情况如下：\n\n- 7-10 完成 [Project1](https://www.nand2tetris.org/project01)\n- 7-11 完成 [Project2](https://www.nand2tetris.org/project02)\n- 7-12 完成 [Project3](https://www.nand2tetris.org/project03)\n- 7-13 完成 [Project4](https://www.nand2tetris.org/project04)\n- 7-15 完成 [Project5](https://www.nand2tetris.org/project05)\n- 7-16 完成 [Project6](https://www.nand2tetris.org/project06)\n\n完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。\n\n**在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）**\n\n\n\n### 项目总结\n\n整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。\n\nProject1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。\n\n选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。\n\n下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：\n\n```\nNand(a, b) = 如果a和b同时为1，则结果为0，否则结果为1\n\n// Not(0)的情况返回1，Not(1)返回0\nNot(in) = Nand(in, in)\n\n// And(1,1)的情况返回1，其他情况返回0\nAnd(a, b) = Not(Nand(a, b))\n\n// Or(0,0)的情况返回0，其他情况返回1\nOr(a, b) = Nand(Not(a), Not(b))\n\n// 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0\nXor(a, b) = Or(And(Not(a), b), And(a, Not(b)))\n```\n\n\n\nProject2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。\n\nHack ALU支持的运算如下：\n\n```\nALU(x, y) = 0 | 1 | -1 | x | y | !x | !y | -x | -y\n          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x\n          | x&y | x|y\n```\n\n\n\nProject3引入一种新类型的电路，[时序逻辑电路](https://en.wikipedia.org/wiki/Sequential_logic)，而前面构建的都是[组合逻辑电路](https://en.wikipedia.org/wiki/Combinational_logic)。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。\n\n**话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。**\n\n\n\nProject4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。\n\n\n\nProject5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是`@123`指令，则表示将123设置到A寄存器中。\n\n完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：\n\n![](/images/nand2tetris-1/CPU.png)\n\n在设计CPU时，需要注意几点：\n\n1. A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。\n2. 根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。\n3. **每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。**\n\n\n\nProject6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。\n\nHack汇编语言BNF描述如下：\n\n```\nProgram -> Stats\nStats   -> Stat Stats\n        |  ε\nState \t-> A-Inst | C-Inst | Branch | Comment\nA-Inst \t-> \"@\" num | '@' Symbol\nC-Inst \t-> Dest comp Jump\nBranch  -> \"(\" symbol \")\"\nComment -> \"//\" [^\\n]+\n\nSymbol  -> \"R0\" | ... | \"R15\" \n        |  \"SP\" | \"LCL\" | \"ARG\" | \"THIS\" | \"THAT\" | \"SCREEN\" | \"KBD\" \n        |  symbol\nDest    -> dest \"=\"\n        |  ε\nJump    -> \";\" jump\n        |  ε\n\ndest    -> \"A\" | \"D\" | \"M\" | \"AD\" | \"AM\" | \"MD\" | \"AMD\"\ncomp    -> \"0\" | \"1\" | \"-1\" | \"D\" | \"A\" | \"!D\" | \"!A\" | \"-D\" | \"-A\"\n        |  \"D+1\" | \"A+1\" | \"D-1\" | \"A-1\" | \"D+A\" | \"D-A\" | \"A-D\" | \"D&A\" | \"D|A\" \n        |  \"M\" | \"!M\" | \"-M\" | \"M+1\" | \"M-1\" | \"D+M\" | \"D-M\" | \"M-D\" | \"D&M\" | \"D|M\"\njump    -> \"JGT\" | \"JEG\" | \"JGE\" | \"JLT\" | \"JNE\" | \"JLE\" | \"JMP\"\nnum     -> [0-9]+\nsymbol  -> [a-zA-Z_.$:][a-zA-Z_.$:0-9]+\n```\n\n示例程序：\n\n```\n// Computes R2 = max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])\n\n   @R0\n   D=M              // D = first number\n   @R1\n   D=D-M            // D = first number - second number\n   @OUTPUT_FIRST\n   D;JGT            // if D>0 (first is greater) goto output_first\n   @R1\n   D=M              // D = second number\n   @OUTPUT_D\n   0;JMP            // goto output_d\n(OUTPUT_FIRST)\n   @R0             \n   D=M              // D = first number\n(OUTPUT_D)\n   @R2\n   M=D              // M[2] = D (greatest number)\n(INFINITE_LOOP)\n   @INFINITE_LOOP\n   0;JMP            // infinite loop\n```\n\n","source":"_posts/nand2tetris-1.md","raw":"---\ntitle: Nand2Tetris Part 1 课程总结\ndate: 2020/07/17\ntag:\n- nand2tetris\ncategory:\n- note\nexcerpt: 按：本文记录我在学习完Coursera上的 Nand2Tetris Part 1 课程之后的总结与思考。\n---\n\n\n\n今天完成了Coursera上的 [Nand2Tetris Part 1](https://www.coursera.org/learn/build-a-computer) 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在[这里](https://gitee.com/lhtin/Nand2TetrisLabs)可以看到我完成的答案。\n\n每个Project完成情况如下：\n\n- 7-10 完成 [Project1](https://www.nand2tetris.org/project01)\n- 7-11 完成 [Project2](https://www.nand2tetris.org/project02)\n- 7-12 完成 [Project3](https://www.nand2tetris.org/project03)\n- 7-13 完成 [Project4](https://www.nand2tetris.org/project04)\n- 7-15 完成 [Project5](https://www.nand2tetris.org/project05)\n- 7-16 完成 [Project6](https://www.nand2tetris.org/project06)\n\n完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。\n\n**在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）**\n\n\n\n### 项目总结\n\n整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。\n\nProject1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。\n\n选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。\n\n下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：\n\n```\nNand(a, b) = 如果a和b同时为1，则结果为0，否则结果为1\n\n// Not(0)的情况返回1，Not(1)返回0\nNot(in) = Nand(in, in)\n\n// And(1,1)的情况返回1，其他情况返回0\nAnd(a, b) = Not(Nand(a, b))\n\n// Or(0,0)的情况返回0，其他情况返回1\nOr(a, b) = Nand(Not(a), Not(b))\n\n// 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0\nXor(a, b) = Or(And(Not(a), b), And(a, Not(b)))\n```\n\n\n\nProject2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。\n\nHack ALU支持的运算如下：\n\n```\nALU(x, y) = 0 | 1 | -1 | x | y | !x | !y | -x | -y\n          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x\n          | x&y | x|y\n```\n\n\n\nProject3引入一种新类型的电路，[时序逻辑电路](https://en.wikipedia.org/wiki/Sequential_logic)，而前面构建的都是[组合逻辑电路](https://en.wikipedia.org/wiki/Combinational_logic)。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。\n\n**话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。**\n\n\n\nProject4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。\n\n\n\nProject5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是`@123`指令，则表示将123设置到A寄存器中。\n\n完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：\n\n![](/images/nand2tetris-1/CPU.png)\n\n在设计CPU时，需要注意几点：\n\n1. A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。\n2. 根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。\n3. **每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。**\n\n\n\nProject6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。\n\nHack汇编语言BNF描述如下：\n\n```\nProgram -> Stats\nStats   -> Stat Stats\n        |  ε\nState \t-> A-Inst | C-Inst | Branch | Comment\nA-Inst \t-> \"@\" num | '@' Symbol\nC-Inst \t-> Dest comp Jump\nBranch  -> \"(\" symbol \")\"\nComment -> \"//\" [^\\n]+\n\nSymbol  -> \"R0\" | ... | \"R15\" \n        |  \"SP\" | \"LCL\" | \"ARG\" | \"THIS\" | \"THAT\" | \"SCREEN\" | \"KBD\" \n        |  symbol\nDest    -> dest \"=\"\n        |  ε\nJump    -> \";\" jump\n        |  ε\n\ndest    -> \"A\" | \"D\" | \"M\" | \"AD\" | \"AM\" | \"MD\" | \"AMD\"\ncomp    -> \"0\" | \"1\" | \"-1\" | \"D\" | \"A\" | \"!D\" | \"!A\" | \"-D\" | \"-A\"\n        |  \"D+1\" | \"A+1\" | \"D-1\" | \"A-1\" | \"D+A\" | \"D-A\" | \"A-D\" | \"D&A\" | \"D|A\" \n        |  \"M\" | \"!M\" | \"-M\" | \"M+1\" | \"M-1\" | \"D+M\" | \"D-M\" | \"M-D\" | \"D&M\" | \"D|M\"\njump    -> \"JGT\" | \"JEG\" | \"JGE\" | \"JLT\" | \"JNE\" | \"JLE\" | \"JMP\"\nnum     -> [0-9]+\nsymbol  -> [a-zA-Z_.$:][a-zA-Z_.$:0-9]+\n```\n\n示例程序：\n\n```\n// Computes R2 = max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])\n\n   @R0\n   D=M              // D = first number\n   @R1\n   D=D-M            // D = first number - second number\n   @OUTPUT_FIRST\n   D;JGT            // if D>0 (first is greater) goto output_first\n   @R1\n   D=M              // D = second number\n   @OUTPUT_D\n   0;JMP            // goto output_d\n(OUTPUT_FIRST)\n   @R0             \n   D=M              // D = first number\n(OUTPUT_D)\n   @R2\n   M=D              // M[2] = D (greatest number)\n(INFINITE_LOOP)\n   @INFINITE_LOOP\n   0;JMP            // infinite loop\n```\n\n","slug":"nand2tetris-1","published":1,"updated":"2020-11-28T14:23:40.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzu0004rnq7cwzg9n6n","content":"<p>今天完成了Coursera上的 <a href=\"https://www.coursera.org/learn/build-a-computer\">Nand2Tetris Part 1</a> 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在<a href=\"https://gitee.com/lhtin/Nand2TetrisLabs\">这里</a>可以看到我完成的答案。</p>\n<p>每个Project完成情况如下：</p>\n<ul>\n<li>7-10 完成 <a href=\"https://www.nand2tetris.org/project01\">Project1</a></li>\n<li>7-11 完成 <a href=\"https://www.nand2tetris.org/project02\">Project2</a></li>\n<li>7-12 完成 <a href=\"https://www.nand2tetris.org/project03\">Project3</a></li>\n<li>7-13 完成 <a href=\"https://www.nand2tetris.org/project04\">Project4</a></li>\n<li>7-15 完成 <a href=\"https://www.nand2tetris.org/project05\">Project5</a></li>\n<li>7-16 完成 <a href=\"https://www.nand2tetris.org/project06\">Project6</a></li>\n</ul>\n<p>完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。</p>\n<p><strong>在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）</strong></p>\n<h3 id=\"项目总结\"><a href=\"#项目总结\" class=\"headerlink\" title=\"项目总结\"></a>项目总结</h3><p>整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。</p>\n<p>Project1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。</p>\n<p>选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。</p>\n<p>下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nand(a, b) &#x3D; 如果a和b同时为1，则结果为0，否则结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Not(0)的情况返回1，Not(1)返回0</span><br><span class=\"line\">Not(in) &#x3D; Nand(in, in)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; And(1,1)的情况返回1，其他情况返回0</span><br><span class=\"line\">And(a, b) &#x3D; Not(Nand(a, b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Or(0,0)的情况返回0，其他情况返回1</span><br><span class=\"line\">Or(a, b) &#x3D; Nand(Not(a), Not(b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0</span><br><span class=\"line\">Xor(a, b) &#x3D; Or(And(Not(a), b), And(a, Not(b)))</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。</p>\n<p>Hack ALU支持的运算如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALU(x, y) &#x3D; 0 | 1 | -1 | x | y | !x | !y | -x | -y</span><br><span class=\"line\">          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x</span><br><span class=\"line\">          | x&amp;y | x|y</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project3引入一种新类型的电路，<a href=\"https://en.wikipedia.org/wiki/Sequential_logic\">时序逻辑电路</a>，而前面构建的都是<a href=\"https://en.wikipedia.org/wiki/Combinational_logic\">组合逻辑电路</a>。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。</p>\n<p><strong>话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。</strong></p>\n<p>Project4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。</p>\n<p>Project5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是<code>@123</code>指令，则表示将123设置到A寄存器中。</p>\n<p>完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：</p>\n<p><img src=\"/images/nand2tetris-1/CPU.png\"></p>\n<p>在设计CPU时，需要注意几点：</p>\n<ol>\n<li>A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。</li>\n<li>根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。</li>\n<li><strong>每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。</strong></li>\n</ol>\n<p>Project6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。</p>\n<p>Hack汇编语言BNF描述如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program -&gt; Stats</span><br><span class=\"line\">Stats   -&gt; Stat Stats</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">State \t-&gt; A-Inst | C-Inst | Branch | Comment</span><br><span class=\"line\">A-Inst \t-&gt; &quot;@&quot; num | &#39;@&#39; Symbol</span><br><span class=\"line\">C-Inst \t-&gt; Dest comp Jump</span><br><span class=\"line\">Branch  -&gt; &quot;(&quot; symbol &quot;)&quot;</span><br><span class=\"line\">Comment -&gt; &quot;&#x2F;&#x2F;&quot; [^\\n]+</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol  -&gt; &quot;R0&quot; | ... | &quot;R15&quot; </span><br><span class=\"line\">        |  &quot;SP&quot; | &quot;LCL&quot; | &quot;ARG&quot; | &quot;THIS&quot; | &quot;THAT&quot; | &quot;SCREEN&quot; | &quot;KBD&quot; </span><br><span class=\"line\">        |  symbol</span><br><span class=\"line\">Dest    -&gt; dest &quot;&#x3D;&quot;</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">Jump    -&gt; &quot;;&quot; jump</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\"></span><br><span class=\"line\">dest    -&gt; &quot;A&quot; | &quot;D&quot; | &quot;M&quot; | &quot;AD&quot; | &quot;AM&quot; | &quot;MD&quot; | &quot;AMD&quot;</span><br><span class=\"line\">comp    -&gt; &quot;0&quot; | &quot;1&quot; | &quot;-1&quot; | &quot;D&quot; | &quot;A&quot; | &quot;!D&quot; | &quot;!A&quot; | &quot;-D&quot; | &quot;-A&quot;</span><br><span class=\"line\">        |  &quot;D+1&quot; | &quot;A+1&quot; | &quot;D-1&quot; | &quot;A-1&quot; | &quot;D+A&quot; | &quot;D-A&quot; | &quot;A-D&quot; | &quot;D&amp;A&quot; | &quot;D|A&quot; </span><br><span class=\"line\">        |  &quot;M&quot; | &quot;!M&quot; | &quot;-M&quot; | &quot;M+1&quot; | &quot;M-1&quot; | &quot;D+M&quot; | &quot;D-M&quot; | &quot;M-D&quot; | &quot;D&amp;M&quot; | &quot;D|M&quot;</span><br><span class=\"line\">jump    -&gt; &quot;JGT&quot; | &quot;JEG&quot; | &quot;JGE&quot; | &quot;JLT&quot; | &quot;JNE&quot; | &quot;JLE&quot; | &quot;JMP&quot;</span><br><span class=\"line\">num     -&gt; [0-9]+</span><br><span class=\"line\">symbol  -&gt; [a-zA-Z_.$:][a-zA-Z_.$:0-9]+</span><br></pre></td></tr></table></figure>\n\n<p>示例程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Computes R2 &#x3D; max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])</span><br><span class=\"line\"></span><br><span class=\"line\">   @R0</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;D-M            &#x2F;&#x2F; D &#x3D; first number - second number</span><br><span class=\"line\">   @OUTPUT_FIRST</span><br><span class=\"line\">   D;JGT            &#x2F;&#x2F; if D&gt;0 (first is greater) goto output_first</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; second number</span><br><span class=\"line\">   @OUTPUT_D</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; goto output_d</span><br><span class=\"line\">(OUTPUT_FIRST)</span><br><span class=\"line\">   @R0             </span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">(OUTPUT_D)</span><br><span class=\"line\">   @R2</span><br><span class=\"line\">   M&#x3D;D              &#x2F;&#x2F; M[2] &#x3D; D (greatest number)</span><br><span class=\"line\">(INFINITE_LOOP)</span><br><span class=\"line\">   @INFINITE_LOOP</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; infinite loop</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"more":"<p>今天完成了Coursera上的 <a href=\"https://www.coursera.org/learn/build-a-computer\">Nand2Tetris Part 1</a> 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在<a href=\"https://gitee.com/lhtin/Nand2TetrisLabs\">这里</a>可以看到我完成的答案。</p>\n<p>每个Project完成情况如下：</p>\n<ul>\n<li>7-10 完成 <a href=\"https://www.nand2tetris.org/project01\">Project1</a></li>\n<li>7-11 完成 <a href=\"https://www.nand2tetris.org/project02\">Project2</a></li>\n<li>7-12 完成 <a href=\"https://www.nand2tetris.org/project03\">Project3</a></li>\n<li>7-13 完成 <a href=\"https://www.nand2tetris.org/project04\">Project4</a></li>\n<li>7-15 完成 <a href=\"https://www.nand2tetris.org/project05\">Project5</a></li>\n<li>7-16 完成 <a href=\"https://www.nand2tetris.org/project06\">Project6</a></li>\n</ul>\n<p>完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。</p>\n<p><strong>在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）</strong></p>\n<h3 id=\"项目总结\"><a href=\"#项目总结\" class=\"headerlink\" title=\"项目总结\"></a>项目总结</h3><p>整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。</p>\n<p>Project1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。</p>\n<p>选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。</p>\n<p>下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nand(a, b) &#x3D; 如果a和b同时为1，则结果为0，否则结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Not(0)的情况返回1，Not(1)返回0</span><br><span class=\"line\">Not(in) &#x3D; Nand(in, in)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; And(1,1)的情况返回1，其他情况返回0</span><br><span class=\"line\">And(a, b) &#x3D; Not(Nand(a, b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Or(0,0)的情况返回0，其他情况返回1</span><br><span class=\"line\">Or(a, b) &#x3D; Nand(Not(a), Not(b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0</span><br><span class=\"line\">Xor(a, b) &#x3D; Or(And(Not(a), b), And(a, Not(b)))</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。</p>\n<p>Hack ALU支持的运算如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALU(x, y) &#x3D; 0 | 1 | -1 | x | y | !x | !y | -x | -y</span><br><span class=\"line\">          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x</span><br><span class=\"line\">          | x&amp;y | x|y</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project3引入一种新类型的电路，<a href=\"https://en.wikipedia.org/wiki/Sequential_logic\">时序逻辑电路</a>，而前面构建的都是<a href=\"https://en.wikipedia.org/wiki/Combinational_logic\">组合逻辑电路</a>。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。</p>\n<p><strong>话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。</strong></p>\n<p>Project4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。</p>\n<p>Project5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是<code>@123</code>指令，则表示将123设置到A寄存器中。</p>\n<p>完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：</p>\n<p><img src=\"/images/nand2tetris-1/CPU.png\"></p>\n<p>在设计CPU时，需要注意几点：</p>\n<ol>\n<li>A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。</li>\n<li>根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。</li>\n<li><strong>每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。</strong></li>\n</ol>\n<p>Project6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。</p>\n<p>Hack汇编语言BNF描述如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program -&gt; Stats</span><br><span class=\"line\">Stats   -&gt; Stat Stats</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">State \t-&gt; A-Inst | C-Inst | Branch | Comment</span><br><span class=\"line\">A-Inst \t-&gt; &quot;@&quot; num | &#39;@&#39; Symbol</span><br><span class=\"line\">C-Inst \t-&gt; Dest comp Jump</span><br><span class=\"line\">Branch  -&gt; &quot;(&quot; symbol &quot;)&quot;</span><br><span class=\"line\">Comment -&gt; &quot;&#x2F;&#x2F;&quot; [^\\n]+</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol  -&gt; &quot;R0&quot; | ... | &quot;R15&quot; </span><br><span class=\"line\">        |  &quot;SP&quot; | &quot;LCL&quot; | &quot;ARG&quot; | &quot;THIS&quot; | &quot;THAT&quot; | &quot;SCREEN&quot; | &quot;KBD&quot; </span><br><span class=\"line\">        |  symbol</span><br><span class=\"line\">Dest    -&gt; dest &quot;&#x3D;&quot;</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">Jump    -&gt; &quot;;&quot; jump</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\"></span><br><span class=\"line\">dest    -&gt; &quot;A&quot; | &quot;D&quot; | &quot;M&quot; | &quot;AD&quot; | &quot;AM&quot; | &quot;MD&quot; | &quot;AMD&quot;</span><br><span class=\"line\">comp    -&gt; &quot;0&quot; | &quot;1&quot; | &quot;-1&quot; | &quot;D&quot; | &quot;A&quot; | &quot;!D&quot; | &quot;!A&quot; | &quot;-D&quot; | &quot;-A&quot;</span><br><span class=\"line\">        |  &quot;D+1&quot; | &quot;A+1&quot; | &quot;D-1&quot; | &quot;A-1&quot; | &quot;D+A&quot; | &quot;D-A&quot; | &quot;A-D&quot; | &quot;D&amp;A&quot; | &quot;D|A&quot; </span><br><span class=\"line\">        |  &quot;M&quot; | &quot;!M&quot; | &quot;-M&quot; | &quot;M+1&quot; | &quot;M-1&quot; | &quot;D+M&quot; | &quot;D-M&quot; | &quot;M-D&quot; | &quot;D&amp;M&quot; | &quot;D|M&quot;</span><br><span class=\"line\">jump    -&gt; &quot;JGT&quot; | &quot;JEG&quot; | &quot;JGE&quot; | &quot;JLT&quot; | &quot;JNE&quot; | &quot;JLE&quot; | &quot;JMP&quot;</span><br><span class=\"line\">num     -&gt; [0-9]+</span><br><span class=\"line\">symbol  -&gt; [a-zA-Z_.$:][a-zA-Z_.$:0-9]+</span><br></pre></td></tr></table></figure>\n\n<p>示例程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Computes R2 &#x3D; max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])</span><br><span class=\"line\"></span><br><span class=\"line\">   @R0</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;D-M            &#x2F;&#x2F; D &#x3D; first number - second number</span><br><span class=\"line\">   @OUTPUT_FIRST</span><br><span class=\"line\">   D;JGT            &#x2F;&#x2F; if D&gt;0 (first is greater) goto output_first</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; second number</span><br><span class=\"line\">   @OUTPUT_D</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; goto output_d</span><br><span class=\"line\">(OUTPUT_FIRST)</span><br><span class=\"line\">   @R0             </span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">(OUTPUT_D)</span><br><span class=\"line\">   @R2</span><br><span class=\"line\">   M&#x3D;D              &#x2F;&#x2F; M[2] &#x3D; D (greatest number)</span><br><span class=\"line\">(INFINITE_LOOP)</span><br><span class=\"line\">   @INFINITE_LOOP</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; infinite loop</span><br></pre></td></tr></table></figure>\n\n"},{"title":"2017年诺贝尔经济学奖","date":"2017-10-16T16:00:00.000Z","excerpt":"本文先简单介绍今年的诺贝尔经济学奖内容，然后是重点，各方的评论。文章最后会说下我自己的观点。","_content":"\n今年诺贝尔经济学奖很奇葩，获奖者的理论否定了经济学的基本假设：人都是自私的。我想这肯定会引来很多的争议，所以就耐心等待着经济学者们的评论，包括持续关注我喜欢的经济学者。过了几天，我跑到各种网上平台去搜索，想集众家之言于此。一来这个话题自己很感兴趣，二来想看看社会对诺贝尔奖的反应。\n\n本文先简单介绍今年的诺贝尔经济学奖内容，然后是重点，各方的评论。文章最后会说下我自己的观点。\n\n## 2017年诺贝尔经济学奖介绍\n\n[今年诺贝尔经济学奖](https://www.nobelprize.org/nobel_prizes/economic-sciences/laureates/2017/press.html)颁给了查理德·塞勒（Richard H. Thaler），表彰其在行为经济学（behavioural economics）做出的贡献。\n\n塞勒将心理学引入到经济选择的分析中，通过探索有限理性、社会偏好、缺乏自制力所产生的结果，揭示了人的这些特征是如何系统地影响个人决策和市场产出的。\n\n有限理性（limited rationality）是说，我们面对选择时，只会根据少量的影响因素，而不是权衡所有因素去做选择。另外一方面，因为讨厌失去，我们会认为某个东西在拥有后的价值比拥有前高。\n\n社会偏好（social preferences）是说，在供不应求的时候，产品价格本应被提高，但是消费者对公平的在乎会阻止公司这么做。而在产品成本增加的时候，消费者的在乎则不会影响公司提高价格。\n\n缺乏自制力（lack of self-control）是说我们都是短视的，把今天看的比明天重要。这也是健康饮食等美好计划失败的原因。因此，塞勒提出了一个词“助推”（nudge），来帮助我们克服短视问题。通过助推，让我们每个人都拥有健康的身体。\n\n## 各方观点\n\n《理查德·塞勒：行为经济学的又一次胜利》（[公众号文章地址](https://mp.weixin.qq.com/s/jvXfTTGeuKMKzkSTKNDY9g)），这篇文章介绍了塞勒的学说，不清楚塞勒的学说的读者可以通过该文了解下，跟我上面的介绍类似，这里就不总结了。\n\n在《奥派经济学家对塞勒获“诺贝尔经济学奖”的观感》（10月9日发布，[中文翻译公众号文章地址](https://mp.weixin.qq.com/s/Hg5ox1uBY-rA_DPdncemnw)，[英文地址](https://mises.org/blog/thaler-wins-nobel-1)）中，奥地利学派经济学家认为应该完全把人的行为学与心理学区分开来，奥派认为人的行为是有目的的（也就是说人的行为可以运用逻辑来推导出来），跟是否理性没有关系。这是奥派在经济学的定义上否定了塞勒的经济学贡献，塞勒的研究跟经济学并没有关系。大卫·戈登（David Gordon）认为塞勒的畅销书《助推》有一个明显的矛盾，设计和实施“助推”的人和其他人一样都是“有限理性”，没有理由相信这些“助推”可以改善社会结果呢？史蒂文·波尔（Steven Poole）认为塞勒的大部分发现并不适用于现实世界，甚或即使是塞勒在实验室发现的所谓“不理性”行为，实际上依然是理性的行为。\n\n在《今年的诺贝尔经济学奖颁给了一个危险的男人》（10月11日发布，[公众号文章地址](https://mp.weixin.qq.com/s/WRcT0UPnuqgPV31OyoLM7Q)）中，作者对整个行为经济学进行的批评，认为行为经济学是自由市场的敌人。比如他说行为经济学从“理性人假设”开始，认为市场存在大量非理性的行为，进而提出进行市场矫正的主张，变成干预主义。关于塞勒的书《助推》，作者认为塞勒提倡的是家长主义，本质上是强制。作者举了个例子：在香烟上印吓人的宣传画，用温柔方式劝告（助推）消费者不要抽烟，问题是商家为什么要自毁生意呢？那是因为有立法，是国家强制规定的结果。\n\n早在2008年，大卫·戈登（David Gordon）在《新“白左”宣言：理查德·塞勒危险的“自由至上家长主义”》（[中文翻译公众号文章地址](https://mp.weixin.qq.com/s/gqGhuGiVS0xZOsVdZ3uMNA)，[英文地址](https://mises.org/library/nudge-improving-decisions-about-health-wealth-and-happiness-richard-h-thaler-and-sunstein)）中就指出了《助推》中的问题，作者认为家长主义和自由主义本身就是矛盾的，而塞勒在《助推》中所捍卫的就是这两者的结合--自由至上的家长主义。塞勒认为自由至上的家长主义是不会对人们的选择造成限制。一来作者认为该书中的很多例子并不代表自由至上的家长主义（比如将器官捐赠的默认选项改成“是”）；其次，做选择的人按照自己的偏好做选择，同样“助推”他们的人也是按照自己的偏好进行助推（塞勒等在书中强调说做选择的人大部分的选择都不是“自由”的选择，不是他们“真正”的想法）；最后一点，作者认为塞勒在书中提出的非理性证据并没有说服力（比如关于购买保修服务的例子，塞勒认为购买保修服务是非理性行为，因为设备发生故障的可能性是非常小的，作者提出不购买保修服务只是塞勒自己的偏好而已，而他的偏好并不代表理性）。\n\n因为诺奖颁布之前我读到了李俊慧老师《经济学讲义》中关于经济学中的自私假设的章节，知道李老师肯定会痛批今年的诺贝尔经济学奖。在10月12日，李老师推了一篇题为《今年（2017年）的诺贝尔经济学奖是近年来最水的一届》（10月12日发布，[公众号文章地址](https://mp.weixin.qq.com/s/6xTetAvTYYCItiHaaHKNrw)）的文章。李老师一来先批评了塞勒对自私假设的否定，认为塞勒提出的有限理性完全没有解释力。因为如果假设人有时自私有时又不自私的话，由这个假设推出的理论就根本不可能被证伪，没有任何解释力。进一步，通过【自私假设是错的】推出【以该假设为基础的经济学是错的】本身就犯了“用非A推出非B”的逻辑错误。另外一点，塞勒以【结果的不正确】来反推【人是不理性的】是不成立的，它们之间并不是因果关系。因为通过理性做出的选择所产生的后果并不需要在现实中是正确的。最有趣的一点事，李老师提到了为什么金融学会比其他领域的经济学跟容易出现非理性主张，其原因是金融学的信息费用更高，同时金融学家也是自私的，所以避重就轻地修改理论而不是去调查现实。（之后李老师还转载了另外两篇批评诺贝尔经济学奖的文章，也很有说服力，这里就不做总结了，请读者自行点击阅读：[《广告中“禀赋效应”的正确解释，附其它精彩评论》](https://mp.weixin.qq.com/s/dJiJhJRX-8qPgqnknZr41Q)，[《这次诺奖昭示着经济学的大踏步衰退，附其它精彩评论》](https://mp.weixin.qq.com/s/71F91Webkde35Arl6vV8AQ)；还有一篇是张是之的文章，观点也类似，一并奉上：[《对理性的误解》](https://mp.weixin.qq.com/s/zNYJfb7lyMr98Cqa5nGROA)）\n\n## 我的观点\n\n先说下我对【网上对今年诺贝尔经济学奖的反应】的观感。网上关于诺贝尔经济学奖的文章主要涉及到这些内容：1. 介绍塞勒的学说；2. 以塞勒的学说解释一些行为；3. 借此卖塞勒的书；4. 警惕塞勒的学说导致的国家干预；5. 从逻辑上分析塞勒的学说漏洞；6. 批评塞勒的《助推》等书。上文提到的那几篇文章，主要是以批评为主，也是我认为最好的几篇文章。从我的搜索结果来看，大部分的文章都是鼓吹夸大塞勒的学说或者以卖书为目的，都不值得看。值得看的是上面我列举的那些文章，批评得有理有据。这次对该事件的持续关注，让我更加全面的了解了各方的观点，各个不同，各有各的侧重点，很是有趣。\n\n至于我对塞勒学说的观点，也是持批评态度。下面是我的浅评（由于才疏学浅，想要更全面更有说服力的评论文章，还请看上面提到的那些文章）：\n\n关于“有限理性”，我认为是塞勒对“理性”概念的理解不清楚。塞勒认为我们在做选择的时候只是根据少量的因素，而不会去衡量所有的因素，进而推出人是有限理性的。不知这进而从哪里来。首先，通过少量因素做选择并不代表不理性；其次，假如衡量所有因素所花费的成本巨大，那么只根据少量因素做选择就是理性的（尤其是根据那些关键性的因素），衡量所有因素做选择反而是不理性的。\n\n由“有限理性”延伸出的“缺乏控制力”，进而提出“助推”的概念，本身也是站不住脚的。就拿抽烟来说，站在塞勒的角度肯定会认为这是一种不理性的行为，需要助推他一下；但是，假如站在某个抽烟者的角度，他会认为我抽烟可以拉近和客户的关系，谈得一笔生意，过上更好的生活，这完全可以抵消这支烟所带来的伤害。这里的核心是不同的人做同一个选择时所处的情况是不同的，对于某个人做的决定是不是理性的，首先需要知道他做选择时所处的情况，即当时的局限条件是怎样的。只是说抽烟是不理性的并没有任何解释力，因为我为什么不可以说不抽烟是不理性的呢？\n","source":"_posts/prize-in-economics-2017.md","raw":"---\ntitle: 2017年诺贝尔经济学奖\ndate: 2017/10/17\ntag:\n- 经济学\ncategory:\n- 评论\nexcerpt: 本文先简单介绍今年的诺贝尔经济学奖内容，然后是重点，各方的评论。文章最后会说下我自己的观点。\n---\n\n今年诺贝尔经济学奖很奇葩，获奖者的理论否定了经济学的基本假设：人都是自私的。我想这肯定会引来很多的争议，所以就耐心等待着经济学者们的评论，包括持续关注我喜欢的经济学者。过了几天，我跑到各种网上平台去搜索，想集众家之言于此。一来这个话题自己很感兴趣，二来想看看社会对诺贝尔奖的反应。\n\n本文先简单介绍今年的诺贝尔经济学奖内容，然后是重点，各方的评论。文章最后会说下我自己的观点。\n\n## 2017年诺贝尔经济学奖介绍\n\n[今年诺贝尔经济学奖](https://www.nobelprize.org/nobel_prizes/economic-sciences/laureates/2017/press.html)颁给了查理德·塞勒（Richard H. Thaler），表彰其在行为经济学（behavioural economics）做出的贡献。\n\n塞勒将心理学引入到经济选择的分析中，通过探索有限理性、社会偏好、缺乏自制力所产生的结果，揭示了人的这些特征是如何系统地影响个人决策和市场产出的。\n\n有限理性（limited rationality）是说，我们面对选择时，只会根据少量的影响因素，而不是权衡所有因素去做选择。另外一方面，因为讨厌失去，我们会认为某个东西在拥有后的价值比拥有前高。\n\n社会偏好（social preferences）是说，在供不应求的时候，产品价格本应被提高，但是消费者对公平的在乎会阻止公司这么做。而在产品成本增加的时候，消费者的在乎则不会影响公司提高价格。\n\n缺乏自制力（lack of self-control）是说我们都是短视的，把今天看的比明天重要。这也是健康饮食等美好计划失败的原因。因此，塞勒提出了一个词“助推”（nudge），来帮助我们克服短视问题。通过助推，让我们每个人都拥有健康的身体。\n\n## 各方观点\n\n《理查德·塞勒：行为经济学的又一次胜利》（[公众号文章地址](https://mp.weixin.qq.com/s/jvXfTTGeuKMKzkSTKNDY9g)），这篇文章介绍了塞勒的学说，不清楚塞勒的学说的读者可以通过该文了解下，跟我上面的介绍类似，这里就不总结了。\n\n在《奥派经济学家对塞勒获“诺贝尔经济学奖”的观感》（10月9日发布，[中文翻译公众号文章地址](https://mp.weixin.qq.com/s/Hg5ox1uBY-rA_DPdncemnw)，[英文地址](https://mises.org/blog/thaler-wins-nobel-1)）中，奥地利学派经济学家认为应该完全把人的行为学与心理学区分开来，奥派认为人的行为是有目的的（也就是说人的行为可以运用逻辑来推导出来），跟是否理性没有关系。这是奥派在经济学的定义上否定了塞勒的经济学贡献，塞勒的研究跟经济学并没有关系。大卫·戈登（David Gordon）认为塞勒的畅销书《助推》有一个明显的矛盾，设计和实施“助推”的人和其他人一样都是“有限理性”，没有理由相信这些“助推”可以改善社会结果呢？史蒂文·波尔（Steven Poole）认为塞勒的大部分发现并不适用于现实世界，甚或即使是塞勒在实验室发现的所谓“不理性”行为，实际上依然是理性的行为。\n\n在《今年的诺贝尔经济学奖颁给了一个危险的男人》（10月11日发布，[公众号文章地址](https://mp.weixin.qq.com/s/WRcT0UPnuqgPV31OyoLM7Q)）中，作者对整个行为经济学进行的批评，认为行为经济学是自由市场的敌人。比如他说行为经济学从“理性人假设”开始，认为市场存在大量非理性的行为，进而提出进行市场矫正的主张，变成干预主义。关于塞勒的书《助推》，作者认为塞勒提倡的是家长主义，本质上是强制。作者举了个例子：在香烟上印吓人的宣传画，用温柔方式劝告（助推）消费者不要抽烟，问题是商家为什么要自毁生意呢？那是因为有立法，是国家强制规定的结果。\n\n早在2008年，大卫·戈登（David Gordon）在《新“白左”宣言：理查德·塞勒危险的“自由至上家长主义”》（[中文翻译公众号文章地址](https://mp.weixin.qq.com/s/gqGhuGiVS0xZOsVdZ3uMNA)，[英文地址](https://mises.org/library/nudge-improving-decisions-about-health-wealth-and-happiness-richard-h-thaler-and-sunstein)）中就指出了《助推》中的问题，作者认为家长主义和自由主义本身就是矛盾的，而塞勒在《助推》中所捍卫的就是这两者的结合--自由至上的家长主义。塞勒认为自由至上的家长主义是不会对人们的选择造成限制。一来作者认为该书中的很多例子并不代表自由至上的家长主义（比如将器官捐赠的默认选项改成“是”）；其次，做选择的人按照自己的偏好做选择，同样“助推”他们的人也是按照自己的偏好进行助推（塞勒等在书中强调说做选择的人大部分的选择都不是“自由”的选择，不是他们“真正”的想法）；最后一点，作者认为塞勒在书中提出的非理性证据并没有说服力（比如关于购买保修服务的例子，塞勒认为购买保修服务是非理性行为，因为设备发生故障的可能性是非常小的，作者提出不购买保修服务只是塞勒自己的偏好而已，而他的偏好并不代表理性）。\n\n因为诺奖颁布之前我读到了李俊慧老师《经济学讲义》中关于经济学中的自私假设的章节，知道李老师肯定会痛批今年的诺贝尔经济学奖。在10月12日，李老师推了一篇题为《今年（2017年）的诺贝尔经济学奖是近年来最水的一届》（10月12日发布，[公众号文章地址](https://mp.weixin.qq.com/s/6xTetAvTYYCItiHaaHKNrw)）的文章。李老师一来先批评了塞勒对自私假设的否定，认为塞勒提出的有限理性完全没有解释力。因为如果假设人有时自私有时又不自私的话，由这个假设推出的理论就根本不可能被证伪，没有任何解释力。进一步，通过【自私假设是错的】推出【以该假设为基础的经济学是错的】本身就犯了“用非A推出非B”的逻辑错误。另外一点，塞勒以【结果的不正确】来反推【人是不理性的】是不成立的，它们之间并不是因果关系。因为通过理性做出的选择所产生的后果并不需要在现实中是正确的。最有趣的一点事，李老师提到了为什么金融学会比其他领域的经济学跟容易出现非理性主张，其原因是金融学的信息费用更高，同时金融学家也是自私的，所以避重就轻地修改理论而不是去调查现实。（之后李老师还转载了另外两篇批评诺贝尔经济学奖的文章，也很有说服力，这里就不做总结了，请读者自行点击阅读：[《广告中“禀赋效应”的正确解释，附其它精彩评论》](https://mp.weixin.qq.com/s/dJiJhJRX-8qPgqnknZr41Q)，[《这次诺奖昭示着经济学的大踏步衰退，附其它精彩评论》](https://mp.weixin.qq.com/s/71F91Webkde35Arl6vV8AQ)；还有一篇是张是之的文章，观点也类似，一并奉上：[《对理性的误解》](https://mp.weixin.qq.com/s/zNYJfb7lyMr98Cqa5nGROA)）\n\n## 我的观点\n\n先说下我对【网上对今年诺贝尔经济学奖的反应】的观感。网上关于诺贝尔经济学奖的文章主要涉及到这些内容：1. 介绍塞勒的学说；2. 以塞勒的学说解释一些行为；3. 借此卖塞勒的书；4. 警惕塞勒的学说导致的国家干预；5. 从逻辑上分析塞勒的学说漏洞；6. 批评塞勒的《助推》等书。上文提到的那几篇文章，主要是以批评为主，也是我认为最好的几篇文章。从我的搜索结果来看，大部分的文章都是鼓吹夸大塞勒的学说或者以卖书为目的，都不值得看。值得看的是上面我列举的那些文章，批评得有理有据。这次对该事件的持续关注，让我更加全面的了解了各方的观点，各个不同，各有各的侧重点，很是有趣。\n\n至于我对塞勒学说的观点，也是持批评态度。下面是我的浅评（由于才疏学浅，想要更全面更有说服力的评论文章，还请看上面提到的那些文章）：\n\n关于“有限理性”，我认为是塞勒对“理性”概念的理解不清楚。塞勒认为我们在做选择的时候只是根据少量的因素，而不会去衡量所有的因素，进而推出人是有限理性的。不知这进而从哪里来。首先，通过少量因素做选择并不代表不理性；其次，假如衡量所有因素所花费的成本巨大，那么只根据少量因素做选择就是理性的（尤其是根据那些关键性的因素），衡量所有因素做选择反而是不理性的。\n\n由“有限理性”延伸出的“缺乏控制力”，进而提出“助推”的概念，本身也是站不住脚的。就拿抽烟来说，站在塞勒的角度肯定会认为这是一种不理性的行为，需要助推他一下；但是，假如站在某个抽烟者的角度，他会认为我抽烟可以拉近和客户的关系，谈得一笔生意，过上更好的生活，这完全可以抵消这支烟所带来的伤害。这里的核心是不同的人做同一个选择时所处的情况是不同的，对于某个人做的决定是不是理性的，首先需要知道他做选择时所处的情况，即当时的局限条件是怎样的。只是说抽烟是不理性的并没有任何解释力，因为我为什么不可以说不抽烟是不理性的呢？\n","slug":"prize-in-economics-2017","published":1,"updated":"2020-11-28T14:27:48.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzu0005rnq7f7c46zbd","content":"<p>今年诺贝尔经济学奖很奇葩，获奖者的理论否定了经济学的基本假设：人都是自私的。我想这肯定会引来很多的争议，所以就耐心等待着经济学者们的评论，包括持续关注我喜欢的经济学者。过了几天，我跑到各种网上平台去搜索，想集众家之言于此。一来这个话题自己很感兴趣，二来想看看社会对诺贝尔奖的反应。</p>\n<p>本文先简单介绍今年的诺贝尔经济学奖内容，然后是重点，各方的评论。文章最后会说下我自己的观点。</p>\n<h2 id=\"2017年诺贝尔经济学奖介绍\"><a href=\"#2017年诺贝尔经济学奖介绍\" class=\"headerlink\" title=\"2017年诺贝尔经济学奖介绍\"></a>2017年诺贝尔经济学奖介绍</h2><p><a href=\"https://www.nobelprize.org/nobel_prizes/economic-sciences/laureates/2017/press.html\">今年诺贝尔经济学奖</a>颁给了查理德·塞勒（Richard H. Thaler），表彰其在行为经济学（behavioural economics）做出的贡献。</p>\n<p>塞勒将心理学引入到经济选择的分析中，通过探索有限理性、社会偏好、缺乏自制力所产生的结果，揭示了人的这些特征是如何系统地影响个人决策和市场产出的。</p>\n<p>有限理性（limited rationality）是说，我们面对选择时，只会根据少量的影响因素，而不是权衡所有因素去做选择。另外一方面，因为讨厌失去，我们会认为某个东西在拥有后的价值比拥有前高。</p>\n<p>社会偏好（social preferences）是说，在供不应求的时候，产品价格本应被提高，但是消费者对公平的在乎会阻止公司这么做。而在产品成本增加的时候，消费者的在乎则不会影响公司提高价格。</p>\n<p>缺乏自制力（lack of self-control）是说我们都是短视的，把今天看的比明天重要。这也是健康饮食等美好计划失败的原因。因此，塞勒提出了一个词“助推”（nudge），来帮助我们克服短视问题。通过助推，让我们每个人都拥有健康的身体。</p>\n<h2 id=\"各方观点\"><a href=\"#各方观点\" class=\"headerlink\" title=\"各方观点\"></a>各方观点</h2><p>《理查德·塞勒：行为经济学的又一次胜利》（<a href=\"https://mp.weixin.qq.com/s/jvXfTTGeuKMKzkSTKNDY9g\">公众号文章地址</a>），这篇文章介绍了塞勒的学说，不清楚塞勒的学说的读者可以通过该文了解下，跟我上面的介绍类似，这里就不总结了。</p>\n<p>在《奥派经济学家对塞勒获“诺贝尔经济学奖”的观感》（10月9日发布，<a href=\"https://mp.weixin.qq.com/s/Hg5ox1uBY-rA_DPdncemnw\">中文翻译公众号文章地址</a>，<a href=\"https://mises.org/blog/thaler-wins-nobel-1\">英文地址</a>）中，奥地利学派经济学家认为应该完全把人的行为学与心理学区分开来，奥派认为人的行为是有目的的（也就是说人的行为可以运用逻辑来推导出来），跟是否理性没有关系。这是奥派在经济学的定义上否定了塞勒的经济学贡献，塞勒的研究跟经济学并没有关系。大卫·戈登（David Gordon）认为塞勒的畅销书《助推》有一个明显的矛盾，设计和实施“助推”的人和其他人一样都是“有限理性”，没有理由相信这些“助推”可以改善社会结果呢？史蒂文·波尔（Steven Poole）认为塞勒的大部分发现并不适用于现实世界，甚或即使是塞勒在实验室发现的所谓“不理性”行为，实际上依然是理性的行为。</p>\n<p>在《今年的诺贝尔经济学奖颁给了一个危险的男人》（10月11日发布，<a href=\"https://mp.weixin.qq.com/s/WRcT0UPnuqgPV31OyoLM7Q\">公众号文章地址</a>）中，作者对整个行为经济学进行的批评，认为行为经济学是自由市场的敌人。比如他说行为经济学从“理性人假设”开始，认为市场存在大量非理性的行为，进而提出进行市场矫正的主张，变成干预主义。关于塞勒的书《助推》，作者认为塞勒提倡的是家长主义，本质上是强制。作者举了个例子：在香烟上印吓人的宣传画，用温柔方式劝告（助推）消费者不要抽烟，问题是商家为什么要自毁生意呢？那是因为有立法，是国家强制规定的结果。</p>\n<p>早在2008年，大卫·戈登（David Gordon）在《新“白左”宣言：理查德·塞勒危险的“自由至上家长主义”》（<a href=\"https://mp.weixin.qq.com/s/gqGhuGiVS0xZOsVdZ3uMNA\">中文翻译公众号文章地址</a>，<a href=\"https://mises.org/library/nudge-improving-decisions-about-health-wealth-and-happiness-richard-h-thaler-and-sunstein\">英文地址</a>）中就指出了《助推》中的问题，作者认为家长主义和自由主义本身就是矛盾的，而塞勒在《助推》中所捍卫的就是这两者的结合–自由至上的家长主义。塞勒认为自由至上的家长主义是不会对人们的选择造成限制。一来作者认为该书中的很多例子并不代表自由至上的家长主义（比如将器官捐赠的默认选项改成“是”）；其次，做选择的人按照自己的偏好做选择，同样“助推”他们的人也是按照自己的偏好进行助推（塞勒等在书中强调说做选择的人大部分的选择都不是“自由”的选择，不是他们“真正”的想法）；最后一点，作者认为塞勒在书中提出的非理性证据并没有说服力（比如关于购买保修服务的例子，塞勒认为购买保修服务是非理性行为，因为设备发生故障的可能性是非常小的，作者提出不购买保修服务只是塞勒自己的偏好而已，而他的偏好并不代表理性）。</p>\n<p>因为诺奖颁布之前我读到了李俊慧老师《经济学讲义》中关于经济学中的自私假设的章节，知道李老师肯定会痛批今年的诺贝尔经济学奖。在10月12日，李老师推了一篇题为《今年（2017年）的诺贝尔经济学奖是近年来最水的一届》（10月12日发布，<a href=\"https://mp.weixin.qq.com/s/6xTetAvTYYCItiHaaHKNrw\">公众号文章地址</a>）的文章。李老师一来先批评了塞勒对自私假设的否定，认为塞勒提出的有限理性完全没有解释力。因为如果假设人有时自私有时又不自私的话，由这个假设推出的理论就根本不可能被证伪，没有任何解释力。进一步，通过【自私假设是错的】推出【以该假设为基础的经济学是错的】本身就犯了“用非A推出非B”的逻辑错误。另外一点，塞勒以【结果的不正确】来反推【人是不理性的】是不成立的，它们之间并不是因果关系。因为通过理性做出的选择所产生的后果并不需要在现实中是正确的。最有趣的一点事，李老师提到了为什么金融学会比其他领域的经济学跟容易出现非理性主张，其原因是金融学的信息费用更高，同时金融学家也是自私的，所以避重就轻地修改理论而不是去调查现实。（之后李老师还转载了另外两篇批评诺贝尔经济学奖的文章，也很有说服力，这里就不做总结了，请读者自行点击阅读：<a href=\"https://mp.weixin.qq.com/s/dJiJhJRX-8qPgqnknZr41Q\">《广告中“禀赋效应”的正确解释，附其它精彩评论》</a>，<a href=\"https://mp.weixin.qq.com/s/71F91Webkde35Arl6vV8AQ\">《这次诺奖昭示着经济学的大踏步衰退，附其它精彩评论》</a>；还有一篇是张是之的文章，观点也类似，一并奉上：<a href=\"https://mp.weixin.qq.com/s/zNYJfb7lyMr98Cqa5nGROA\">《对理性的误解》</a>）</p>\n<h2 id=\"我的观点\"><a href=\"#我的观点\" class=\"headerlink\" title=\"我的观点\"></a>我的观点</h2><p>先说下我对【网上对今年诺贝尔经济学奖的反应】的观感。网上关于诺贝尔经济学奖的文章主要涉及到这些内容：1. 介绍塞勒的学说；2. 以塞勒的学说解释一些行为；3. 借此卖塞勒的书；4. 警惕塞勒的学说导致的国家干预；5. 从逻辑上分析塞勒的学说漏洞；6. 批评塞勒的《助推》等书。上文提到的那几篇文章，主要是以批评为主，也是我认为最好的几篇文章。从我的搜索结果来看，大部分的文章都是鼓吹夸大塞勒的学说或者以卖书为目的，都不值得看。值得看的是上面我列举的那些文章，批评得有理有据。这次对该事件的持续关注，让我更加全面的了解了各方的观点，各个不同，各有各的侧重点，很是有趣。</p>\n<p>至于我对塞勒学说的观点，也是持批评态度。下面是我的浅评（由于才疏学浅，想要更全面更有说服力的评论文章，还请看上面提到的那些文章）：</p>\n<p>关于“有限理性”，我认为是塞勒对“理性”概念的理解不清楚。塞勒认为我们在做选择的时候只是根据少量的因素，而不会去衡量所有的因素，进而推出人是有限理性的。不知这进而从哪里来。首先，通过少量因素做选择并不代表不理性；其次，假如衡量所有因素所花费的成本巨大，那么只根据少量因素做选择就是理性的（尤其是根据那些关键性的因素），衡量所有因素做选择反而是不理性的。</p>\n<p>由“有限理性”延伸出的“缺乏控制力”，进而提出“助推”的概念，本身也是站不住脚的。就拿抽烟来说，站在塞勒的角度肯定会认为这是一种不理性的行为，需要助推他一下；但是，假如站在某个抽烟者的角度，他会认为我抽烟可以拉近和客户的关系，谈得一笔生意，过上更好的生活，这完全可以抵消这支烟所带来的伤害。这里的核心是不同的人做同一个选择时所处的情况是不同的，对于某个人做的决定是不是理性的，首先需要知道他做选择时所处的情况，即当时的局限条件是怎样的。只是说抽烟是不理性的并没有任何解释力，因为我为什么不可以说不抽烟是不理性的呢？</p>\n","site":{"data":{}},"more":"<p>今年诺贝尔经济学奖很奇葩，获奖者的理论否定了经济学的基本假设：人都是自私的。我想这肯定会引来很多的争议，所以就耐心等待着经济学者们的评论，包括持续关注我喜欢的经济学者。过了几天，我跑到各种网上平台去搜索，想集众家之言于此。一来这个话题自己很感兴趣，二来想看看社会对诺贝尔奖的反应。</p>\n<p>本文先简单介绍今年的诺贝尔经济学奖内容，然后是重点，各方的评论。文章最后会说下我自己的观点。</p>\n<h2 id=\"2017年诺贝尔经济学奖介绍\"><a href=\"#2017年诺贝尔经济学奖介绍\" class=\"headerlink\" title=\"2017年诺贝尔经济学奖介绍\"></a>2017年诺贝尔经济学奖介绍</h2><p><a href=\"https://www.nobelprize.org/nobel_prizes/economic-sciences/laureates/2017/press.html\">今年诺贝尔经济学奖</a>颁给了查理德·塞勒（Richard H. Thaler），表彰其在行为经济学（behavioural economics）做出的贡献。</p>\n<p>塞勒将心理学引入到经济选择的分析中，通过探索有限理性、社会偏好、缺乏自制力所产生的结果，揭示了人的这些特征是如何系统地影响个人决策和市场产出的。</p>\n<p>有限理性（limited rationality）是说，我们面对选择时，只会根据少量的影响因素，而不是权衡所有因素去做选择。另外一方面，因为讨厌失去，我们会认为某个东西在拥有后的价值比拥有前高。</p>\n<p>社会偏好（social preferences）是说，在供不应求的时候，产品价格本应被提高，但是消费者对公平的在乎会阻止公司这么做。而在产品成本增加的时候，消费者的在乎则不会影响公司提高价格。</p>\n<p>缺乏自制力（lack of self-control）是说我们都是短视的，把今天看的比明天重要。这也是健康饮食等美好计划失败的原因。因此，塞勒提出了一个词“助推”（nudge），来帮助我们克服短视问题。通过助推，让我们每个人都拥有健康的身体。</p>\n<h2 id=\"各方观点\"><a href=\"#各方观点\" class=\"headerlink\" title=\"各方观点\"></a>各方观点</h2><p>《理查德·塞勒：行为经济学的又一次胜利》（<a href=\"https://mp.weixin.qq.com/s/jvXfTTGeuKMKzkSTKNDY9g\">公众号文章地址</a>），这篇文章介绍了塞勒的学说，不清楚塞勒的学说的读者可以通过该文了解下，跟我上面的介绍类似，这里就不总结了。</p>\n<p>在《奥派经济学家对塞勒获“诺贝尔经济学奖”的观感》（10月9日发布，<a href=\"https://mp.weixin.qq.com/s/Hg5ox1uBY-rA_DPdncemnw\">中文翻译公众号文章地址</a>，<a href=\"https://mises.org/blog/thaler-wins-nobel-1\">英文地址</a>）中，奥地利学派经济学家认为应该完全把人的行为学与心理学区分开来，奥派认为人的行为是有目的的（也就是说人的行为可以运用逻辑来推导出来），跟是否理性没有关系。这是奥派在经济学的定义上否定了塞勒的经济学贡献，塞勒的研究跟经济学并没有关系。大卫·戈登（David Gordon）认为塞勒的畅销书《助推》有一个明显的矛盾，设计和实施“助推”的人和其他人一样都是“有限理性”，没有理由相信这些“助推”可以改善社会结果呢？史蒂文·波尔（Steven Poole）认为塞勒的大部分发现并不适用于现实世界，甚或即使是塞勒在实验室发现的所谓“不理性”行为，实际上依然是理性的行为。</p>\n<p>在《今年的诺贝尔经济学奖颁给了一个危险的男人》（10月11日发布，<a href=\"https://mp.weixin.qq.com/s/WRcT0UPnuqgPV31OyoLM7Q\">公众号文章地址</a>）中，作者对整个行为经济学进行的批评，认为行为经济学是自由市场的敌人。比如他说行为经济学从“理性人假设”开始，认为市场存在大量非理性的行为，进而提出进行市场矫正的主张，变成干预主义。关于塞勒的书《助推》，作者认为塞勒提倡的是家长主义，本质上是强制。作者举了个例子：在香烟上印吓人的宣传画，用温柔方式劝告（助推）消费者不要抽烟，问题是商家为什么要自毁生意呢？那是因为有立法，是国家强制规定的结果。</p>\n<p>早在2008年，大卫·戈登（David Gordon）在《新“白左”宣言：理查德·塞勒危险的“自由至上家长主义”》（<a href=\"https://mp.weixin.qq.com/s/gqGhuGiVS0xZOsVdZ3uMNA\">中文翻译公众号文章地址</a>，<a href=\"https://mises.org/library/nudge-improving-decisions-about-health-wealth-and-happiness-richard-h-thaler-and-sunstein\">英文地址</a>）中就指出了《助推》中的问题，作者认为家长主义和自由主义本身就是矛盾的，而塞勒在《助推》中所捍卫的就是这两者的结合–自由至上的家长主义。塞勒认为自由至上的家长主义是不会对人们的选择造成限制。一来作者认为该书中的很多例子并不代表自由至上的家长主义（比如将器官捐赠的默认选项改成“是”）；其次，做选择的人按照自己的偏好做选择，同样“助推”他们的人也是按照自己的偏好进行助推（塞勒等在书中强调说做选择的人大部分的选择都不是“自由”的选择，不是他们“真正”的想法）；最后一点，作者认为塞勒在书中提出的非理性证据并没有说服力（比如关于购买保修服务的例子，塞勒认为购买保修服务是非理性行为，因为设备发生故障的可能性是非常小的，作者提出不购买保修服务只是塞勒自己的偏好而已，而他的偏好并不代表理性）。</p>\n<p>因为诺奖颁布之前我读到了李俊慧老师《经济学讲义》中关于经济学中的自私假设的章节，知道李老师肯定会痛批今年的诺贝尔经济学奖。在10月12日，李老师推了一篇题为《今年（2017年）的诺贝尔经济学奖是近年来最水的一届》（10月12日发布，<a href=\"https://mp.weixin.qq.com/s/6xTetAvTYYCItiHaaHKNrw\">公众号文章地址</a>）的文章。李老师一来先批评了塞勒对自私假设的否定，认为塞勒提出的有限理性完全没有解释力。因为如果假设人有时自私有时又不自私的话，由这个假设推出的理论就根本不可能被证伪，没有任何解释力。进一步，通过【自私假设是错的】推出【以该假设为基础的经济学是错的】本身就犯了“用非A推出非B”的逻辑错误。另外一点，塞勒以【结果的不正确】来反推【人是不理性的】是不成立的，它们之间并不是因果关系。因为通过理性做出的选择所产生的后果并不需要在现实中是正确的。最有趣的一点事，李老师提到了为什么金融学会比其他领域的经济学跟容易出现非理性主张，其原因是金融学的信息费用更高，同时金融学家也是自私的，所以避重就轻地修改理论而不是去调查现实。（之后李老师还转载了另外两篇批评诺贝尔经济学奖的文章，也很有说服力，这里就不做总结了，请读者自行点击阅读：<a href=\"https://mp.weixin.qq.com/s/dJiJhJRX-8qPgqnknZr41Q\">《广告中“禀赋效应”的正确解释，附其它精彩评论》</a>，<a href=\"https://mp.weixin.qq.com/s/71F91Webkde35Arl6vV8AQ\">《这次诺奖昭示着经济学的大踏步衰退，附其它精彩评论》</a>；还有一篇是张是之的文章，观点也类似，一并奉上：<a href=\"https://mp.weixin.qq.com/s/zNYJfb7lyMr98Cqa5nGROA\">《对理性的误解》</a>）</p>\n<h2 id=\"我的观点\"><a href=\"#我的观点\" class=\"headerlink\" title=\"我的观点\"></a>我的观点</h2><p>先说下我对【网上对今年诺贝尔经济学奖的反应】的观感。网上关于诺贝尔经济学奖的文章主要涉及到这些内容：1. 介绍塞勒的学说；2. 以塞勒的学说解释一些行为；3. 借此卖塞勒的书；4. 警惕塞勒的学说导致的国家干预；5. 从逻辑上分析塞勒的学说漏洞；6. 批评塞勒的《助推》等书。上文提到的那几篇文章，主要是以批评为主，也是我认为最好的几篇文章。从我的搜索结果来看，大部分的文章都是鼓吹夸大塞勒的学说或者以卖书为目的，都不值得看。值得看的是上面我列举的那些文章，批评得有理有据。这次对该事件的持续关注，让我更加全面的了解了各方的观点，各个不同，各有各的侧重点，很是有趣。</p>\n<p>至于我对塞勒学说的观点，也是持批评态度。下面是我的浅评（由于才疏学浅，想要更全面更有说服力的评论文章，还请看上面提到的那些文章）：</p>\n<p>关于“有限理性”，我认为是塞勒对“理性”概念的理解不清楚。塞勒认为我们在做选择的时候只是根据少量的因素，而不会去衡量所有的因素，进而推出人是有限理性的。不知这进而从哪里来。首先，通过少量因素做选择并不代表不理性；其次，假如衡量所有因素所花费的成本巨大，那么只根据少量因素做选择就是理性的（尤其是根据那些关键性的因素），衡量所有因素做选择反而是不理性的。</p>\n<p>由“有限理性”延伸出的“缺乏控制力”，进而提出“助推”的概念，本身也是站不住脚的。就拿抽烟来说，站在塞勒的角度肯定会认为这是一种不理性的行为，需要助推他一下；但是，假如站在某个抽烟者的角度，他会认为我抽烟可以拉近和客户的关系，谈得一笔生意，过上更好的生活，这完全可以抵消这支烟所带来的伤害。这里的核心是不同的人做同一个选择时所处的情况是不同的，对于某个人做的决定是不是理性的，首先需要知道他做选择时所处的情况，即当时的局限条件是怎样的。只是说抽烟是不理性的并没有任何解释力，因为我为什么不可以说不抽烟是不理性的呢？</p>\n"},{"title":"6月7日在OSDT线上技术讨论会上的分享视频","date":"2020-07-02T05:03:13.000Z","excerpt":"按：我在6月7日报名参加了OSDT线上技术讨论会，做了以《QuickJS架构及源代码分析》为主题的直播分享。本文用于记录一下相关的资源，包括分享视频、PPT、代码注释和笔记等。","_content":"\n- 分享视频B站地址：\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=1 （重新录的，时长48分钟）\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=2 （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）\n- 对QuickJS做的一些代码注释、笔记、流程图等资料：https://gitee.com/lhtin/quickjs\n- 分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\n\n","source":"_posts/quickjs.md","raw":"---\ntitle: 6月7日在OSDT线上技术讨论会上的分享视频\ndate: 2020-07-02 13:03:13\ncategories:\n- js\ntags:\n- js\n- quickjs\nexcerpt: 按：我在6月7日报名参加了OSDT线上技术讨论会，做了以《QuickJS架构及源代码分析》为主题的直播分享。本文用于记录一下相关的资源，包括分享视频、PPT、代码注释和笔记等。\n---\n\n- 分享视频B站地址：\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=1 （重新录的，时长48分钟）\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=2 （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）\n- 对QuickJS做的一些代码注释、笔记、流程图等资料：https://gitee.com/lhtin/quickjs\n- 分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\n\n","slug":"quickjs","published":1,"updated":"2020-11-01T09:07:19.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzv0006rnq7bgpbbdir","content":"<ul>\n<li>分享视频B站地址：<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=1\">https://www.bilibili.com/video/BV1bt4y1y79L?p=1</a> （重新录的，时长48分钟）</li>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=2\">https://www.bilibili.com/video/BV1bt4y1y79L?p=2</a> （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）</li>\n</ul>\n</li>\n<li>对QuickJS做的一些代码注释、笔记、流程图等资料：<a href=\"https://gitee.com/lhtin/quickjs\">https://gitee.com/lhtin/quickjs</a></li>\n<li>分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：<a href=\"https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%86%E4%BA%AB%E7%94%A8.pdf\">https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf</a></li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li>分享视频B站地址：<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=1\">https://www.bilibili.com/video/BV1bt4y1y79L?p=1</a> （重新录的，时长48分钟）</li>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=2\">https://www.bilibili.com/video/BV1bt4y1y79L?p=2</a> （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）</li>\n</ul>\n</li>\n<li>对QuickJS做的一些代码注释、笔记、流程图等资料：<a href=\"https://gitee.com/lhtin/quickjs\">https://gitee.com/lhtin/quickjs</a></li>\n<li>分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：<a href=\"https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E5%88%86%E4%BA%AB%E7%94%A8.pdf\">https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf</a></li>\n</ul>\n"},{"title":"日用品的设计（持续更新中）","date":"2018-06-29T16:00:00.000Z","excerpt":"本文用于记录我对日用品设计方面的评价。这个评价是基于我使用这些日用品的感受。给出某日用品设计上的好或者坏的评价时，会一并给出理由。本文会持续更新，增加日用品或者改变某个评价。","_content":"\n注：本文用于记录我对日用品设计方面的评价。这个评价是基于我使用这些日用品的感受。给出某日用品设计上的**好**或者**坏**的评价时，会一并给出理由。本文会持续更新，增加日用品或者改变某个评价。\n\n## 洗手间性别标志（2018-06-30）\n\n### 坏设计\n\n![20180630.1-1.bad](/assets/design/20180630.1-1.bad.jpg)\n\n理由：上图是我今天去参加一个活动时看到的洗手间性别标志（广州康莱德酒店），刚看到时我完全不知道这代表的是男洗手间还是女洗手间，甚至有怀疑过这是否是一个性别标志，于是乎我只能去寻找另一个洗手间标志进行比较，一比较就很容易知道这个代表的是男洗手间，因为女洗手间标志穿着裙子。这个标志看起来很有设计感，实际我觉得用错了地方，标志的作用是准确快速的表达某个意思，可以让人一眼就明白其含义，否则就会带来理解成本。所以我觉得这里直接写“男”和“女”都比这个要好。\n\n## 厨具架（2018-02-18）\n\n### 好设计\n\n![20180218.1-1.good](/assets/design/20180218.1-1.good.jpg)\n\n理由：如图所示，砧板、刀具、筷子、勺子叉子、锅铲、削皮器等都有了自己的位置。基本的厨具都可以放，也方便滤干，而且使用的时候也很方便。\n\n<!--\n购买的京东地址：https://item.jd.com/19425443445.html\n-->\n\n## 菜刀（2017-07-02）\n\n### 坏设计\n\n![20170702.1-1.bad](/assets/design/20170702.1-1.bad.jpg)\n\n理由：这是我在沃尔玛超市买来用于切菜的刀，实际切菜过程中发现非常难用，不能一次性把菜切断。这里的原因是因为刀刃并不是平直的，而是有一个较大的弧度。这导致我要切断菜的时候需要上下转动一下，切菜非常的费力。\n\n### 好设计\n\n![20170702.1-1.good](/assets/design/20170702.1-1.good.jpg)\n\n理由：跟坏的设计相比，这里刀刃的弧度不大，很容易把菜切断。\n\n## 食品包装袋（2016-12-11）\n\n### 坏设计\n\n![20161211.1-1.bad](/assets/design/20161211.1-1.bad.jpg)\n\n![20161211.1-2.bad](/assets/design/20161211.1-2.bad.jpg)\n\n理由：上面两幅图展示了撕开图中包装袋的困难。我尝试撕开一边，发现撕到一小段距离之后就撕不动了，于是我从另一边撕，还是遇到一样的问题。分析发现撕不开的原因是因为撕口那边有食品，不是平整光滑的。这导致的另一个问题是用力过猛会把食物搞出来。解决的方法是在包装的时候不把食物压到撕口的位置，保证撕口处平整光滑。当然也可以设计一种新的撕开方式，比如做一条撕开的引导线，控制撕开走的位置。\n\n## Mac充电器（2016-12-3）\n\n### 坏设计\n\n![20161203.1-1.bad](/assets/design/20161203.1-1.bad.jpg)\n\n理由：Mac充电器含有两种转换接头，上图是其中一种，叫短转换接头，另外一种是长线的，叫长转换接头。而我是在家里和公司使用同一台Mac，由于长转换接头带来带去非常麻烦，我就直接把长转换接头放在公司，下班回家时一般都是只把充电器部分和短转换接头带上。由于嫌麻烦，我通常把短转换接头和充电器分开放到书包里。这样的话，短转换接头太小，单独放很容易弄丢。有时索性我就一直放在家里，这样遇到的问题是有时我需要就麻烦了。我知道，其实我勤劳点，每次拔下长转换接头时顺手把短转换接头插上，就不会有这个问题了，可是，这不还是很麻烦吗！我想的解决方法是把短转换接头内置在充电器上，不能拔下来，然后在做一个长转换接头的插槽。\n\n## 服装店里的衣架（2016-11-20）\n\n### 好设计\n\n![20161120.1-1.good](/assets/design/20161120.1-1.good.jpg)\n\n![20161120.1-2.good](/assets/design/20161120.1-2.good.jpg)\n\n![20161120.1-3.good](/assets/design/20161120.1-3.good.jpg)\n\n理由：上面三幅图中红框框出的部分，想要展示的是，有些服装店里的衣架的钩子部分，夹了一个含有衣服或者裤子尺码信息的小物体，而且不同尺码的颜色也不同（请看第二幅图）。这对于顾客来说，通过查看这个小物体就可以方便地拿到自己想要的尺码，而不需要翻开服装来看，尤其是去拿那些挂在高位置的服装时。不过，第三幅图中的小物体有两个缺点。第一是容易掉，因为缺口位置没有为防止脱落而做一个钩子。第二是它是一个长方体，但是四周只有三边有尺码信息，缺口那一边是没有的，这样如果你正好正对着缺口的位置，是看不到尺码信息的，而圆形的视角即使也只有三个位置有尺码信息，但是由于它是圆形，并且分三等份设置尺码信息，所以没有哪个角度是看不到尺码信息的。\n\n## 瓶装酱油、醋、料酒等的盖子（2016-11-19）\n\n### 坏设计\n\n![20161119.2-1.bad](/assets/design/20161119.2-1.bad.jpg)\n\n![20161119.2-2.bad](/assets/design/20161119.2-2.bad.jpg)\n\n理由：炒菜时添加酱油等调料是一件比较紧急的事情，但是上面两幅图中的盖子开起来都比较的麻烦（第一幅图需要把盖子抠出来，薄薄的盖子是很难抠的，第二幅图需要拧很多下）。另外不好的一点是盖子和瓶子是分离的，也就是说使用时分离的盖子还得找地方放，这会导致盖子很容易搞丢。\n\n### 好设计\n\n![20161119.2-1.good](/assets/design/20161119.2-1.good.jpg)\n\n理由：上图中的盖子没有那些问题，因为打开盖子时只需要往上用一下力，同时盖子和瓶子没有分离，盖的时候也只需向下按盖子就可以了。\n\n\n## 瓶装洗发水或沐浴露的盖子（2016-11-19）\n\n### 坏设计\n\n![20161119.1-1.bad](/assets/design/20161119.1-1.bad.jpg)\n\n理由：上图中的日用品是沐浴露。使用的方式一般是先冲湿全身，然后拿起它，掰开盖子，倒过来挤出沐浴露，放好它，将挤出来的沐浴露涂满全身。带来的问题是，首先，在洗澡这样的场景中，获取沐浴露的方式一定要既快速又方便。但是如果是图中的这种盖子，获得沐浴露的方式很繁琐（需要拿在手上，掰开盖子，倒着挤）。试想，假如此时你的手很滑（手上沾有洗发水）、你闭着眼睛（为了防止头上涂的洗发水进入眼睛）、或是在冬天洗澡。这样的使用方式都会带来麻烦是，瓶子掉了、挤完后不知道放哪里、冷到了。\n\n### 好设计\n\n![20161119.1-1.good](/assets/design/20161119.1-1.good.jpg)\n\n理由：对着上面坏设计来看，上图中的沐浴露盖子没有那些问题。它使用时不需要拿起来、不需要掰开盖子、不需要倒过来，只需要向下一挤就可以获得里面的沐浴露了。\n","source":"_posts/the-design-of-everyday-things.md","raw":"---\ntitle: 日用品的设计（持续更新中）\ndate: 2018/06/30\ncategories:\n- note\ntags:\n- design\nexcerpt: 本文用于记录我对日用品设计方面的评价。这个评价是基于我使用这些日用品的感受。给出某日用品设计上的好或者坏的评价时，会一并给出理由。本文会持续更新，增加日用品或者改变某个评价。\n---\n\n注：本文用于记录我对日用品设计方面的评价。这个评价是基于我使用这些日用品的感受。给出某日用品设计上的**好**或者**坏**的评价时，会一并给出理由。本文会持续更新，增加日用品或者改变某个评价。\n\n## 洗手间性别标志（2018-06-30）\n\n### 坏设计\n\n![20180630.1-1.bad](/assets/design/20180630.1-1.bad.jpg)\n\n理由：上图是我今天去参加一个活动时看到的洗手间性别标志（广州康莱德酒店），刚看到时我完全不知道这代表的是男洗手间还是女洗手间，甚至有怀疑过这是否是一个性别标志，于是乎我只能去寻找另一个洗手间标志进行比较，一比较就很容易知道这个代表的是男洗手间，因为女洗手间标志穿着裙子。这个标志看起来很有设计感，实际我觉得用错了地方，标志的作用是准确快速的表达某个意思，可以让人一眼就明白其含义，否则就会带来理解成本。所以我觉得这里直接写“男”和“女”都比这个要好。\n\n## 厨具架（2018-02-18）\n\n### 好设计\n\n![20180218.1-1.good](/assets/design/20180218.1-1.good.jpg)\n\n理由：如图所示，砧板、刀具、筷子、勺子叉子、锅铲、削皮器等都有了自己的位置。基本的厨具都可以放，也方便滤干，而且使用的时候也很方便。\n\n<!--\n购买的京东地址：https://item.jd.com/19425443445.html\n-->\n\n## 菜刀（2017-07-02）\n\n### 坏设计\n\n![20170702.1-1.bad](/assets/design/20170702.1-1.bad.jpg)\n\n理由：这是我在沃尔玛超市买来用于切菜的刀，实际切菜过程中发现非常难用，不能一次性把菜切断。这里的原因是因为刀刃并不是平直的，而是有一个较大的弧度。这导致我要切断菜的时候需要上下转动一下，切菜非常的费力。\n\n### 好设计\n\n![20170702.1-1.good](/assets/design/20170702.1-1.good.jpg)\n\n理由：跟坏的设计相比，这里刀刃的弧度不大，很容易把菜切断。\n\n## 食品包装袋（2016-12-11）\n\n### 坏设计\n\n![20161211.1-1.bad](/assets/design/20161211.1-1.bad.jpg)\n\n![20161211.1-2.bad](/assets/design/20161211.1-2.bad.jpg)\n\n理由：上面两幅图展示了撕开图中包装袋的困难。我尝试撕开一边，发现撕到一小段距离之后就撕不动了，于是我从另一边撕，还是遇到一样的问题。分析发现撕不开的原因是因为撕口那边有食品，不是平整光滑的。这导致的另一个问题是用力过猛会把食物搞出来。解决的方法是在包装的时候不把食物压到撕口的位置，保证撕口处平整光滑。当然也可以设计一种新的撕开方式，比如做一条撕开的引导线，控制撕开走的位置。\n\n## Mac充电器（2016-12-3）\n\n### 坏设计\n\n![20161203.1-1.bad](/assets/design/20161203.1-1.bad.jpg)\n\n理由：Mac充电器含有两种转换接头，上图是其中一种，叫短转换接头，另外一种是长线的，叫长转换接头。而我是在家里和公司使用同一台Mac，由于长转换接头带来带去非常麻烦，我就直接把长转换接头放在公司，下班回家时一般都是只把充电器部分和短转换接头带上。由于嫌麻烦，我通常把短转换接头和充电器分开放到书包里。这样的话，短转换接头太小，单独放很容易弄丢。有时索性我就一直放在家里，这样遇到的问题是有时我需要就麻烦了。我知道，其实我勤劳点，每次拔下长转换接头时顺手把短转换接头插上，就不会有这个问题了，可是，这不还是很麻烦吗！我想的解决方法是把短转换接头内置在充电器上，不能拔下来，然后在做一个长转换接头的插槽。\n\n## 服装店里的衣架（2016-11-20）\n\n### 好设计\n\n![20161120.1-1.good](/assets/design/20161120.1-1.good.jpg)\n\n![20161120.1-2.good](/assets/design/20161120.1-2.good.jpg)\n\n![20161120.1-3.good](/assets/design/20161120.1-3.good.jpg)\n\n理由：上面三幅图中红框框出的部分，想要展示的是，有些服装店里的衣架的钩子部分，夹了一个含有衣服或者裤子尺码信息的小物体，而且不同尺码的颜色也不同（请看第二幅图）。这对于顾客来说，通过查看这个小物体就可以方便地拿到自己想要的尺码，而不需要翻开服装来看，尤其是去拿那些挂在高位置的服装时。不过，第三幅图中的小物体有两个缺点。第一是容易掉，因为缺口位置没有为防止脱落而做一个钩子。第二是它是一个长方体，但是四周只有三边有尺码信息，缺口那一边是没有的，这样如果你正好正对着缺口的位置，是看不到尺码信息的，而圆形的视角即使也只有三个位置有尺码信息，但是由于它是圆形，并且分三等份设置尺码信息，所以没有哪个角度是看不到尺码信息的。\n\n## 瓶装酱油、醋、料酒等的盖子（2016-11-19）\n\n### 坏设计\n\n![20161119.2-1.bad](/assets/design/20161119.2-1.bad.jpg)\n\n![20161119.2-2.bad](/assets/design/20161119.2-2.bad.jpg)\n\n理由：炒菜时添加酱油等调料是一件比较紧急的事情，但是上面两幅图中的盖子开起来都比较的麻烦（第一幅图需要把盖子抠出来，薄薄的盖子是很难抠的，第二幅图需要拧很多下）。另外不好的一点是盖子和瓶子是分离的，也就是说使用时分离的盖子还得找地方放，这会导致盖子很容易搞丢。\n\n### 好设计\n\n![20161119.2-1.good](/assets/design/20161119.2-1.good.jpg)\n\n理由：上图中的盖子没有那些问题，因为打开盖子时只需要往上用一下力，同时盖子和瓶子没有分离，盖的时候也只需向下按盖子就可以了。\n\n\n## 瓶装洗发水或沐浴露的盖子（2016-11-19）\n\n### 坏设计\n\n![20161119.1-1.bad](/assets/design/20161119.1-1.bad.jpg)\n\n理由：上图中的日用品是沐浴露。使用的方式一般是先冲湿全身，然后拿起它，掰开盖子，倒过来挤出沐浴露，放好它，将挤出来的沐浴露涂满全身。带来的问题是，首先，在洗澡这样的场景中，获取沐浴露的方式一定要既快速又方便。但是如果是图中的这种盖子，获得沐浴露的方式很繁琐（需要拿在手上，掰开盖子，倒着挤）。试想，假如此时你的手很滑（手上沾有洗发水）、你闭着眼睛（为了防止头上涂的洗发水进入眼睛）、或是在冬天洗澡。这样的使用方式都会带来麻烦是，瓶子掉了、挤完后不知道放哪里、冷到了。\n\n### 好设计\n\n![20161119.1-1.good](/assets/design/20161119.1-1.good.jpg)\n\n理由：对着上面坏设计来看，上图中的沐浴露盖子没有那些问题。它使用时不需要拿起来、不需要掰开盖子、不需要倒过来，只需要向下一挤就可以获得里面的沐浴露了。\n","slug":"the-design-of-everyday-things","published":1,"updated":"2020-11-28T14:38:36.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzw000arnq732oldox6","content":"<p>注：本文用于记录我对日用品设计方面的评价。这个评价是基于我使用这些日用品的感受。给出某日用品设计上的<strong>好</strong>或者<strong>坏</strong>的评价时，会一并给出理由。本文会持续更新，增加日用品或者改变某个评价。</p>\n<h2 id=\"洗手间性别标志（2018-06-30）\"><a href=\"#洗手间性别标志（2018-06-30）\" class=\"headerlink\" title=\"洗手间性别标志（2018-06-30）\"></a>洗手间性别标志（2018-06-30）</h2><h3 id=\"坏设计\"><a href=\"#坏设计\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20180630.1-1.bad.jpg\" alt=\"20180630.1-1.bad\"></p>\n<p>理由：上图是我今天去参加一个活动时看到的洗手间性别标志（广州康莱德酒店），刚看到时我完全不知道这代表的是男洗手间还是女洗手间，甚至有怀疑过这是否是一个性别标志，于是乎我只能去寻找另一个洗手间标志进行比较，一比较就很容易知道这个代表的是男洗手间，因为女洗手间标志穿着裙子。这个标志看起来很有设计感，实际我觉得用错了地方，标志的作用是准确快速的表达某个意思，可以让人一眼就明白其含义，否则就会带来理解成本。所以我觉得这里直接写“男”和“女”都比这个要好。</p>\n<h2 id=\"厨具架（2018-02-18）\"><a href=\"#厨具架（2018-02-18）\" class=\"headerlink\" title=\"厨具架（2018-02-18）\"></a>厨具架（2018-02-18）</h2><h3 id=\"好设计\"><a href=\"#好设计\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20180218.1-1.good.jpg\" alt=\"20180218.1-1.good\"></p>\n<p>理由：如图所示，砧板、刀具、筷子、勺子叉子、锅铲、削皮器等都有了自己的位置。基本的厨具都可以放，也方便滤干，而且使用的时候也很方便。</p>\n<!--\n购买的京东地址：https://item.jd.com/19425443445.html\n-->\n\n<h2 id=\"菜刀（2017-07-02）\"><a href=\"#菜刀（2017-07-02）\" class=\"headerlink\" title=\"菜刀（2017-07-02）\"></a>菜刀（2017-07-02）</h2><h3 id=\"坏设计-1\"><a href=\"#坏设计-1\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20170702.1-1.bad.jpg\" alt=\"20170702.1-1.bad\"></p>\n<p>理由：这是我在沃尔玛超市买来用于切菜的刀，实际切菜过程中发现非常难用，不能一次性把菜切断。这里的原因是因为刀刃并不是平直的，而是有一个较大的弧度。这导致我要切断菜的时候需要上下转动一下，切菜非常的费力。</p>\n<h3 id=\"好设计-1\"><a href=\"#好设计-1\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20170702.1-1.good.jpg\" alt=\"20170702.1-1.good\"></p>\n<p>理由：跟坏的设计相比，这里刀刃的弧度不大，很容易把菜切断。</p>\n<h2 id=\"食品包装袋（2016-12-11）\"><a href=\"#食品包装袋（2016-12-11）\" class=\"headerlink\" title=\"食品包装袋（2016-12-11）\"></a>食品包装袋（2016-12-11）</h2><h3 id=\"坏设计-2\"><a href=\"#坏设计-2\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161211.1-1.bad.jpg\" alt=\"20161211.1-1.bad\"></p>\n<p><img src=\"/assets/design/20161211.1-2.bad.jpg\" alt=\"20161211.1-2.bad\"></p>\n<p>理由：上面两幅图展示了撕开图中包装袋的困难。我尝试撕开一边，发现撕到一小段距离之后就撕不动了，于是我从另一边撕，还是遇到一样的问题。分析发现撕不开的原因是因为撕口那边有食品，不是平整光滑的。这导致的另一个问题是用力过猛会把食物搞出来。解决的方法是在包装的时候不把食物压到撕口的位置，保证撕口处平整光滑。当然也可以设计一种新的撕开方式，比如做一条撕开的引导线，控制撕开走的位置。</p>\n<h2 id=\"Mac充电器（2016-12-3）\"><a href=\"#Mac充电器（2016-12-3）\" class=\"headerlink\" title=\"Mac充电器（2016-12-3）\"></a>Mac充电器（2016-12-3）</h2><h3 id=\"坏设计-3\"><a href=\"#坏设计-3\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161203.1-1.bad.jpg\" alt=\"20161203.1-1.bad\"></p>\n<p>理由：Mac充电器含有两种转换接头，上图是其中一种，叫短转换接头，另外一种是长线的，叫长转换接头。而我是在家里和公司使用同一台Mac，由于长转换接头带来带去非常麻烦，我就直接把长转换接头放在公司，下班回家时一般都是只把充电器部分和短转换接头带上。由于嫌麻烦，我通常把短转换接头和充电器分开放到书包里。这样的话，短转换接头太小，单独放很容易弄丢。有时索性我就一直放在家里，这样遇到的问题是有时我需要就麻烦了。我知道，其实我勤劳点，每次拔下长转换接头时顺手把短转换接头插上，就不会有这个问题了，可是，这不还是很麻烦吗！我想的解决方法是把短转换接头内置在充电器上，不能拔下来，然后在做一个长转换接头的插槽。</p>\n<h2 id=\"服装店里的衣架（2016-11-20）\"><a href=\"#服装店里的衣架（2016-11-20）\" class=\"headerlink\" title=\"服装店里的衣架（2016-11-20）\"></a>服装店里的衣架（2016-11-20）</h2><h3 id=\"好设计-2\"><a href=\"#好设计-2\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20161120.1-1.good.jpg\" alt=\"20161120.1-1.good\"></p>\n<p><img src=\"/assets/design/20161120.1-2.good.jpg\" alt=\"20161120.1-2.good\"></p>\n<p><img src=\"/assets/design/20161120.1-3.good.jpg\" alt=\"20161120.1-3.good\"></p>\n<p>理由：上面三幅图中红框框出的部分，想要展示的是，有些服装店里的衣架的钩子部分，夹了一个含有衣服或者裤子尺码信息的小物体，而且不同尺码的颜色也不同（请看第二幅图）。这对于顾客来说，通过查看这个小物体就可以方便地拿到自己想要的尺码，而不需要翻开服装来看，尤其是去拿那些挂在高位置的服装时。不过，第三幅图中的小物体有两个缺点。第一是容易掉，因为缺口位置没有为防止脱落而做一个钩子。第二是它是一个长方体，但是四周只有三边有尺码信息，缺口那一边是没有的，这样如果你正好正对着缺口的位置，是看不到尺码信息的，而圆形的视角即使也只有三个位置有尺码信息，但是由于它是圆形，并且分三等份设置尺码信息，所以没有哪个角度是看不到尺码信息的。</p>\n<h2 id=\"瓶装酱油、醋、料酒等的盖子（2016-11-19）\"><a href=\"#瓶装酱油、醋、料酒等的盖子（2016-11-19）\" class=\"headerlink\" title=\"瓶装酱油、醋、料酒等的盖子（2016-11-19）\"></a>瓶装酱油、醋、料酒等的盖子（2016-11-19）</h2><h3 id=\"坏设计-4\"><a href=\"#坏设计-4\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161119.2-1.bad.jpg\" alt=\"20161119.2-1.bad\"></p>\n<p><img src=\"/assets/design/20161119.2-2.bad.jpg\" alt=\"20161119.2-2.bad\"></p>\n<p>理由：炒菜时添加酱油等调料是一件比较紧急的事情，但是上面两幅图中的盖子开起来都比较的麻烦（第一幅图需要把盖子抠出来，薄薄的盖子是很难抠的，第二幅图需要拧很多下）。另外不好的一点是盖子和瓶子是分离的，也就是说使用时分离的盖子还得找地方放，这会导致盖子很容易搞丢。</p>\n<h3 id=\"好设计-3\"><a href=\"#好设计-3\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20161119.2-1.good.jpg\" alt=\"20161119.2-1.good\"></p>\n<p>理由：上图中的盖子没有那些问题，因为打开盖子时只需要往上用一下力，同时盖子和瓶子没有分离，盖的时候也只需向下按盖子就可以了。</p>\n<h2 id=\"瓶装洗发水或沐浴露的盖子（2016-11-19）\"><a href=\"#瓶装洗发水或沐浴露的盖子（2016-11-19）\" class=\"headerlink\" title=\"瓶装洗发水或沐浴露的盖子（2016-11-19）\"></a>瓶装洗发水或沐浴露的盖子（2016-11-19）</h2><h3 id=\"坏设计-5\"><a href=\"#坏设计-5\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161119.1-1.bad.jpg\" alt=\"20161119.1-1.bad\"></p>\n<p>理由：上图中的日用品是沐浴露。使用的方式一般是先冲湿全身，然后拿起它，掰开盖子，倒过来挤出沐浴露，放好它，将挤出来的沐浴露涂满全身。带来的问题是，首先，在洗澡这样的场景中，获取沐浴露的方式一定要既快速又方便。但是如果是图中的这种盖子，获得沐浴露的方式很繁琐（需要拿在手上，掰开盖子，倒着挤）。试想，假如此时你的手很滑（手上沾有洗发水）、你闭着眼睛（为了防止头上涂的洗发水进入眼睛）、或是在冬天洗澡。这样的使用方式都会带来麻烦是，瓶子掉了、挤完后不知道放哪里、冷到了。</p>\n<h3 id=\"好设计-4\"><a href=\"#好设计-4\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20161119.1-1.good.jpg\" alt=\"20161119.1-1.good\"></p>\n<p>理由：对着上面坏设计来看，上图中的沐浴露盖子没有那些问题。它使用时不需要拿起来、不需要掰开盖子、不需要倒过来，只需要向下一挤就可以获得里面的沐浴露了。</p>\n","site":{"data":{}},"more":"<p>注：本文用于记录我对日用品设计方面的评价。这个评价是基于我使用这些日用品的感受。给出某日用品设计上的<strong>好</strong>或者<strong>坏</strong>的评价时，会一并给出理由。本文会持续更新，增加日用品或者改变某个评价。</p>\n<h2 id=\"洗手间性别标志（2018-06-30）\"><a href=\"#洗手间性别标志（2018-06-30）\" class=\"headerlink\" title=\"洗手间性别标志（2018-06-30）\"></a>洗手间性别标志（2018-06-30）</h2><h3 id=\"坏设计\"><a href=\"#坏设计\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20180630.1-1.bad.jpg\" alt=\"20180630.1-1.bad\"></p>\n<p>理由：上图是我今天去参加一个活动时看到的洗手间性别标志（广州康莱德酒店），刚看到时我完全不知道这代表的是男洗手间还是女洗手间，甚至有怀疑过这是否是一个性别标志，于是乎我只能去寻找另一个洗手间标志进行比较，一比较就很容易知道这个代表的是男洗手间，因为女洗手间标志穿着裙子。这个标志看起来很有设计感，实际我觉得用错了地方，标志的作用是准确快速的表达某个意思，可以让人一眼就明白其含义，否则就会带来理解成本。所以我觉得这里直接写“男”和“女”都比这个要好。</p>\n<h2 id=\"厨具架（2018-02-18）\"><a href=\"#厨具架（2018-02-18）\" class=\"headerlink\" title=\"厨具架（2018-02-18）\"></a>厨具架（2018-02-18）</h2><h3 id=\"好设计\"><a href=\"#好设计\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20180218.1-1.good.jpg\" alt=\"20180218.1-1.good\"></p>\n<p>理由：如图所示，砧板、刀具、筷子、勺子叉子、锅铲、削皮器等都有了自己的位置。基本的厨具都可以放，也方便滤干，而且使用的时候也很方便。</p>\n<!--\n购买的京东地址：https://item.jd.com/19425443445.html\n-->\n\n<h2 id=\"菜刀（2017-07-02）\"><a href=\"#菜刀（2017-07-02）\" class=\"headerlink\" title=\"菜刀（2017-07-02）\"></a>菜刀（2017-07-02）</h2><h3 id=\"坏设计-1\"><a href=\"#坏设计-1\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20170702.1-1.bad.jpg\" alt=\"20170702.1-1.bad\"></p>\n<p>理由：这是我在沃尔玛超市买来用于切菜的刀，实际切菜过程中发现非常难用，不能一次性把菜切断。这里的原因是因为刀刃并不是平直的，而是有一个较大的弧度。这导致我要切断菜的时候需要上下转动一下，切菜非常的费力。</p>\n<h3 id=\"好设计-1\"><a href=\"#好设计-1\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20170702.1-1.good.jpg\" alt=\"20170702.1-1.good\"></p>\n<p>理由：跟坏的设计相比，这里刀刃的弧度不大，很容易把菜切断。</p>\n<h2 id=\"食品包装袋（2016-12-11）\"><a href=\"#食品包装袋（2016-12-11）\" class=\"headerlink\" title=\"食品包装袋（2016-12-11）\"></a>食品包装袋（2016-12-11）</h2><h3 id=\"坏设计-2\"><a href=\"#坏设计-2\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161211.1-1.bad.jpg\" alt=\"20161211.1-1.bad\"></p>\n<p><img src=\"/assets/design/20161211.1-2.bad.jpg\" alt=\"20161211.1-2.bad\"></p>\n<p>理由：上面两幅图展示了撕开图中包装袋的困难。我尝试撕开一边，发现撕到一小段距离之后就撕不动了，于是我从另一边撕，还是遇到一样的问题。分析发现撕不开的原因是因为撕口那边有食品，不是平整光滑的。这导致的另一个问题是用力过猛会把食物搞出来。解决的方法是在包装的时候不把食物压到撕口的位置，保证撕口处平整光滑。当然也可以设计一种新的撕开方式，比如做一条撕开的引导线，控制撕开走的位置。</p>\n<h2 id=\"Mac充电器（2016-12-3）\"><a href=\"#Mac充电器（2016-12-3）\" class=\"headerlink\" title=\"Mac充电器（2016-12-3）\"></a>Mac充电器（2016-12-3）</h2><h3 id=\"坏设计-3\"><a href=\"#坏设计-3\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161203.1-1.bad.jpg\" alt=\"20161203.1-1.bad\"></p>\n<p>理由：Mac充电器含有两种转换接头，上图是其中一种，叫短转换接头，另外一种是长线的，叫长转换接头。而我是在家里和公司使用同一台Mac，由于长转换接头带来带去非常麻烦，我就直接把长转换接头放在公司，下班回家时一般都是只把充电器部分和短转换接头带上。由于嫌麻烦，我通常把短转换接头和充电器分开放到书包里。这样的话，短转换接头太小，单独放很容易弄丢。有时索性我就一直放在家里，这样遇到的问题是有时我需要就麻烦了。我知道，其实我勤劳点，每次拔下长转换接头时顺手把短转换接头插上，就不会有这个问题了，可是，这不还是很麻烦吗！我想的解决方法是把短转换接头内置在充电器上，不能拔下来，然后在做一个长转换接头的插槽。</p>\n<h2 id=\"服装店里的衣架（2016-11-20）\"><a href=\"#服装店里的衣架（2016-11-20）\" class=\"headerlink\" title=\"服装店里的衣架（2016-11-20）\"></a>服装店里的衣架（2016-11-20）</h2><h3 id=\"好设计-2\"><a href=\"#好设计-2\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20161120.1-1.good.jpg\" alt=\"20161120.1-1.good\"></p>\n<p><img src=\"/assets/design/20161120.1-2.good.jpg\" alt=\"20161120.1-2.good\"></p>\n<p><img src=\"/assets/design/20161120.1-3.good.jpg\" alt=\"20161120.1-3.good\"></p>\n<p>理由：上面三幅图中红框框出的部分，想要展示的是，有些服装店里的衣架的钩子部分，夹了一个含有衣服或者裤子尺码信息的小物体，而且不同尺码的颜色也不同（请看第二幅图）。这对于顾客来说，通过查看这个小物体就可以方便地拿到自己想要的尺码，而不需要翻开服装来看，尤其是去拿那些挂在高位置的服装时。不过，第三幅图中的小物体有两个缺点。第一是容易掉，因为缺口位置没有为防止脱落而做一个钩子。第二是它是一个长方体，但是四周只有三边有尺码信息，缺口那一边是没有的，这样如果你正好正对着缺口的位置，是看不到尺码信息的，而圆形的视角即使也只有三个位置有尺码信息，但是由于它是圆形，并且分三等份设置尺码信息，所以没有哪个角度是看不到尺码信息的。</p>\n<h2 id=\"瓶装酱油、醋、料酒等的盖子（2016-11-19）\"><a href=\"#瓶装酱油、醋、料酒等的盖子（2016-11-19）\" class=\"headerlink\" title=\"瓶装酱油、醋、料酒等的盖子（2016-11-19）\"></a>瓶装酱油、醋、料酒等的盖子（2016-11-19）</h2><h3 id=\"坏设计-4\"><a href=\"#坏设计-4\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161119.2-1.bad.jpg\" alt=\"20161119.2-1.bad\"></p>\n<p><img src=\"/assets/design/20161119.2-2.bad.jpg\" alt=\"20161119.2-2.bad\"></p>\n<p>理由：炒菜时添加酱油等调料是一件比较紧急的事情，但是上面两幅图中的盖子开起来都比较的麻烦（第一幅图需要把盖子抠出来，薄薄的盖子是很难抠的，第二幅图需要拧很多下）。另外不好的一点是盖子和瓶子是分离的，也就是说使用时分离的盖子还得找地方放，这会导致盖子很容易搞丢。</p>\n<h3 id=\"好设计-3\"><a href=\"#好设计-3\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20161119.2-1.good.jpg\" alt=\"20161119.2-1.good\"></p>\n<p>理由：上图中的盖子没有那些问题，因为打开盖子时只需要往上用一下力，同时盖子和瓶子没有分离，盖的时候也只需向下按盖子就可以了。</p>\n<h2 id=\"瓶装洗发水或沐浴露的盖子（2016-11-19）\"><a href=\"#瓶装洗发水或沐浴露的盖子（2016-11-19）\" class=\"headerlink\" title=\"瓶装洗发水或沐浴露的盖子（2016-11-19）\"></a>瓶装洗发水或沐浴露的盖子（2016-11-19）</h2><h3 id=\"坏设计-5\"><a href=\"#坏设计-5\" class=\"headerlink\" title=\"坏设计\"></a>坏设计</h3><p><img src=\"/assets/design/20161119.1-1.bad.jpg\" alt=\"20161119.1-1.bad\"></p>\n<p>理由：上图中的日用品是沐浴露。使用的方式一般是先冲湿全身，然后拿起它，掰开盖子，倒过来挤出沐浴露，放好它，将挤出来的沐浴露涂满全身。带来的问题是，首先，在洗澡这样的场景中，获取沐浴露的方式一定要既快速又方便。但是如果是图中的这种盖子，获得沐浴露的方式很繁琐（需要拿在手上，掰开盖子，倒着挤）。试想，假如此时你的手很滑（手上沾有洗发水）、你闭着眼睛（为了防止头上涂的洗发水进入眼睛）、或是在冬天洗澡。这样的使用方式都会带来麻烦是，瓶子掉了、挤完后不知道放哪里、冷到了。</p>\n<h3 id=\"好设计-4\"><a href=\"#好设计-4\" class=\"headerlink\" title=\"好设计\"></a>好设计</h3><p><img src=\"/assets/design/20161119.1-1.good.jpg\" alt=\"20161119.1-1.good\"></p>\n<p>理由：对着上面坏设计来看，上图中的沐浴露盖子没有那些问题。它使用时不需要拿起来、不需要掰开盖子、不需要倒过来，只需要向下一挤就可以获得里面的沐浴露了。</p>\n"},{"title":"Ukulele学习笔记","date":"2018-11-03T16:00:00.000Z","excerpt":"Ukulele学习笔记","_content":"\n## 术语\n\n- tempo：音乐的速度，比如120bpm指每分钟120拍。\n- bpm：beats per minute\n\n## 学习日记\n\n### 2018-11-04\n\n最近一段时间学习《强尼课》的7、8、9、10课，练习多指法（二指法和三指法）、槌音和勾音。强尼老师强调指甲的修建对音色影响非常大，于是我也重视起来。首先是买了抛光指甲的用具，保留右手拇指、食指和中指指甲，不过目前使用最多的还是拇指，偶尔一些谱子会用到食指，中指基本还没用上。然后生活中做家务时会刻意换成左手来做，保护右手的指甲。\n\n这段时间弹的最多的是电影毕业生主题曲《寂静之声》指弹曲，还有今天练习的《月亮代表我的心》，很喜欢这两首曲子，谱子如下：\n\n![寂静之声](/assets/tabs/寂静之声.jpg)\n![月亮代表我的心](/assets/tabs/月亮代表我的心.jpg)\n\n### 2018-08-25\n\n好久没有记录了，其实这段时间也在陆陆续续学着尤克里里。今天记录下我在学习的一个课程。\n\n前段时间因为强尼小子教学《Hula Girl》而发现了他的《强尼小子基础指弹网络课程》（[课程地址](https://mp.weixin.qq.com/s/7TTP-VcoEiDOp50NSGYk3A)），思考了几天决定买下来，花了800人民币。他这个课有个不太好的地方是无法在Mac上观看，而且只能在一台机器上看。不过这个不能阻挡我热爱学习的心呀，把妹子用的Windows电脑拿来观看。\n\n这门课是将每两课录制成一个2小时的视频，共20课，10个视频，目前我学了前4课。强烈推荐这个课程给想学习指弹的人，老师讲得较为深入但是有趣，有些课程需要听很多遍才能慢慢理解。和我之前跟的一些免费课相比，非常的系统和全面。\n\n下面是3～4课学习的内容，简单记录下：\n\nC大调音阶：C C# D D# E F F# G G# A A# B C\n\n音程：\n- 第一种单位：全音、半音\n- 第二种单位：完全一度(C)、小二度(Db)、大二度(D)、小三度(Eb)、大三度(E)、完全四度(F)、增四减五度(Gb)、完全五度(G)、小六度(Ab)、大六度(A)、小七度(Bb)、大七度(B)、完全八度(C)\n- C F G C：完全和协音\n- Db D Gb Bb B：完全不和协音\n- Eb E Ab A：不完全和协音\n\n和声：三度的堆叠\n\n单音、双音、和弦（三音及以上）\n\n和弦种类：\n\n- 大三度+小三度 快乐的感觉 大和弦（Major） CMajor（1 3 5） FMajor（4 6 1）\n- 小三度+大三度（6 1 3） 悲伤的感觉 小和弦（minor） Am（6 1 3） Dm（2 4 6）\n- 大三度+大三度 增和弦（Augment）\n- 小三度+小三度 减和弦（diminished）\n- 大三度+小三度+小三度 悬疑的感觉 属七和弦（Major7、minor7） C7（1 3 5 7） G7（5 7 2 4） A7（6 1# 3 5）\n\nminor（悲伤）------属七------Major（快乐）\n\n级数及顺阶和弦：\n\n- 1 Major(大) C(1 3 5)\n- 2 minor(小) Dm(2 4 6)\n- 3 minor(小) Em(3 5 7)\n- 4 Major(大) F(4 6 1)\n- 5 Major(大) G(5 7 2)\n- 6 minor(小) Am(6 1 3)\n- 7 diminished(减) Bdim(7 2 4)\n\n常见和弦进行：\n\n- 1-6m-4-5(比如C调：C Am F G)\n- 1-3m-2m-5\n- 4-3m-2m-1\n- 1-5-6m-3m-4-3m-2m-5\n\n大小调：\n\n- Major：C(做结尾释放) F G\n- minor：Dm Em Am(做结尾释放)\n\n各种调：\n\n- C Key（C调）：C D E F G A B C\n- G Key（G调）：G A B C D E F# G\n- F Key（F调）：F G A Bb C D E F\n\n儿歌（一般大和弦欢快型）可以作为和弦学习的入门，听儿歌识别出里面用到的和弦。比如《小毛驴》。\n\n疑问：为什么音阶是七个音，而不是12平均律里面的六个音呢？\n\n老师布置的课后作业是将C调的《生日快乐歌》改编为其他调，下面是我改编F调和G调的谱子：\n\n生日快乐歌-F调：\n\n![生日快乐歌-F调](/assets/tabs/生日快乐歌-F调.jpg)\n\n生日快乐歌-G调：\n\n![生日快乐歌-G调](/assets/tabs/生日快乐歌-G调.jpg)\n\n### 2018-07-28\n\n最近几周学习弹奏《Always with Me》单音版、还有Jake大神的《Hula Girl》。第一首能比较完整的弹出来，第二首目前只会弹前奏部分和开头一点点。最近感觉来看，学的比较顺利。最近发现了一个叫强尼的尤克里里老师，感觉还挺厉害的，走的指弹路线，打算购买他的课程学习更多指弹的技巧。最近也下载了Jake录制的教学视频，英文的，慢慢看吧。接下来计划练习《Always with Me》的进阶版，继续《Hula Girl》。另外想写一个渲染器，将我发明的.utab格式的记谱文件在浏览器上渲染成谱子。\n\n### 2018-07-08\n\n今天下午和昨天晚上都把时间花在了指弹曲《虫儿飞》上面了，到目前为止感觉还不是很满意。不过还是很有一些效果，弹起来更轻松一些，不会太慌张了。还需要加强的地方：一是多练习那几个难按的和弦；二是快速换弦的问题。\n\n### 2018-07-01\n\n今天早上学习了白熊音乐的第十一课《尤克里里的演奏形式》，一般一首音乐由旋律和伴奏组成。其中旋律可以用尤克里里弹出来可以由人唱出来。形式可以有一下几种：一把尤克里里将旋律弹出来；一把尤克里里将旋律弹出来，另一把尤克里里弹和声伴奏；人唱旋律，一把尤克里里伴奏。\n\n### 2018-06-30\n\n今天晚上练习一个小时。练习《青花瓷》主旋律和《夏威夷小曲子（双音版）》，贴出练习的音频。\n\n青花瓷：\n\n<audio src=\"/assets/tabs/青花瓷.m4a\" controls></audio>\n\n夏威夷小曲子双音版：\n\n<audio src=\"/assets/tabs/夏威夷小曲子双音版.m4a\" controls></audio>\n\n### 2018-06-18\n\n今天看了白熊音乐的第七课《一起合奏》、第八课《和弦+旋律》。第七课主要讲弦律和伴奏（和弦）。涉及到了国际四和弦：C和弦、Am和弦、F和弦、G7和弦，还有课后练习中涉及的Fadd9和弦、C7和弦。第八课讲解了旋律和伴奏的概念，很重要。\n\n### 2018-06-16\n\n今天练习上次留下的《夏威夷小曲（双音版）》，目前还是比较生疏，换弦的时候不是很连贯。另外之前每天早上和晚上也会花几分钟爬下格子和练滑音，保持练习的感觉。今天还看了白熊音乐的第十一课《乐理篇——弹唱和指弹的区别，尤克里里的演奏形式》、第十三课《曲目1——新年好》、第十四课《基本功2——拉伸手指》。以后还是要抽出小段时间来做练习。\n\n附上爬格子和拉伸手指的练习谱子：\n\n![爬格子1](/assets/tabs/爬格子练习1.png)\n\n![爬格子2](/assets/tabs/爬格子练习2.png)\n\n![爬格子3](/assets/tabs/爬格子练习3.png)\n\n![拉伸手指](/assets/tabs/拉伸手指练习.jpg)\n\n以及新年好的谱子：\n\n![新年快乐](/assets/tabs/新年快乐.jpg)\n\n### 2018-06-10\n\n今天学习白熊音乐的指弹系列课程第六课，主要练习的内容是如何同时演奏双音，以及如何滑音。其中演奏双音分两种：如果是同时播响相邻的两根弦，则用拇指去扫，核心是尽量快。如果是同时播响非相邻的弦，则用拇指和食指，拇指向下播弦，食指向上勾弦。滑音的核心包含三个，一是滑的快，二是滑的过程要保持一直压弦，三是滑的准。主要的曲子是《夏威夷小曲（单音版）》、《夏威夷小曲（双音版）》。其中单音版还好，主要是双音版，还需要多加练习。\n\n涉及到的曲子如下：\n\n![小星星（双音版）](/assets/tabs/小星星（双音版）.jpg)\n\n![欢乐颂（双音版）](/assets/tabs/欢乐颂（双音版）.jpg)\n\n![夏威夷小曲子（单音版）](/assets/tabs/夏威夷小曲子（单音版）.jpg)\n\n![夏威夷小曲子（双音版）](/assets/tabs/夏威夷小曲子（双音版）.jpg)\n\n### 2018-05-27\n\n今天练习了白熊音乐的指弹系列课程第五课，主要练习推荐的课后练习曲子《茉莉花》、《欢乐颂》、《Long Long Ago》、《London Bridge is Falling Down》、《Do Re Mi》。其中后面两首比较有难度，只能在tempo为60bpm左右时弹的比较流畅。这里的难点主要有两个：一个是反拍，主要体现在下面4线谱中的开头，第一小节第二拍起来的时候；一个是tempo加快跟不上，这个还是需要多加练习练习。\n\n![London Bridge is Falling Down](/assets/tabs/London-Bridge-is-Falling-Down.jpg)\n\n![Do Re Mi](/assets/tabs/Do-Re-Mi.jpg)\n\n### 2018-05-26\n\n今天主要跟着[《如何訓練音樂節奏感》](http://www.ms333.com/Publication/Cool/Thory-Rhythm.html)中的[教学视频](https://v.qq.com/x/page/z01826ifrlq.html)练习打节奏。重点和难点是反拍的练习。反拍指在一拍的下半时间演奏（拍掌）。以四分音符为一拍的话，八分音符将一拍均分为两段，十六分音符将一拍均分为四段。如果用脚来辅助打拍，那么四分音符是在脚落下去的时候演奏。八分音符一个是在脚落下去的时候演奏，另一个是在脚起来的时候演奏。十六分音符是在脚落下的时候、脚快要起来的时候、脚起来的时候、脚起到一半的时候演奏。\n","source":"_posts/ukulele.md","raw":"---\ntitle: Ukulele学习笔记\ndate: 2018/11/04\ncategories:\n- note\ntags:\n- ukulele\nexcerpt: Ukulele学习笔记\n---\n\n## 术语\n\n- tempo：音乐的速度，比如120bpm指每分钟120拍。\n- bpm：beats per minute\n\n## 学习日记\n\n### 2018-11-04\n\n最近一段时间学习《强尼课》的7、8、9、10课，练习多指法（二指法和三指法）、槌音和勾音。强尼老师强调指甲的修建对音色影响非常大，于是我也重视起来。首先是买了抛光指甲的用具，保留右手拇指、食指和中指指甲，不过目前使用最多的还是拇指，偶尔一些谱子会用到食指，中指基本还没用上。然后生活中做家务时会刻意换成左手来做，保护右手的指甲。\n\n这段时间弹的最多的是电影毕业生主题曲《寂静之声》指弹曲，还有今天练习的《月亮代表我的心》，很喜欢这两首曲子，谱子如下：\n\n![寂静之声](/assets/tabs/寂静之声.jpg)\n![月亮代表我的心](/assets/tabs/月亮代表我的心.jpg)\n\n### 2018-08-25\n\n好久没有记录了，其实这段时间也在陆陆续续学着尤克里里。今天记录下我在学习的一个课程。\n\n前段时间因为强尼小子教学《Hula Girl》而发现了他的《强尼小子基础指弹网络课程》（[课程地址](https://mp.weixin.qq.com/s/7TTP-VcoEiDOp50NSGYk3A)），思考了几天决定买下来，花了800人民币。他这个课有个不太好的地方是无法在Mac上观看，而且只能在一台机器上看。不过这个不能阻挡我热爱学习的心呀，把妹子用的Windows电脑拿来观看。\n\n这门课是将每两课录制成一个2小时的视频，共20课，10个视频，目前我学了前4课。强烈推荐这个课程给想学习指弹的人，老师讲得较为深入但是有趣，有些课程需要听很多遍才能慢慢理解。和我之前跟的一些免费课相比，非常的系统和全面。\n\n下面是3～4课学习的内容，简单记录下：\n\nC大调音阶：C C# D D# E F F# G G# A A# B C\n\n音程：\n- 第一种单位：全音、半音\n- 第二种单位：完全一度(C)、小二度(Db)、大二度(D)、小三度(Eb)、大三度(E)、完全四度(F)、增四减五度(Gb)、完全五度(G)、小六度(Ab)、大六度(A)、小七度(Bb)、大七度(B)、完全八度(C)\n- C F G C：完全和协音\n- Db D Gb Bb B：完全不和协音\n- Eb E Ab A：不完全和协音\n\n和声：三度的堆叠\n\n单音、双音、和弦（三音及以上）\n\n和弦种类：\n\n- 大三度+小三度 快乐的感觉 大和弦（Major） CMajor（1 3 5） FMajor（4 6 1）\n- 小三度+大三度（6 1 3） 悲伤的感觉 小和弦（minor） Am（6 1 3） Dm（2 4 6）\n- 大三度+大三度 增和弦（Augment）\n- 小三度+小三度 减和弦（diminished）\n- 大三度+小三度+小三度 悬疑的感觉 属七和弦（Major7、minor7） C7（1 3 5 7） G7（5 7 2 4） A7（6 1# 3 5）\n\nminor（悲伤）------属七------Major（快乐）\n\n级数及顺阶和弦：\n\n- 1 Major(大) C(1 3 5)\n- 2 minor(小) Dm(2 4 6)\n- 3 minor(小) Em(3 5 7)\n- 4 Major(大) F(4 6 1)\n- 5 Major(大) G(5 7 2)\n- 6 minor(小) Am(6 1 3)\n- 7 diminished(减) Bdim(7 2 4)\n\n常见和弦进行：\n\n- 1-6m-4-5(比如C调：C Am F G)\n- 1-3m-2m-5\n- 4-3m-2m-1\n- 1-5-6m-3m-4-3m-2m-5\n\n大小调：\n\n- Major：C(做结尾释放) F G\n- minor：Dm Em Am(做结尾释放)\n\n各种调：\n\n- C Key（C调）：C D E F G A B C\n- G Key（G调）：G A B C D E F# G\n- F Key（F调）：F G A Bb C D E F\n\n儿歌（一般大和弦欢快型）可以作为和弦学习的入门，听儿歌识别出里面用到的和弦。比如《小毛驴》。\n\n疑问：为什么音阶是七个音，而不是12平均律里面的六个音呢？\n\n老师布置的课后作业是将C调的《生日快乐歌》改编为其他调，下面是我改编F调和G调的谱子：\n\n生日快乐歌-F调：\n\n![生日快乐歌-F调](/assets/tabs/生日快乐歌-F调.jpg)\n\n生日快乐歌-G调：\n\n![生日快乐歌-G调](/assets/tabs/生日快乐歌-G调.jpg)\n\n### 2018-07-28\n\n最近几周学习弹奏《Always with Me》单音版、还有Jake大神的《Hula Girl》。第一首能比较完整的弹出来，第二首目前只会弹前奏部分和开头一点点。最近感觉来看，学的比较顺利。最近发现了一个叫强尼的尤克里里老师，感觉还挺厉害的，走的指弹路线，打算购买他的课程学习更多指弹的技巧。最近也下载了Jake录制的教学视频，英文的，慢慢看吧。接下来计划练习《Always with Me》的进阶版，继续《Hula Girl》。另外想写一个渲染器，将我发明的.utab格式的记谱文件在浏览器上渲染成谱子。\n\n### 2018-07-08\n\n今天下午和昨天晚上都把时间花在了指弹曲《虫儿飞》上面了，到目前为止感觉还不是很满意。不过还是很有一些效果，弹起来更轻松一些，不会太慌张了。还需要加强的地方：一是多练习那几个难按的和弦；二是快速换弦的问题。\n\n### 2018-07-01\n\n今天早上学习了白熊音乐的第十一课《尤克里里的演奏形式》，一般一首音乐由旋律和伴奏组成。其中旋律可以用尤克里里弹出来可以由人唱出来。形式可以有一下几种：一把尤克里里将旋律弹出来；一把尤克里里将旋律弹出来，另一把尤克里里弹和声伴奏；人唱旋律，一把尤克里里伴奏。\n\n### 2018-06-30\n\n今天晚上练习一个小时。练习《青花瓷》主旋律和《夏威夷小曲子（双音版）》，贴出练习的音频。\n\n青花瓷：\n\n<audio src=\"/assets/tabs/青花瓷.m4a\" controls></audio>\n\n夏威夷小曲子双音版：\n\n<audio src=\"/assets/tabs/夏威夷小曲子双音版.m4a\" controls></audio>\n\n### 2018-06-18\n\n今天看了白熊音乐的第七课《一起合奏》、第八课《和弦+旋律》。第七课主要讲弦律和伴奏（和弦）。涉及到了国际四和弦：C和弦、Am和弦、F和弦、G7和弦，还有课后练习中涉及的Fadd9和弦、C7和弦。第八课讲解了旋律和伴奏的概念，很重要。\n\n### 2018-06-16\n\n今天练习上次留下的《夏威夷小曲（双音版）》，目前还是比较生疏，换弦的时候不是很连贯。另外之前每天早上和晚上也会花几分钟爬下格子和练滑音，保持练习的感觉。今天还看了白熊音乐的第十一课《乐理篇——弹唱和指弹的区别，尤克里里的演奏形式》、第十三课《曲目1——新年好》、第十四课《基本功2——拉伸手指》。以后还是要抽出小段时间来做练习。\n\n附上爬格子和拉伸手指的练习谱子：\n\n![爬格子1](/assets/tabs/爬格子练习1.png)\n\n![爬格子2](/assets/tabs/爬格子练习2.png)\n\n![爬格子3](/assets/tabs/爬格子练习3.png)\n\n![拉伸手指](/assets/tabs/拉伸手指练习.jpg)\n\n以及新年好的谱子：\n\n![新年快乐](/assets/tabs/新年快乐.jpg)\n\n### 2018-06-10\n\n今天学习白熊音乐的指弹系列课程第六课，主要练习的内容是如何同时演奏双音，以及如何滑音。其中演奏双音分两种：如果是同时播响相邻的两根弦，则用拇指去扫，核心是尽量快。如果是同时播响非相邻的弦，则用拇指和食指，拇指向下播弦，食指向上勾弦。滑音的核心包含三个，一是滑的快，二是滑的过程要保持一直压弦，三是滑的准。主要的曲子是《夏威夷小曲（单音版）》、《夏威夷小曲（双音版）》。其中单音版还好，主要是双音版，还需要多加练习。\n\n涉及到的曲子如下：\n\n![小星星（双音版）](/assets/tabs/小星星（双音版）.jpg)\n\n![欢乐颂（双音版）](/assets/tabs/欢乐颂（双音版）.jpg)\n\n![夏威夷小曲子（单音版）](/assets/tabs/夏威夷小曲子（单音版）.jpg)\n\n![夏威夷小曲子（双音版）](/assets/tabs/夏威夷小曲子（双音版）.jpg)\n\n### 2018-05-27\n\n今天练习了白熊音乐的指弹系列课程第五课，主要练习推荐的课后练习曲子《茉莉花》、《欢乐颂》、《Long Long Ago》、《London Bridge is Falling Down》、《Do Re Mi》。其中后面两首比较有难度，只能在tempo为60bpm左右时弹的比较流畅。这里的难点主要有两个：一个是反拍，主要体现在下面4线谱中的开头，第一小节第二拍起来的时候；一个是tempo加快跟不上，这个还是需要多加练习练习。\n\n![London Bridge is Falling Down](/assets/tabs/London-Bridge-is-Falling-Down.jpg)\n\n![Do Re Mi](/assets/tabs/Do-Re-Mi.jpg)\n\n### 2018-05-26\n\n今天主要跟着[《如何訓練音樂節奏感》](http://www.ms333.com/Publication/Cool/Thory-Rhythm.html)中的[教学视频](https://v.qq.com/x/page/z01826ifrlq.html)练习打节奏。重点和难点是反拍的练习。反拍指在一拍的下半时间演奏（拍掌）。以四分音符为一拍的话，八分音符将一拍均分为两段，十六分音符将一拍均分为四段。如果用脚来辅助打拍，那么四分音符是在脚落下去的时候演奏。八分音符一个是在脚落下去的时候演奏，另一个是在脚起来的时候演奏。十六分音符是在脚落下的时候、脚快要起来的时候、脚起来的时候、脚起到一半的时候演奏。\n","slug":"ukulele","published":1,"updated":"2020-11-28T14:38:56.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzx000brnq7buqj97j9","content":"<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><ul>\n<li>tempo：音乐的速度，比如120bpm指每分钟120拍。</li>\n<li>bpm：beats per minute</li>\n</ul>\n<h2 id=\"学习日记\"><a href=\"#学习日记\" class=\"headerlink\" title=\"学习日记\"></a>学习日记</h2><h3 id=\"2018-11-04\"><a href=\"#2018-11-04\" class=\"headerlink\" title=\"2018-11-04\"></a>2018-11-04</h3><p>最近一段时间学习《强尼课》的7、8、9、10课，练习多指法（二指法和三指法）、槌音和勾音。强尼老师强调指甲的修建对音色影响非常大，于是我也重视起来。首先是买了抛光指甲的用具，保留右手拇指、食指和中指指甲，不过目前使用最多的还是拇指，偶尔一些谱子会用到食指，中指基本还没用上。然后生活中做家务时会刻意换成左手来做，保护右手的指甲。</p>\n<p>这段时间弹的最多的是电影毕业生主题曲《寂静之声》指弹曲，还有今天练习的《月亮代表我的心》，很喜欢这两首曲子，谱子如下：</p>\n<p><img src=\"/assets/tabs/%E5%AF%82%E9%9D%99%E4%B9%8B%E5%A3%B0.jpg\" alt=\"寂静之声\"><br><img src=\"/assets/tabs/%E6%9C%88%E4%BA%AE%E4%BB%A3%E8%A1%A8%E6%88%91%E7%9A%84%E5%BF%83.jpg\" alt=\"月亮代表我的心\"></p>\n<h3 id=\"2018-08-25\"><a href=\"#2018-08-25\" class=\"headerlink\" title=\"2018-08-25\"></a>2018-08-25</h3><p>好久没有记录了，其实这段时间也在陆陆续续学着尤克里里。今天记录下我在学习的一个课程。</p>\n<p>前段时间因为强尼小子教学《Hula Girl》而发现了他的《强尼小子基础指弹网络课程》（<a href=\"https://mp.weixin.qq.com/s/7TTP-VcoEiDOp50NSGYk3A\">课程地址</a>），思考了几天决定买下来，花了800人民币。他这个课有个不太好的地方是无法在Mac上观看，而且只能在一台机器上看。不过这个不能阻挡我热爱学习的心呀，把妹子用的Windows电脑拿来观看。</p>\n<p>这门课是将每两课录制成一个2小时的视频，共20课，10个视频，目前我学了前4课。强烈推荐这个课程给想学习指弹的人，老师讲得较为深入但是有趣，有些课程需要听很多遍才能慢慢理解。和我之前跟的一些免费课相比，非常的系统和全面。</p>\n<p>下面是3～4课学习的内容，简单记录下：</p>\n<p>C大调音阶：C C# D D# E F F# G G# A A# B C</p>\n<p>音程：</p>\n<ul>\n<li>第一种单位：全音、半音</li>\n<li>第二种单位：完全一度(C)、小二度(Db)、大二度(D)、小三度(Eb)、大三度(E)、完全四度(F)、增四减五度(Gb)、完全五度(G)、小六度(Ab)、大六度(A)、小七度(Bb)、大七度(B)、完全八度(C)</li>\n<li>C F G C：完全和协音</li>\n<li>Db D Gb Bb B：完全不和协音</li>\n<li>Eb E Ab A：不完全和协音</li>\n</ul>\n<p>和声：三度的堆叠</p>\n<p>单音、双音、和弦（三音及以上）</p>\n<p>和弦种类：</p>\n<ul>\n<li>大三度+小三度 快乐的感觉 大和弦（Major） CMajor（1 3 5） FMajor（4 6 1）</li>\n<li>小三度+大三度（6 1 3） 悲伤的感觉 小和弦（minor） Am（6 1 3） Dm（2 4 6）</li>\n<li>大三度+大三度 增和弦（Augment）</li>\n<li>小三度+小三度 减和弦（diminished）</li>\n<li>大三度+小三度+小三度 悬疑的感觉 属七和弦（Major7、minor7） C7（1 3 5 7） G7（5 7 2 4） A7（6 1# 3 5）</li>\n</ul>\n<p>minor（悲伤）——属七——Major（快乐）</p>\n<p>级数及顺阶和弦：</p>\n<ul>\n<li>1 Major(大) C(1 3 5)</li>\n<li>2 minor(小) Dm(2 4 6)</li>\n<li>3 minor(小) Em(3 5 7)</li>\n<li>4 Major(大) F(4 6 1)</li>\n<li>5 Major(大) G(5 7 2)</li>\n<li>6 minor(小) Am(6 1 3)</li>\n<li>7 diminished(减) Bdim(7 2 4)</li>\n</ul>\n<p>常见和弦进行：</p>\n<ul>\n<li>1-6m-4-5(比如C调：C Am F G)</li>\n<li>1-3m-2m-5</li>\n<li>4-3m-2m-1</li>\n<li>1-5-6m-3m-4-3m-2m-5</li>\n</ul>\n<p>大小调：</p>\n<ul>\n<li>Major：C(做结尾释放) F G</li>\n<li>minor：Dm Em Am(做结尾释放)</li>\n</ul>\n<p>各种调：</p>\n<ul>\n<li>C Key（C调）：C D E F G A B C</li>\n<li>G Key（G调）：G A B C D E F# G</li>\n<li>F Key（F调）：F G A Bb C D E F</li>\n</ul>\n<p>儿歌（一般大和弦欢快型）可以作为和弦学习的入门，听儿歌识别出里面用到的和弦。比如《小毛驴》。</p>\n<p>疑问：为什么音阶是七个音，而不是12平均律里面的六个音呢？</p>\n<p>老师布置的课后作业是将C调的《生日快乐歌》改编为其他调，下面是我改编F调和G调的谱子：</p>\n<p>生日快乐歌-F调：</p>\n<p><img src=\"/assets/tabs/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%E6%AD%8C-F%E8%B0%83.jpg\" alt=\"生日快乐歌-F调\"></p>\n<p>生日快乐歌-G调：</p>\n<p><img src=\"/assets/tabs/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%E6%AD%8C-G%E8%B0%83.jpg\" alt=\"生日快乐歌-G调\"></p>\n<h3 id=\"2018-07-28\"><a href=\"#2018-07-28\" class=\"headerlink\" title=\"2018-07-28\"></a>2018-07-28</h3><p>最近几周学习弹奏《Always with Me》单音版、还有Jake大神的《Hula Girl》。第一首能比较完整的弹出来，第二首目前只会弹前奏部分和开头一点点。最近感觉来看，学的比较顺利。最近发现了一个叫强尼的尤克里里老师，感觉还挺厉害的，走的指弹路线，打算购买他的课程学习更多指弹的技巧。最近也下载了Jake录制的教学视频，英文的，慢慢看吧。接下来计划练习《Always with Me》的进阶版，继续《Hula Girl》。另外想写一个渲染器，将我发明的.utab格式的记谱文件在浏览器上渲染成谱子。</p>\n<h3 id=\"2018-07-08\"><a href=\"#2018-07-08\" class=\"headerlink\" title=\"2018-07-08\"></a>2018-07-08</h3><p>今天下午和昨天晚上都把时间花在了指弹曲《虫儿飞》上面了，到目前为止感觉还不是很满意。不过还是很有一些效果，弹起来更轻松一些，不会太慌张了。还需要加强的地方：一是多练习那几个难按的和弦；二是快速换弦的问题。</p>\n<h3 id=\"2018-07-01\"><a href=\"#2018-07-01\" class=\"headerlink\" title=\"2018-07-01\"></a>2018-07-01</h3><p>今天早上学习了白熊音乐的第十一课《尤克里里的演奏形式》，一般一首音乐由旋律和伴奏组成。其中旋律可以用尤克里里弹出来可以由人唱出来。形式可以有一下几种：一把尤克里里将旋律弹出来；一把尤克里里将旋律弹出来，另一把尤克里里弹和声伴奏；人唱旋律，一把尤克里里伴奏。</p>\n<h3 id=\"2018-06-30\"><a href=\"#2018-06-30\" class=\"headerlink\" title=\"2018-06-30\"></a>2018-06-30</h3><p>今天晚上练习一个小时。练习《青花瓷》主旋律和《夏威夷小曲子（双音版）》，贴出练习的音频。</p>\n<p>青花瓷：</p>\n<p><audio src=\"/assets/tabs/青花瓷.m4a\" controls></audio></p>\n<p>夏威夷小曲子双音版：</p>\n<p><audio src=\"/assets/tabs/夏威夷小曲子双音版.m4a\" controls></audio></p>\n<h3 id=\"2018-06-18\"><a href=\"#2018-06-18\" class=\"headerlink\" title=\"2018-06-18\"></a>2018-06-18</h3><p>今天看了白熊音乐的第七课《一起合奏》、第八课《和弦+旋律》。第七课主要讲弦律和伴奏（和弦）。涉及到了国际四和弦：C和弦、Am和弦、F和弦、G7和弦，还有课后练习中涉及的Fadd9和弦、C7和弦。第八课讲解了旋律和伴奏的概念，很重要。</p>\n<h3 id=\"2018-06-16\"><a href=\"#2018-06-16\" class=\"headerlink\" title=\"2018-06-16\"></a>2018-06-16</h3><p>今天练习上次留下的《夏威夷小曲（双音版）》，目前还是比较生疏，换弦的时候不是很连贯。另外之前每天早上和晚上也会花几分钟爬下格子和练滑音，保持练习的感觉。今天还看了白熊音乐的第十一课《乐理篇——弹唱和指弹的区别，尤克里里的演奏形式》、第十三课《曲目1——新年好》、第十四课《基本功2——拉伸手指》。以后还是要抽出小段时间来做练习。</p>\n<p>附上爬格子和拉伸手指的练习谱子：</p>\n<p><img src=\"/assets/tabs/%E7%88%AC%E6%A0%BC%E5%AD%90%E7%BB%83%E4%B9%A01.png\" alt=\"爬格子1\"></p>\n<p><img src=\"/assets/tabs/%E7%88%AC%E6%A0%BC%E5%AD%90%E7%BB%83%E4%B9%A02.png\" alt=\"爬格子2\"></p>\n<p><img src=\"/assets/tabs/%E7%88%AC%E6%A0%BC%E5%AD%90%E7%BB%83%E4%B9%A03.png\" alt=\"爬格子3\"></p>\n<p><img src=\"/assets/tabs/%E6%8B%89%E4%BC%B8%E6%89%8B%E6%8C%87%E7%BB%83%E4%B9%A0.jpg\" alt=\"拉伸手指\"></p>\n<p>以及新年好的谱子：</p>\n<p><img src=\"/assets/tabs/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90.jpg\" alt=\"新年快乐\"></p>\n<h3 id=\"2018-06-10\"><a href=\"#2018-06-10\" class=\"headerlink\" title=\"2018-06-10\"></a>2018-06-10</h3><p>今天学习白熊音乐的指弹系列课程第六课，主要练习的内容是如何同时演奏双音，以及如何滑音。其中演奏双音分两种：如果是同时播响相邻的两根弦，则用拇指去扫，核心是尽量快。如果是同时播响非相邻的弦，则用拇指和食指，拇指向下播弦，食指向上勾弦。滑音的核心包含三个，一是滑的快，二是滑的过程要保持一直压弦，三是滑的准。主要的曲子是《夏威夷小曲（单音版）》、《夏威夷小曲（双音版）》。其中单音版还好，主要是双音版，还需要多加练习。</p>\n<p>涉及到的曲子如下：</p>\n<p><img src=\"/assets/tabs/%E5%B0%8F%E6%98%9F%E6%98%9F%EF%BC%88%E5%8F%8C%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"小星星（双音版）\"></p>\n<p><img src=\"/assets/tabs/%E6%AC%A2%E4%B9%90%E9%A2%82%EF%BC%88%E5%8F%8C%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"欢乐颂（双音版）\"></p>\n<p><img src=\"/assets/tabs/%E5%A4%8F%E5%A8%81%E5%A4%B7%E5%B0%8F%E6%9B%B2%E5%AD%90%EF%BC%88%E5%8D%95%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"夏威夷小曲子（单音版）\"></p>\n<p><img src=\"/assets/tabs/%E5%A4%8F%E5%A8%81%E5%A4%B7%E5%B0%8F%E6%9B%B2%E5%AD%90%EF%BC%88%E5%8F%8C%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"夏威夷小曲子（双音版）\"></p>\n<h3 id=\"2018-05-27\"><a href=\"#2018-05-27\" class=\"headerlink\" title=\"2018-05-27\"></a>2018-05-27</h3><p>今天练习了白熊音乐的指弹系列课程第五课，主要练习推荐的课后练习曲子《茉莉花》、《欢乐颂》、《Long Long Ago》、《London Bridge is Falling Down》、《Do Re Mi》。其中后面两首比较有难度，只能在tempo为60bpm左右时弹的比较流畅。这里的难点主要有两个：一个是反拍，主要体现在下面4线谱中的开头，第一小节第二拍起来的时候；一个是tempo加快跟不上，这个还是需要多加练习练习。</p>\n<p><img src=\"/assets/tabs/London-Bridge-is-Falling-Down.jpg\" alt=\"London Bridge is Falling Down\"></p>\n<p><img src=\"/assets/tabs/Do-Re-Mi.jpg\" alt=\"Do Re Mi\"></p>\n<h3 id=\"2018-05-26\"><a href=\"#2018-05-26\" class=\"headerlink\" title=\"2018-05-26\"></a>2018-05-26</h3><p>今天主要跟着<a href=\"http://www.ms333.com/Publication/Cool/Thory-Rhythm.html\">《如何訓練音樂節奏感》</a>中的<a href=\"https://v.qq.com/x/page/z01826ifrlq.html\">教学视频</a>练习打节奏。重点和难点是反拍的练习。反拍指在一拍的下半时间演奏（拍掌）。以四分音符为一拍的话，八分音符将一拍均分为两段，十六分音符将一拍均分为四段。如果用脚来辅助打拍，那么四分音符是在脚落下去的时候演奏。八分音符一个是在脚落下去的时候演奏，另一个是在脚起来的时候演奏。十六分音符是在脚落下的时候、脚快要起来的时候、脚起来的时候、脚起到一半的时候演奏。</p>\n","site":{"data":{}},"more":"<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><ul>\n<li>tempo：音乐的速度，比如120bpm指每分钟120拍。</li>\n<li>bpm：beats per minute</li>\n</ul>\n<h2 id=\"学习日记\"><a href=\"#学习日记\" class=\"headerlink\" title=\"学习日记\"></a>学习日记</h2><h3 id=\"2018-11-04\"><a href=\"#2018-11-04\" class=\"headerlink\" title=\"2018-11-04\"></a>2018-11-04</h3><p>最近一段时间学习《强尼课》的7、8、9、10课，练习多指法（二指法和三指法）、槌音和勾音。强尼老师强调指甲的修建对音色影响非常大，于是我也重视起来。首先是买了抛光指甲的用具，保留右手拇指、食指和中指指甲，不过目前使用最多的还是拇指，偶尔一些谱子会用到食指，中指基本还没用上。然后生活中做家务时会刻意换成左手来做，保护右手的指甲。</p>\n<p>这段时间弹的最多的是电影毕业生主题曲《寂静之声》指弹曲，还有今天练习的《月亮代表我的心》，很喜欢这两首曲子，谱子如下：</p>\n<p><img src=\"/assets/tabs/%E5%AF%82%E9%9D%99%E4%B9%8B%E5%A3%B0.jpg\" alt=\"寂静之声\"><br><img src=\"/assets/tabs/%E6%9C%88%E4%BA%AE%E4%BB%A3%E8%A1%A8%E6%88%91%E7%9A%84%E5%BF%83.jpg\" alt=\"月亮代表我的心\"></p>\n<h3 id=\"2018-08-25\"><a href=\"#2018-08-25\" class=\"headerlink\" title=\"2018-08-25\"></a>2018-08-25</h3><p>好久没有记录了，其实这段时间也在陆陆续续学着尤克里里。今天记录下我在学习的一个课程。</p>\n<p>前段时间因为强尼小子教学《Hula Girl》而发现了他的《强尼小子基础指弹网络课程》（<a href=\"https://mp.weixin.qq.com/s/7TTP-VcoEiDOp50NSGYk3A\">课程地址</a>），思考了几天决定买下来，花了800人民币。他这个课有个不太好的地方是无法在Mac上观看，而且只能在一台机器上看。不过这个不能阻挡我热爱学习的心呀，把妹子用的Windows电脑拿来观看。</p>\n<p>这门课是将每两课录制成一个2小时的视频，共20课，10个视频，目前我学了前4课。强烈推荐这个课程给想学习指弹的人，老师讲得较为深入但是有趣，有些课程需要听很多遍才能慢慢理解。和我之前跟的一些免费课相比，非常的系统和全面。</p>\n<p>下面是3～4课学习的内容，简单记录下：</p>\n<p>C大调音阶：C C# D D# E F F# G G# A A# B C</p>\n<p>音程：</p>\n<ul>\n<li>第一种单位：全音、半音</li>\n<li>第二种单位：完全一度(C)、小二度(Db)、大二度(D)、小三度(Eb)、大三度(E)、完全四度(F)、增四减五度(Gb)、完全五度(G)、小六度(Ab)、大六度(A)、小七度(Bb)、大七度(B)、完全八度(C)</li>\n<li>C F G C：完全和协音</li>\n<li>Db D Gb Bb B：完全不和协音</li>\n<li>Eb E Ab A：不完全和协音</li>\n</ul>\n<p>和声：三度的堆叠</p>\n<p>单音、双音、和弦（三音及以上）</p>\n<p>和弦种类：</p>\n<ul>\n<li>大三度+小三度 快乐的感觉 大和弦（Major） CMajor（1 3 5） FMajor（4 6 1）</li>\n<li>小三度+大三度（6 1 3） 悲伤的感觉 小和弦（minor） Am（6 1 3） Dm（2 4 6）</li>\n<li>大三度+大三度 增和弦（Augment）</li>\n<li>小三度+小三度 减和弦（diminished）</li>\n<li>大三度+小三度+小三度 悬疑的感觉 属七和弦（Major7、minor7） C7（1 3 5 7） G7（5 7 2 4） A7（6 1# 3 5）</li>\n</ul>\n<p>minor（悲伤）——属七——Major（快乐）</p>\n<p>级数及顺阶和弦：</p>\n<ul>\n<li>1 Major(大) C(1 3 5)</li>\n<li>2 minor(小) Dm(2 4 6)</li>\n<li>3 minor(小) Em(3 5 7)</li>\n<li>4 Major(大) F(4 6 1)</li>\n<li>5 Major(大) G(5 7 2)</li>\n<li>6 minor(小) Am(6 1 3)</li>\n<li>7 diminished(减) Bdim(7 2 4)</li>\n</ul>\n<p>常见和弦进行：</p>\n<ul>\n<li>1-6m-4-5(比如C调：C Am F G)</li>\n<li>1-3m-2m-5</li>\n<li>4-3m-2m-1</li>\n<li>1-5-6m-3m-4-3m-2m-5</li>\n</ul>\n<p>大小调：</p>\n<ul>\n<li>Major：C(做结尾释放) F G</li>\n<li>minor：Dm Em Am(做结尾释放)</li>\n</ul>\n<p>各种调：</p>\n<ul>\n<li>C Key（C调）：C D E F G A B C</li>\n<li>G Key（G调）：G A B C D E F# G</li>\n<li>F Key（F调）：F G A Bb C D E F</li>\n</ul>\n<p>儿歌（一般大和弦欢快型）可以作为和弦学习的入门，听儿歌识别出里面用到的和弦。比如《小毛驴》。</p>\n<p>疑问：为什么音阶是七个音，而不是12平均律里面的六个音呢？</p>\n<p>老师布置的课后作业是将C调的《生日快乐歌》改编为其他调，下面是我改编F调和G调的谱子：</p>\n<p>生日快乐歌-F调：</p>\n<p><img src=\"/assets/tabs/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%E6%AD%8C-F%E8%B0%83.jpg\" alt=\"生日快乐歌-F调\"></p>\n<p>生日快乐歌-G调：</p>\n<p><img src=\"/assets/tabs/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%E6%AD%8C-G%E8%B0%83.jpg\" alt=\"生日快乐歌-G调\"></p>\n<h3 id=\"2018-07-28\"><a href=\"#2018-07-28\" class=\"headerlink\" title=\"2018-07-28\"></a>2018-07-28</h3><p>最近几周学习弹奏《Always with Me》单音版、还有Jake大神的《Hula Girl》。第一首能比较完整的弹出来，第二首目前只会弹前奏部分和开头一点点。最近感觉来看，学的比较顺利。最近发现了一个叫强尼的尤克里里老师，感觉还挺厉害的，走的指弹路线，打算购买他的课程学习更多指弹的技巧。最近也下载了Jake录制的教学视频，英文的，慢慢看吧。接下来计划练习《Always with Me》的进阶版，继续《Hula Girl》。另外想写一个渲染器，将我发明的.utab格式的记谱文件在浏览器上渲染成谱子。</p>\n<h3 id=\"2018-07-08\"><a href=\"#2018-07-08\" class=\"headerlink\" title=\"2018-07-08\"></a>2018-07-08</h3><p>今天下午和昨天晚上都把时间花在了指弹曲《虫儿飞》上面了，到目前为止感觉还不是很满意。不过还是很有一些效果，弹起来更轻松一些，不会太慌张了。还需要加强的地方：一是多练习那几个难按的和弦；二是快速换弦的问题。</p>\n<h3 id=\"2018-07-01\"><a href=\"#2018-07-01\" class=\"headerlink\" title=\"2018-07-01\"></a>2018-07-01</h3><p>今天早上学习了白熊音乐的第十一课《尤克里里的演奏形式》，一般一首音乐由旋律和伴奏组成。其中旋律可以用尤克里里弹出来可以由人唱出来。形式可以有一下几种：一把尤克里里将旋律弹出来；一把尤克里里将旋律弹出来，另一把尤克里里弹和声伴奏；人唱旋律，一把尤克里里伴奏。</p>\n<h3 id=\"2018-06-30\"><a href=\"#2018-06-30\" class=\"headerlink\" title=\"2018-06-30\"></a>2018-06-30</h3><p>今天晚上练习一个小时。练习《青花瓷》主旋律和《夏威夷小曲子（双音版）》，贴出练习的音频。</p>\n<p>青花瓷：</p>\n<p><audio src=\"/assets/tabs/青花瓷.m4a\" controls></audio></p>\n<p>夏威夷小曲子双音版：</p>\n<p><audio src=\"/assets/tabs/夏威夷小曲子双音版.m4a\" controls></audio></p>\n<h3 id=\"2018-06-18\"><a href=\"#2018-06-18\" class=\"headerlink\" title=\"2018-06-18\"></a>2018-06-18</h3><p>今天看了白熊音乐的第七课《一起合奏》、第八课《和弦+旋律》。第七课主要讲弦律和伴奏（和弦）。涉及到了国际四和弦：C和弦、Am和弦、F和弦、G7和弦，还有课后练习中涉及的Fadd9和弦、C7和弦。第八课讲解了旋律和伴奏的概念，很重要。</p>\n<h3 id=\"2018-06-16\"><a href=\"#2018-06-16\" class=\"headerlink\" title=\"2018-06-16\"></a>2018-06-16</h3><p>今天练习上次留下的《夏威夷小曲（双音版）》，目前还是比较生疏，换弦的时候不是很连贯。另外之前每天早上和晚上也会花几分钟爬下格子和练滑音，保持练习的感觉。今天还看了白熊音乐的第十一课《乐理篇——弹唱和指弹的区别，尤克里里的演奏形式》、第十三课《曲目1——新年好》、第十四课《基本功2——拉伸手指》。以后还是要抽出小段时间来做练习。</p>\n<p>附上爬格子和拉伸手指的练习谱子：</p>\n<p><img src=\"/assets/tabs/%E7%88%AC%E6%A0%BC%E5%AD%90%E7%BB%83%E4%B9%A01.png\" alt=\"爬格子1\"></p>\n<p><img src=\"/assets/tabs/%E7%88%AC%E6%A0%BC%E5%AD%90%E7%BB%83%E4%B9%A02.png\" alt=\"爬格子2\"></p>\n<p><img src=\"/assets/tabs/%E7%88%AC%E6%A0%BC%E5%AD%90%E7%BB%83%E4%B9%A03.png\" alt=\"爬格子3\"></p>\n<p><img src=\"/assets/tabs/%E6%8B%89%E4%BC%B8%E6%89%8B%E6%8C%87%E7%BB%83%E4%B9%A0.jpg\" alt=\"拉伸手指\"></p>\n<p>以及新年好的谱子：</p>\n<p><img src=\"/assets/tabs/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90.jpg\" alt=\"新年快乐\"></p>\n<h3 id=\"2018-06-10\"><a href=\"#2018-06-10\" class=\"headerlink\" title=\"2018-06-10\"></a>2018-06-10</h3><p>今天学习白熊音乐的指弹系列课程第六课，主要练习的内容是如何同时演奏双音，以及如何滑音。其中演奏双音分两种：如果是同时播响相邻的两根弦，则用拇指去扫，核心是尽量快。如果是同时播响非相邻的弦，则用拇指和食指，拇指向下播弦，食指向上勾弦。滑音的核心包含三个，一是滑的快，二是滑的过程要保持一直压弦，三是滑的准。主要的曲子是《夏威夷小曲（单音版）》、《夏威夷小曲（双音版）》。其中单音版还好，主要是双音版，还需要多加练习。</p>\n<p>涉及到的曲子如下：</p>\n<p><img src=\"/assets/tabs/%E5%B0%8F%E6%98%9F%E6%98%9F%EF%BC%88%E5%8F%8C%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"小星星（双音版）\"></p>\n<p><img src=\"/assets/tabs/%E6%AC%A2%E4%B9%90%E9%A2%82%EF%BC%88%E5%8F%8C%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"欢乐颂（双音版）\"></p>\n<p><img src=\"/assets/tabs/%E5%A4%8F%E5%A8%81%E5%A4%B7%E5%B0%8F%E6%9B%B2%E5%AD%90%EF%BC%88%E5%8D%95%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"夏威夷小曲子（单音版）\"></p>\n<p><img src=\"/assets/tabs/%E5%A4%8F%E5%A8%81%E5%A4%B7%E5%B0%8F%E6%9B%B2%E5%AD%90%EF%BC%88%E5%8F%8C%E9%9F%B3%E7%89%88%EF%BC%89.jpg\" alt=\"夏威夷小曲子（双音版）\"></p>\n<h3 id=\"2018-05-27\"><a href=\"#2018-05-27\" class=\"headerlink\" title=\"2018-05-27\"></a>2018-05-27</h3><p>今天练习了白熊音乐的指弹系列课程第五课，主要练习推荐的课后练习曲子《茉莉花》、《欢乐颂》、《Long Long Ago》、《London Bridge is Falling Down》、《Do Re Mi》。其中后面两首比较有难度，只能在tempo为60bpm左右时弹的比较流畅。这里的难点主要有两个：一个是反拍，主要体现在下面4线谱中的开头，第一小节第二拍起来的时候；一个是tempo加快跟不上，这个还是需要多加练习练习。</p>\n<p><img src=\"/assets/tabs/London-Bridge-is-Falling-Down.jpg\" alt=\"London Bridge is Falling Down\"></p>\n<p><img src=\"/assets/tabs/Do-Re-Mi.jpg\" alt=\"Do Re Mi\"></p>\n<h3 id=\"2018-05-26\"><a href=\"#2018-05-26\" class=\"headerlink\" title=\"2018-05-26\"></a>2018-05-26</h3><p>今天主要跟着<a href=\"http://www.ms333.com/Publication/Cool/Thory-Rhythm.html\">《如何訓練音樂節奏感》</a>中的<a href=\"https://v.qq.com/x/page/z01826ifrlq.html\">教学视频</a>练习打节奏。重点和难点是反拍的练习。反拍指在一拍的下半时间演奏（拍掌）。以四分音符为一拍的话，八分音符将一拍均分为两段，十六分音符将一拍均分为四段。如果用脚来辅助打拍，那么四分音符是在脚落下去的时候演奏。八分音符一个是在脚落下去的时候演奏，另一个是在脚起来的时候演奏。十六分音符是在脚落下的时候、脚快要起来的时候、脚起来的时候、脚起到一半的时候演奏。</p>\n"},{"title":"本站建造过程记录","date":"2020-06-13T16:00:00.000Z","excerpt":"本文详细记录了使用Hexo创建静态博客的过程。","_content":"\n本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。\n\n## 使用Gitee Pages服务\n\n在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是[lhtin](https://gitee.com/lhtin)，仓库名也为[lhtin](https://gitee.com/lhtin/lhtin)，这样就可以直接通过 https://lhtin.gitee.io 访问，而不需要加上仓库的名称作为访问的路径（ https://lhtin.gitee.io/lhtin ）。\n\n创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考[官方指南](https://gitee.com/help/articles/4136)。这样静态服务器就有了。\n\n## 使用Hexo博客框架\n\n为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。\n\n### 初始化博客项目\n\n首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：\n\n```shell\nnpm install -g hexo-cli\n\nhexo init <name>\n\ncd <name>\nnpm install\n```\n\n执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：\n\n```shell\nnpm run server // 启动本地server\nnpm run build // 将项目打包成静态文件，存放在public目录\nnpm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置\n\nhexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中\n```\n\n更多指南请前往[Hexo官方文档](https://hexo.io/zh-cn/docs)。\n\n### 根据需要修改配置\n\n在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见[官方文档-配置](https://hexo.io/zh-cn/docs/configuration)）：\n\n```yml\n# 项目根目录下的_config.yml文件\ntitle: 01的世界\nsubtitle: 计算机的世界没有秘密\ndescription: 这里有关于计算机的方方面面\nkeywords: 01的世界\nauthor: 钉子哥\nlanguage: zh-CN # 会影响主题中的语言选择\ntimezone: Asia/Shanghai\n\n// 本博客部署的地址\nurl: https://lhtin.gitee.io\nroot: /\n```\n\n然后还需要根据我自己的要求，修改默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的部分内容。所有修改的内容可以参见我fork出来的[仓库](https://gitee.com/lhtin/hexo-theme-landscape)。这里我列出主要的修改：\n\n- 将一些英文翻译为中文，比如Home -> 首页，Read More -> 阅读全文\n- 去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag\n- 添加百度统计，并和Google统计合并到一个ejs文件\n- 去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期\n- 去掉右上角的导航，固定展示为“首页”\n- 修改首页展示文章摘抄的样式\n\n### 构建和部署\n\n当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的[ejs模版](https://ejs.co)，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。\n\n生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。\n\n```yml\n# 项目根目录下的_config.yml文件\ndeploy:\n  type: git\n  repo: https://gitee.com/lhtin/lhtin.git\n  branch: page\n```\n\n构建和部署的命令如下：\n\n```\nnpm run build\nnpm install --save-dev hexo-deployer-git\nnpm run deploy\n```\n\n因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：\n\n```json\n{\n  \"scripts\": {\n    \"d\": \"npm run clean && npm run build && npm run deploy\"\n  }\n}\n```\n\n这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。~~或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。~~目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加[gitee](https://www.npmjs.com/package/gitee)这个npm模块。","source":"_drafts/hexo-guide.md","raw":"---\ntitle: 本站建造过程记录\ndate: 2020/06/14\ntag:\n- guide\ncategory:\n- guide\nexcerpt: 本文详细记录了使用Hexo创建静态博客的过程。\n---\n\n本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。\n\n## 使用Gitee Pages服务\n\n在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是[lhtin](https://gitee.com/lhtin)，仓库名也为[lhtin](https://gitee.com/lhtin/lhtin)，这样就可以直接通过 https://lhtin.gitee.io 访问，而不需要加上仓库的名称作为访问的路径（ https://lhtin.gitee.io/lhtin ）。\n\n创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考[官方指南](https://gitee.com/help/articles/4136)。这样静态服务器就有了。\n\n## 使用Hexo博客框架\n\n为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。\n\n### 初始化博客项目\n\n首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：\n\n```shell\nnpm install -g hexo-cli\n\nhexo init <name>\n\ncd <name>\nnpm install\n```\n\n执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：\n\n```shell\nnpm run server // 启动本地server\nnpm run build // 将项目打包成静态文件，存放在public目录\nnpm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置\n\nhexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中\n```\n\n更多指南请前往[Hexo官方文档](https://hexo.io/zh-cn/docs)。\n\n### 根据需要修改配置\n\n在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见[官方文档-配置](https://hexo.io/zh-cn/docs/configuration)）：\n\n```yml\n# 项目根目录下的_config.yml文件\ntitle: 01的世界\nsubtitle: 计算机的世界没有秘密\ndescription: 这里有关于计算机的方方面面\nkeywords: 01的世界\nauthor: 钉子哥\nlanguage: zh-CN # 会影响主题中的语言选择\ntimezone: Asia/Shanghai\n\n// 本博客部署的地址\nurl: https://lhtin.gitee.io\nroot: /\n```\n\n然后还需要根据我自己的要求，修改默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的部分内容。所有修改的内容可以参见我fork出来的[仓库](https://gitee.com/lhtin/hexo-theme-landscape)。这里我列出主要的修改：\n\n- 将一些英文翻译为中文，比如Home -> 首页，Read More -> 阅读全文\n- 去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag\n- 添加百度统计，并和Google统计合并到一个ejs文件\n- 去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期\n- 去掉右上角的导航，固定展示为“首页”\n- 修改首页展示文章摘抄的样式\n\n### 构建和部署\n\n当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的[ejs模版](https://ejs.co)，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。\n\n生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。\n\n```yml\n# 项目根目录下的_config.yml文件\ndeploy:\n  type: git\n  repo: https://gitee.com/lhtin/lhtin.git\n  branch: page\n```\n\n构建和部署的命令如下：\n\n```\nnpm run build\nnpm install --save-dev hexo-deployer-git\nnpm run deploy\n```\n\n因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：\n\n```json\n{\n  \"scripts\": {\n    \"d\": \"npm run clean && npm run build && npm run deploy\"\n  }\n}\n```\n\n这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。~~或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。~~目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加[gitee](https://www.npmjs.com/package/gitee)这个npm模块。","slug":"hexo-guide","published":0,"updated":"2020-11-01T09:07:19.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzz000frnq71jivamv4","content":"<p>本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。</p>\n<h2 id=\"使用Gitee-Pages服务\"><a href=\"#使用Gitee-Pages服务\" class=\"headerlink\" title=\"使用Gitee Pages服务\"></a>使用Gitee Pages服务</h2><p>在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是<a href=\"https://gitee.com/lhtin\">lhtin</a>，仓库名也为<a href=\"https://gitee.com/lhtin/lhtin\">lhtin</a>，这样就可以直接通过 <a href=\"https://lhtin.gitee.io/\">https://lhtin.gitee.io</a> 访问，而不需要加上仓库的名称作为访问的路径（ <a href=\"https://lhtin.gitee.io/lhtin\">https://lhtin.gitee.io/lhtin</a> ）。</p>\n<p>创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考<a href=\"https://gitee.com/help/articles/4136\">官方指南</a>。这样静态服务器就有了。</p>\n<h2 id=\"使用Hexo博客框架\"><a href=\"#使用Hexo博客框架\" class=\"headerlink\" title=\"使用Hexo博客框架\"></a>使用Hexo博客框架</h2><p>为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。</p>\n<h3 id=\"初始化博客项目\"><a href=\"#初始化博客项目\" class=\"headerlink\" title=\"初始化博客项目\"></a>初始化博客项目</h3><p>首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cd &lt;name&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run server // 启动本地server</span><br><span class=\"line\">npm run build // 将项目打包成静态文件，存放在public目录</span><br><span class=\"line\">npm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中</span><br></pre></td></tr></table></figure>\n\n<p>更多指南请前往<a href=\"https://hexo.io/zh-cn/docs\">Hexo官方文档</a>。</p>\n<h3 id=\"根据需要修改配置\"><a href=\"#根据需要修改配置\" class=\"headerlink\" title=\"根据需要修改配置\"></a>根据需要修改配置</h3><p>在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见<a href=\"https://hexo.io/zh-cn/docs/configuration\">官方文档-配置</a>）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">计算机的世界没有秘密</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">这里有关于计算机的方方面面</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">钉子哥</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span> <span class=\"comment\"># 会影响主题中的语言选择</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span> <span class=\"string\">本博客部署的地址</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://lhtin.gitee.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>然后还需要根据我自己的要求，修改默认主题<a href=\"https://github.com/hexojs/hexo-theme-landscape\">landscape</a>的部分内容。所有修改的内容可以参见我fork出来的<a href=\"https://gitee.com/lhtin/hexo-theme-landscape\">仓库</a>。这里我列出主要的修改：</p>\n<ul>\n<li>将一些英文翻译为中文，比如Home -&gt; 首页，Read More -&gt; 阅读全文</li>\n<li>去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag</li>\n<li>添加百度统计，并和Google统计合并到一个ejs文件</li>\n<li>去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期</li>\n<li>去掉右上角的导航，固定展示为“首页”</li>\n<li>修改首页展示文章摘抄的样式</li>\n</ul>\n<h3 id=\"构建和部署\"><a href=\"#构建和部署\" class=\"headerlink\" title=\"构建和部署\"></a>构建和部署</h3><p>当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的<a href=\"https://ejs.co/\">ejs模版</a>，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。</p>\n<p>生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gitee.com/lhtin/lhtin.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">page</span></span><br></pre></td></tr></table></figure>\n\n<p>构建和部署的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br><span class=\"line\">npm install --save-dev hexo-deployer-git</span><br><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;d&quot;</span>: <span class=\"string\">&quot;npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。<del>或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。</del>目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加<a href=\"https://www.npmjs.com/package/gitee\">gitee</a>这个npm模块。</p>\n","site":{"data":{}},"more":"<p>本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。</p>\n<h2 id=\"使用Gitee-Pages服务\"><a href=\"#使用Gitee-Pages服务\" class=\"headerlink\" title=\"使用Gitee Pages服务\"></a>使用Gitee Pages服务</h2><p>在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是<a href=\"https://gitee.com/lhtin\">lhtin</a>，仓库名也为<a href=\"https://gitee.com/lhtin/lhtin\">lhtin</a>，这样就可以直接通过 <a href=\"https://lhtin.gitee.io/\">https://lhtin.gitee.io</a> 访问，而不需要加上仓库的名称作为访问的路径（ <a href=\"https://lhtin.gitee.io/lhtin\">https://lhtin.gitee.io/lhtin</a> ）。</p>\n<p>创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考<a href=\"https://gitee.com/help/articles/4136\">官方指南</a>。这样静态服务器就有了。</p>\n<h2 id=\"使用Hexo博客框架\"><a href=\"#使用Hexo博客框架\" class=\"headerlink\" title=\"使用Hexo博客框架\"></a>使用Hexo博客框架</h2><p>为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。</p>\n<h3 id=\"初始化博客项目\"><a href=\"#初始化博客项目\" class=\"headerlink\" title=\"初始化博客项目\"></a>初始化博客项目</h3><p>首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cd &lt;name&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run server // 启动本地server</span><br><span class=\"line\">npm run build // 将项目打包成静态文件，存放在public目录</span><br><span class=\"line\">npm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中</span><br></pre></td></tr></table></figure>\n\n<p>更多指南请前往<a href=\"https://hexo.io/zh-cn/docs\">Hexo官方文档</a>。</p>\n<h3 id=\"根据需要修改配置\"><a href=\"#根据需要修改配置\" class=\"headerlink\" title=\"根据需要修改配置\"></a>根据需要修改配置</h3><p>在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见<a href=\"https://hexo.io/zh-cn/docs/configuration\">官方文档-配置</a>）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">计算机的世界没有秘密</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">这里有关于计算机的方方面面</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">钉子哥</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span> <span class=\"comment\"># 会影响主题中的语言选择</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span> <span class=\"string\">本博客部署的地址</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://lhtin.gitee.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>然后还需要根据我自己的要求，修改默认主题<a href=\"https://github.com/hexojs/hexo-theme-landscape\">landscape</a>的部分内容。所有修改的内容可以参见我fork出来的<a href=\"https://gitee.com/lhtin/hexo-theme-landscape\">仓库</a>。这里我列出主要的修改：</p>\n<ul>\n<li>将一些英文翻译为中文，比如Home -&gt; 首页，Read More -&gt; 阅读全文</li>\n<li>去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag</li>\n<li>添加百度统计，并和Google统计合并到一个ejs文件</li>\n<li>去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期</li>\n<li>去掉右上角的导航，固定展示为“首页”</li>\n<li>修改首页展示文章摘抄的样式</li>\n</ul>\n<h3 id=\"构建和部署\"><a href=\"#构建和部署\" class=\"headerlink\" title=\"构建和部署\"></a>构建和部署</h3><p>当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的<a href=\"https://ejs.co/\">ejs模版</a>，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。</p>\n<p>生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gitee.com/lhtin/lhtin.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">page</span></span><br></pre></td></tr></table></figure>\n\n<p>构建和部署的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br><span class=\"line\">npm install --save-dev hexo-deployer-git</span><br><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;d&quot;</span>: <span class=\"string\">&quot;npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。<del>或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。</del>目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加<a href=\"https://www.npmjs.com/package/gitee\">gitee</a>这个npm模块。</p>\n"},{"title":"homebrew国内安装指南","date":"2020-06-17T02:30:39.000Z","_content":"\n[Homebrew](https://brew.sh)是一款Mac上的包管理器，可以很方便的安装各种软件。\n\nfishshell:\n\n```\n# 安装brew\n/bin/bash -c (curl -fsSL https://gitee.com/lhtin/brew-install/raw/master/install.sh)\n\n# 修改源为gitee\ncd (brew --repo)\ngit remote set-url origin https://gitee.com/lhtin/brew.git\n\ncd (brew --repo)/Library/Taps/homebrew/homebrew-core\ngit remote set-url origin https://gitee.com/lhtin/homebrew-core.git\n\n# 安装了cask才有\ncd (brew --repo)/Library/Taps/homebrew/homebrew-cask\ngit remote set-url origin https://gitee.com/lhtin/homebrew-cask.git\n\n# 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址\n\n# 修改Bottles源\n## 中科大源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.ustc.edu.cn/homebrew-bottles\n## 清华源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\n```\n","source":"_drafts/homebrew.md","raw":"---\ntitle: homebrew国内安装指南\ndate: 2020-06-17 10:30:39\ncategories:\n- software\ntags:\n- software\n---\n\n[Homebrew](https://brew.sh)是一款Mac上的包管理器，可以很方便的安装各种软件。\n\nfishshell:\n\n```\n# 安装brew\n/bin/bash -c (curl -fsSL https://gitee.com/lhtin/brew-install/raw/master/install.sh)\n\n# 修改源为gitee\ncd (brew --repo)\ngit remote set-url origin https://gitee.com/lhtin/brew.git\n\ncd (brew --repo)/Library/Taps/homebrew/homebrew-core\ngit remote set-url origin https://gitee.com/lhtin/homebrew-core.git\n\n# 安装了cask才有\ncd (brew --repo)/Library/Taps/homebrew/homebrew-cask\ngit remote set-url origin https://gitee.com/lhtin/homebrew-cask.git\n\n# 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址\n\n# 修改Bottles源\n## 中科大源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.ustc.edu.cn/homebrew-bottles\n## 清华源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\n```\n","slug":"homebrew","published":0,"updated":"2020-11-01T09:07:19.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szjzz000hrnq7fyjbcqgh","content":"<p><a href=\"https://brew.sh/\">Homebrew</a>是一款Mac上的包管理器，可以很方便的安装各种软件。</p>\n<p>fishshell:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装brew</span><br><span class=\"line\">&#x2F;bin&#x2F;bash -c (curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew-install&#x2F;raw&#x2F;master&#x2F;install.sh)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改源为gitee</span><br><span class=\"line\">cd (brew --repo)</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-core.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装了cask才有</span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-cask.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改Bottles源</span><br><span class=\"line\">## 中科大源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles</span><br><span class=\"line\">## 清华源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;homebrew-bottles</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://brew.sh/\">Homebrew</a>是一款Mac上的包管理器，可以很方便的安装各种软件。</p>\n<p>fishshell:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装brew</span><br><span class=\"line\">&#x2F;bin&#x2F;bash -c (curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew-install&#x2F;raw&#x2F;master&#x2F;install.sh)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改源为gitee</span><br><span class=\"line\">cd (brew --repo)</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-core.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装了cask才有</span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-cask.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改Bottles源</span><br><span class=\"line\">## 中科大源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles</span><br><span class=\"line\">## 清华源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;homebrew-bottles</span><br></pre></td></tr></table></figure>\n"},{"_content":"- router 读音不对","source":"_drafts/keyword.md","raw":"- router 读音不对","slug":"keyword","published":0,"date":"2020-11-01T09:07:19.033Z","updated":"2020-11-01T09:07:19.034Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk01000lrnq7azg77ve8","content":"<ul>\n<li>router 读音不对</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>router 读音不对</li>\n</ul>\n"},{"title":"Nand2Tetris Part 2 课程总结","date":"2020-11-01T09:07:19.035Z","excerpt":"按：本文记录我在学习完Coursera上的 Nand2Tetris Part 2 课程之后的总结与思考。","_content":"\n![image-20200726213820736](nand2tetris-2.assets/image-20200726213820736.png)\n\n","source":"_drafts/nand2tetris-2.md","raw":"---\ntitle: Nand2Tetris Part 2 课程总结\ndate: 2020/07/xx\ntag:\n- 笔记\ncategory:\n- 笔记\nexcerpt: 按：本文记录我在学习完Coursera上的 Nand2Tetris Part 2 课程之后的总结与思考。\n---\n\n![image-20200726213820736](nand2tetris-2.assets/image-20200726213820736.png)\n\n","slug":"nand2tetris-2","published":0,"updated":"2020-11-01T09:07:19.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk06001arnq7fbe2girz","content":"<p><img src=\"nand2tetris-2.assets/image-20200726213820736.png\" alt=\"image-20200726213820736\"></p>\n","site":{"data":{}},"more":"<p><img src=\"nand2tetris-2.assets/image-20200726213820736.png\" alt=\"image-20200726213820736\"></p>\n"},{"_content":"# 玩转React系列2：寻找更高效的列表更新算法\n\n本文接着上篇《玩转React系列1：React工作原理》最后提到的React列表更新的问题，来深入探讨下是否有更高效的列表更新方式。\n\n## 目录\n\n- 0\\. 问题描述\n- 1\\. 寻找更高效的方法\n- 2\\. benchmark\n\n## 问题描述\n\n上一篇文章最后提到，React更新算法有一个问题，就是选取的不动子列表S可能不是最长的。比如将S1中的最后一个元素e<sub>n</sub>移动到第一个元素e<sub>1</sub>前面，变成S2的情况。React选取的不动子列表只包含最后一个元素e<sub>n</sub>，所以需要移动其他n-1个元素。但实际上可以将[e<sub>1</sub>, ..., e<sub>n-1</sub>]作为不动子列表，从而只需要做一次移动操作，也就是将e<sub>n</sub>移动到e<sub>1</sub>的前面。\n\n本文尝试探索一种新的方法，来减少元素移动的次数。以及做一个基准测试来确定使用新的方法是否更省时。\n\n## 寻找更高效的方法\n\n为了更清晰的讨论这个问题，我们先做一个合理的假设，假设从列表S1（prevChildren）到列表S2（nextChildren），只是子元素的顺序变了，没有新增和删除子元素。这个假设是合理的，因为不管是哪种更新方式，新增和删除的操作都是一样的，不会影响算法复杂度。另外为了描述方便，假设S1和S2中的元素由该元素在S1中的位置（下标）代替，比如如果S1为d、c、a、b，S2为b、a、d、c。换成下标S1就是0、1、2、3（即d在S1中的位置、c在S1中的位置、a在S1中的位置、b在S1中的位置），S2就是3、2、0、1（即b在S1中的位置、a在S1中的位置、d在S1中的位置、c在S1中的位置）。\n\n首先我们将S2中的n个元素分成k个列表，分的方式是先把S2中第一个元素作为列表的第一个元素，然后顺序判断S2后面的元素，如果遇到的元素小于当前列表的最后一个元素，则将其添加到当前列表后面。S2中的元素全部判断完后，从S2中移除掉在当前列表中的元素。然后进行下一轮同样的操作，直到S2中的元素全部被移除。比如S2为5、1、3、2、0、4，则可以分成3个列表，第一个为5、1、0，第二个为3、2，第三个为4。分的过程如下：\n\n<table>\n  <tr>\n    <td>初始S2为</td>\n    <td>5、1、3、2、0、4</td>\n  </tr>\n  <tr>\n    <td>第一轮找到的列表为</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>3、2、4</td>\n  </tr>\n  <tr>\n    <td>第二轮找到的列表为</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>第三轮找到的列表为</td>\n    <td>4</td>\n  </tr>\n</table>\n\n然后就可以从分成的每个列表中找到一个元素，构成我们所要找的最长子列表。找的方式是这样子的：将最后一个列表的第一个元素作为最长子列表的最后一个元素，然后依次往前，在前一个列表中从前往后找到第一个小于这个元素的元素作为当前元素的前一个元素。以上面找到的3个列表为例，过程如下：\n\n<table>\n  <tr>\n    <td>第三个列表</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>4（列表中的第一个元素）</td>\n  </tr>\n  <tr>\n    <td>第二个列表</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>3（列表中第一个小于4的元素）</td>\n  </tr>\n  <tr>\n    <td>第一个列表</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>所找到的元素为</td>\n    <td>1（列表中第一个小于3的元素）</td>\n  </tr>\n  <tr>\n    <td>所要找的最长子列表为</td>\n    <td>1、3、4（将找到的元素反过来）</td>\n  </tr>\n</table>\n\n有几个点需要证明：\n\n1. 最长子列表中的元素一定来自于所分成的不同列表，最长子列表的长度一定小于等于k\n2. 按照上面方式找到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致\n\n证明：\n\n1. 按照定义，分成的每一个列表中元素的先后顺序，跟S2中这些元素的先后顺序一致，但是跟S1中这些元素的先后顺序相反。而最长子列表中元素的先后顺序要满足跟S2和S1中这些元素的先后顺序都一致。如果最长子列表有超过一个元素来自于同一个列表，则来自同一个列表的这几个元素是按照从大到小排列的。但是上面对S1的假设确定了S1中的元素是按照从小往大排列的，矛盾了。所以最长子列表中的元素一定来自于不同的列表，所以最长子列表的长度一定小于等于k。\n2. 根据最长子列表和S2分成的列表的定义，假设找到的某个列表中的元素为a，找到的该列表的上一个列表中的元素为b，则a大于b，所以也就是要证明在S2中a排在b的后面。如果a排在b的前面且a大于b，但是上一个列表中只包含b而不包含a，这说明上一个列表中包含一个小于a但是大于b的元素c，且c排在a的前面。如果是这样的话，那么找到的上一个列表中的元素应该是c而不是b，因为c和b都在上一个列表中且c排在b的前面。所以a只能排在b的后面，因此得到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致。\n\n有了上面的定义，寻找最长子列表的步骤可以分成两步。一是将S2按照上面的分法分成k个列表。二是从这k个列表的最后一个列表开始，从每个列表中取出一个元素，就组成了所要找的最长子列表。\n\n算法实现如下（主要的优化点在如何将S2分成k个列表上面，详情请看注释）：\n\n```js\nfunction getBestList (S2) {\n  // 1. 将S2分成k个列表，时间复杂度O(nlogn)\n  let levelList = [\n    [S2[0]]\n  ]\n  for (let i = 1; i < S2.length; i += 1) {\n    let x = S2[i]\n\n    // 二分法查寻找刚好比x大的那个列表，\n    let start = 0\n    let end = levelList.length - 1\n    // 中间位置\n    let mid = Math.floor((start + end) / 2)\n    // 中间位置对应的列表\n    let level = levelList[mid]\n    // 列表的最小值\n    let min = level[level.length - 1]\n    do {\n      if (x < min) {\n        // 如果当前元素小于中间列表的最后一个元素，\n        // 说明x应该添加到start～mid中的某一个列表中\n        // 所以缩小范围，从start～mid的列表中寻找\n        end = mid\n      } else {\n        // 如果当前元素大于中间列表的最后一个元素，\n        // 说明x不可能添加到start～mid中的任何一个列表中\n        // 所以缩小范围，从mid+1～end的列表中寻找\n        start = mid + 1\n      }\n      mid = Math.floor((start + end) / 2)\n      level = levelList[mid]\n      min = level[level.length - 1]\n    } while (start < end)\n\n    if (x < min) {\n      // 如果停留在的那个列表的最后一个元素大于x，则将x添加到这个列表最后\n      levelList[start].push(x)\n    } else {\n      // 如果大于，说明没有合适的列表可以添加x进去，则在后面新增一个列表并添加x\n      levelList.push([x])\n    }\n  }\n\n  // 2. 从这k个列表中获取最长子列表，时间复杂度O(n)\n  let best = [\n    levelList[levelList.length - 1][0] // 最后一个列表的第一个元素\n  ]\n  for (let i = levelList.length - 2; i >= 0; i -= 1) {\n    let level = levelList[i]\n    for (let j = 0; j < level.length; j += 1) {\n      let x = level[j]\n      if (x < best[best.length - 1]) {\n        // 第一个小于之前找到的元素\n        best.push(x)\n        break\n      }\n    }\n  }\n  // 元素顺序要反转一下\n  best.reverse()\n  return best\n}\n```\n\n用例：\n\n```js\nlet S1 = [0, 1, 2, 3, 4, 5]\nlet S2 = [5, 1, 3, 2, 0, 4]\nlet best = getBestList(S2)\n\nconsole.log(`S1: ${S1}`)\nconsole.log(`S2: ${S2}`)\nconsole.log(`最长子列表为：${best}`)\nconsole.log(`所以进行${S1.length - best.length}次移动可以将S1转换为S2：`)\nlet actions = []\nfor (let i = 0; i < S2.length; i += 1) {\n  let x = S2[i]\n  if (best.indexOf(x) === -1) {\n    if (i === 0) {\n      moveBefore(x, S2[i + 1], S1)\n      actions.push(`将S1中的${x}移动到${S2[i + 1]}的前面，S1变为：${S1}`)\n    } else {\n      moveAfter(x, S2[i - 1], S1)\n      actions.push(`将S1中的${x}移动到${S2[i - 1]}的后面，S1变为：${S1}`)\n    }\n  } else {\n    actions.push(`${x}不需要移动，S1为：${S1}`)\n  }\n}\nactions.forEach((action) => {\n  console.log(`  ${action}`)\n})\n```\n\n运行输出如下：\n\n```\nS1: 0,1,2,3,4,5\nS2: 5,1,3,2,0,4\n最长子列表为：1,3,4\n所以进行3次移动可以将S1转换为S2：\n  将S1中的5移动到1的前面，S1变为：0,5,1,2,3,4\n  1不需要移动，S1为：0,5,1,2,3,4\n  3不需要移动，S1为：0,5,1,2,3,4\n  将S1中的2移动到3的后面，S1变为：0,5,1,3,2,4\n  将S1中的0移动到2的后面，S1变为：5,1,3,2,0,4\n  4不需要移动，S1为：5,1,3,2,0,4\n```\n\n## benchmark\n\n上面提到的新算法虽然总是能找到最长子列表，但是花在寻找上的时间也更多。所以这里需要做一个benchmark，看看新算法**所减少的元素移动时间**和**寻找最长子列表的时间**的大小关系。如果前者多于后者，说明新算法性能更好。\n\n### 测试参数\n\n\n【需要有一个测试实验结果】\n<!-- 经过测试发现，insertBefore的第二个参数也接近结尾性能越好。 -->\n","source":"_drafts/react-2.md","raw":"# 玩转React系列2：寻找更高效的列表更新算法\n\n本文接着上篇《玩转React系列1：React工作原理》最后提到的React列表更新的问题，来深入探讨下是否有更高效的列表更新方式。\n\n## 目录\n\n- 0\\. 问题描述\n- 1\\. 寻找更高效的方法\n- 2\\. benchmark\n\n## 问题描述\n\n上一篇文章最后提到，React更新算法有一个问题，就是选取的不动子列表S可能不是最长的。比如将S1中的最后一个元素e<sub>n</sub>移动到第一个元素e<sub>1</sub>前面，变成S2的情况。React选取的不动子列表只包含最后一个元素e<sub>n</sub>，所以需要移动其他n-1个元素。但实际上可以将[e<sub>1</sub>, ..., e<sub>n-1</sub>]作为不动子列表，从而只需要做一次移动操作，也就是将e<sub>n</sub>移动到e<sub>1</sub>的前面。\n\n本文尝试探索一种新的方法，来减少元素移动的次数。以及做一个基准测试来确定使用新的方法是否更省时。\n\n## 寻找更高效的方法\n\n为了更清晰的讨论这个问题，我们先做一个合理的假设，假设从列表S1（prevChildren）到列表S2（nextChildren），只是子元素的顺序变了，没有新增和删除子元素。这个假设是合理的，因为不管是哪种更新方式，新增和删除的操作都是一样的，不会影响算法复杂度。另外为了描述方便，假设S1和S2中的元素由该元素在S1中的位置（下标）代替，比如如果S1为d、c、a、b，S2为b、a、d、c。换成下标S1就是0、1、2、3（即d在S1中的位置、c在S1中的位置、a在S1中的位置、b在S1中的位置），S2就是3、2、0、1（即b在S1中的位置、a在S1中的位置、d在S1中的位置、c在S1中的位置）。\n\n首先我们将S2中的n个元素分成k个列表，分的方式是先把S2中第一个元素作为列表的第一个元素，然后顺序判断S2后面的元素，如果遇到的元素小于当前列表的最后一个元素，则将其添加到当前列表后面。S2中的元素全部判断完后，从S2中移除掉在当前列表中的元素。然后进行下一轮同样的操作，直到S2中的元素全部被移除。比如S2为5、1、3、2、0、4，则可以分成3个列表，第一个为5、1、0，第二个为3、2，第三个为4。分的过程如下：\n\n<table>\n  <tr>\n    <td>初始S2为</td>\n    <td>5、1、3、2、0、4</td>\n  </tr>\n  <tr>\n    <td>第一轮找到的列表为</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>3、2、4</td>\n  </tr>\n  <tr>\n    <td>第二轮找到的列表为</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>第三轮找到的列表为</td>\n    <td>4</td>\n  </tr>\n</table>\n\n然后就可以从分成的每个列表中找到一个元素，构成我们所要找的最长子列表。找的方式是这样子的：将最后一个列表的第一个元素作为最长子列表的最后一个元素，然后依次往前，在前一个列表中从前往后找到第一个小于这个元素的元素作为当前元素的前一个元素。以上面找到的3个列表为例，过程如下：\n\n<table>\n  <tr>\n    <td>第三个列表</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>4（列表中的第一个元素）</td>\n  </tr>\n  <tr>\n    <td>第二个列表</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>3（列表中第一个小于4的元素）</td>\n  </tr>\n  <tr>\n    <td>第一个列表</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>所找到的元素为</td>\n    <td>1（列表中第一个小于3的元素）</td>\n  </tr>\n  <tr>\n    <td>所要找的最长子列表为</td>\n    <td>1、3、4（将找到的元素反过来）</td>\n  </tr>\n</table>\n\n有几个点需要证明：\n\n1. 最长子列表中的元素一定来自于所分成的不同列表，最长子列表的长度一定小于等于k\n2. 按照上面方式找到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致\n\n证明：\n\n1. 按照定义，分成的每一个列表中元素的先后顺序，跟S2中这些元素的先后顺序一致，但是跟S1中这些元素的先后顺序相反。而最长子列表中元素的先后顺序要满足跟S2和S1中这些元素的先后顺序都一致。如果最长子列表有超过一个元素来自于同一个列表，则来自同一个列表的这几个元素是按照从大到小排列的。但是上面对S1的假设确定了S1中的元素是按照从小往大排列的，矛盾了。所以最长子列表中的元素一定来自于不同的列表，所以最长子列表的长度一定小于等于k。\n2. 根据最长子列表和S2分成的列表的定义，假设找到的某个列表中的元素为a，找到的该列表的上一个列表中的元素为b，则a大于b，所以也就是要证明在S2中a排在b的后面。如果a排在b的前面且a大于b，但是上一个列表中只包含b而不包含a，这说明上一个列表中包含一个小于a但是大于b的元素c，且c排在a的前面。如果是这样的话，那么找到的上一个列表中的元素应该是c而不是b，因为c和b都在上一个列表中且c排在b的前面。所以a只能排在b的后面，因此得到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致。\n\n有了上面的定义，寻找最长子列表的步骤可以分成两步。一是将S2按照上面的分法分成k个列表。二是从这k个列表的最后一个列表开始，从每个列表中取出一个元素，就组成了所要找的最长子列表。\n\n算法实现如下（主要的优化点在如何将S2分成k个列表上面，详情请看注释）：\n\n```js\nfunction getBestList (S2) {\n  // 1. 将S2分成k个列表，时间复杂度O(nlogn)\n  let levelList = [\n    [S2[0]]\n  ]\n  for (let i = 1; i < S2.length; i += 1) {\n    let x = S2[i]\n\n    // 二分法查寻找刚好比x大的那个列表，\n    let start = 0\n    let end = levelList.length - 1\n    // 中间位置\n    let mid = Math.floor((start + end) / 2)\n    // 中间位置对应的列表\n    let level = levelList[mid]\n    // 列表的最小值\n    let min = level[level.length - 1]\n    do {\n      if (x < min) {\n        // 如果当前元素小于中间列表的最后一个元素，\n        // 说明x应该添加到start～mid中的某一个列表中\n        // 所以缩小范围，从start～mid的列表中寻找\n        end = mid\n      } else {\n        // 如果当前元素大于中间列表的最后一个元素，\n        // 说明x不可能添加到start～mid中的任何一个列表中\n        // 所以缩小范围，从mid+1～end的列表中寻找\n        start = mid + 1\n      }\n      mid = Math.floor((start + end) / 2)\n      level = levelList[mid]\n      min = level[level.length - 1]\n    } while (start < end)\n\n    if (x < min) {\n      // 如果停留在的那个列表的最后一个元素大于x，则将x添加到这个列表最后\n      levelList[start].push(x)\n    } else {\n      // 如果大于，说明没有合适的列表可以添加x进去，则在后面新增一个列表并添加x\n      levelList.push([x])\n    }\n  }\n\n  // 2. 从这k个列表中获取最长子列表，时间复杂度O(n)\n  let best = [\n    levelList[levelList.length - 1][0] // 最后一个列表的第一个元素\n  ]\n  for (let i = levelList.length - 2; i >= 0; i -= 1) {\n    let level = levelList[i]\n    for (let j = 0; j < level.length; j += 1) {\n      let x = level[j]\n      if (x < best[best.length - 1]) {\n        // 第一个小于之前找到的元素\n        best.push(x)\n        break\n      }\n    }\n  }\n  // 元素顺序要反转一下\n  best.reverse()\n  return best\n}\n```\n\n用例：\n\n```js\nlet S1 = [0, 1, 2, 3, 4, 5]\nlet S2 = [5, 1, 3, 2, 0, 4]\nlet best = getBestList(S2)\n\nconsole.log(`S1: ${S1}`)\nconsole.log(`S2: ${S2}`)\nconsole.log(`最长子列表为：${best}`)\nconsole.log(`所以进行${S1.length - best.length}次移动可以将S1转换为S2：`)\nlet actions = []\nfor (let i = 0; i < S2.length; i += 1) {\n  let x = S2[i]\n  if (best.indexOf(x) === -1) {\n    if (i === 0) {\n      moveBefore(x, S2[i + 1], S1)\n      actions.push(`将S1中的${x}移动到${S2[i + 1]}的前面，S1变为：${S1}`)\n    } else {\n      moveAfter(x, S2[i - 1], S1)\n      actions.push(`将S1中的${x}移动到${S2[i - 1]}的后面，S1变为：${S1}`)\n    }\n  } else {\n    actions.push(`${x}不需要移动，S1为：${S1}`)\n  }\n}\nactions.forEach((action) => {\n  console.log(`  ${action}`)\n})\n```\n\n运行输出如下：\n\n```\nS1: 0,1,2,3,4,5\nS2: 5,1,3,2,0,4\n最长子列表为：1,3,4\n所以进行3次移动可以将S1转换为S2：\n  将S1中的5移动到1的前面，S1变为：0,5,1,2,3,4\n  1不需要移动，S1为：0,5,1,2,3,4\n  3不需要移动，S1为：0,5,1,2,3,4\n  将S1中的2移动到3的后面，S1变为：0,5,1,3,2,4\n  将S1中的0移动到2的后面，S1变为：5,1,3,2,0,4\n  4不需要移动，S1为：5,1,3,2,0,4\n```\n\n## benchmark\n\n上面提到的新算法虽然总是能找到最长子列表，但是花在寻找上的时间也更多。所以这里需要做一个benchmark，看看新算法**所减少的元素移动时间**和**寻找最长子列表的时间**的大小关系。如果前者多于后者，说明新算法性能更好。\n\n### 测试参数\n\n\n【需要有一个测试实验结果】\n<!-- 经过测试发现，insertBefore的第二个参数也接近结尾性能越好。 -->\n","slug":"react-2","published":0,"date":"2020-11-28T14:29:24.692Z","updated":"2020-11-28T14:29:24.692Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk07001brnq76mtv0mg0","content":"<h1 id=\"玩转React系列2：寻找更高效的列表更新算法\"><a href=\"#玩转React系列2：寻找更高效的列表更新算法\" class=\"headerlink\" title=\"玩转React系列2：寻找更高效的列表更新算法\"></a>玩转React系列2：寻找更高效的列表更新算法</h1><p>本文接着上篇《玩转React系列1：React工作原理》最后提到的React列表更新的问题，来深入探讨下是否有更高效的列表更新方式。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>0. 问题描述</li>\n<li>1. 寻找更高效的方法</li>\n<li>2. benchmark</li>\n</ul>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>上一篇文章最后提到，React更新算法有一个问题，就是选取的不动子列表S可能不是最长的。比如将S1中的最后一个元素e<sub>n</sub>移动到第一个元素e<sub>1</sub>前面，变成S2的情况。React选取的不动子列表只包含最后一个元素e<sub>n</sub>，所以需要移动其他n-1个元素。但实际上可以将[e<sub>1</sub>, …, e<sub>n-1</sub>]作为不动子列表，从而只需要做一次移动操作，也就是将e<sub>n</sub>移动到e<sub>1</sub>的前面。</p>\n<p>本文尝试探索一种新的方法，来减少元素移动的次数。以及做一个基准测试来确定使用新的方法是否更省时。</p>\n<h2 id=\"寻找更高效的方法\"><a href=\"#寻找更高效的方法\" class=\"headerlink\" title=\"寻找更高效的方法\"></a>寻找更高效的方法</h2><p>为了更清晰的讨论这个问题，我们先做一个合理的假设，假设从列表S1（prevChildren）到列表S2（nextChildren），只是子元素的顺序变了，没有新增和删除子元素。这个假设是合理的，因为不管是哪种更新方式，新增和删除的操作都是一样的，不会影响算法复杂度。另外为了描述方便，假设S1和S2中的元素由该元素在S1中的位置（下标）代替，比如如果S1为d、c、a、b，S2为b、a、d、c。换成下标S1就是0、1、2、3（即d在S1中的位置、c在S1中的位置、a在S1中的位置、b在S1中的位置），S2就是3、2、0、1（即b在S1中的位置、a在S1中的位置、d在S1中的位置、c在S1中的位置）。</p>\n<p>首先我们将S2中的n个元素分成k个列表，分的方式是先把S2中第一个元素作为列表的第一个元素，然后顺序判断S2后面的元素，如果遇到的元素小于当前列表的最后一个元素，则将其添加到当前列表后面。S2中的元素全部判断完后，从S2中移除掉在当前列表中的元素。然后进行下一轮同样的操作，直到S2中的元素全部被移除。比如S2为5、1、3、2、0、4，则可以分成3个列表，第一个为5、1、0，第二个为3、2，第三个为4。分的过程如下：</p>\n<table>\n  <tr>\n    <td>初始S2为</td>\n    <td>5、1、3、2、0、4</td>\n  </tr>\n  <tr>\n    <td>第一轮找到的列表为</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>3、2、4</td>\n  </tr>\n  <tr>\n    <td>第二轮找到的列表为</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>第三轮找到的列表为</td>\n    <td>4</td>\n  </tr>\n</table>\n\n<p>然后就可以从分成的每个列表中找到一个元素，构成我们所要找的最长子列表。找的方式是这样子的：将最后一个列表的第一个元素作为最长子列表的最后一个元素，然后依次往前，在前一个列表中从前往后找到第一个小于这个元素的元素作为当前元素的前一个元素。以上面找到的3个列表为例，过程如下：</p>\n<table>\n  <tr>\n    <td>第三个列表</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>4（列表中的第一个元素）</td>\n  </tr>\n  <tr>\n    <td>第二个列表</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>3（列表中第一个小于4的元素）</td>\n  </tr>\n  <tr>\n    <td>第一个列表</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>所找到的元素为</td>\n    <td>1（列表中第一个小于3的元素）</td>\n  </tr>\n  <tr>\n    <td>所要找的最长子列表为</td>\n    <td>1、3、4（将找到的元素反过来）</td>\n  </tr>\n</table>\n\n<p>有几个点需要证明：</p>\n<ol>\n<li>最长子列表中的元素一定来自于所分成的不同列表，最长子列表的长度一定小于等于k</li>\n<li>按照上面方式找到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致</li>\n</ol>\n<p>证明：</p>\n<ol>\n<li>按照定义，分成的每一个列表中元素的先后顺序，跟S2中这些元素的先后顺序一致，但是跟S1中这些元素的先后顺序相反。而最长子列表中元素的先后顺序要满足跟S2和S1中这些元素的先后顺序都一致。如果最长子列表有超过一个元素来自于同一个列表，则来自同一个列表的这几个元素是按照从大到小排列的。但是上面对S1的假设确定了S1中的元素是按照从小往大排列的，矛盾了。所以最长子列表中的元素一定来自于不同的列表，所以最长子列表的长度一定小于等于k。</li>\n<li>根据最长子列表和S2分成的列表的定义，假设找到的某个列表中的元素为a，找到的该列表的上一个列表中的元素为b，则a大于b，所以也就是要证明在S2中a排在b的后面。如果a排在b的前面且a大于b，但是上一个列表中只包含b而不包含a，这说明上一个列表中包含一个小于a但是大于b的元素c，且c排在a的前面。如果是这样的话，那么找到的上一个列表中的元素应该是c而不是b，因为c和b都在上一个列表中且c排在b的前面。所以a只能排在b的后面，因此得到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致。</li>\n</ol>\n<p>有了上面的定义，寻找最长子列表的步骤可以分成两步。一是将S2按照上面的分法分成k个列表。二是从这k个列表的最后一个列表开始，从每个列表中取出一个元素，就组成了所要找的最长子列表。</p>\n<p>算法实现如下（主要的优化点在如何将S2分成k个列表上面，详情请看注释）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBestList</span> (<span class=\"params\">S2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 将S2分成k个列表，时间复杂度O(nlogn)</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> levelList = [</span><br><span class=\"line\">    [S2[<span class=\"number\">0</span>]]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; S2.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = S2[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 二分法查寻找刚好比x大的那个列表，</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> start = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> end = levelList.length - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 中间位置</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((start + end) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 中间位置对应的列表</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> level = levelList[mid]</span><br><span class=\"line\">    <span class=\"comment\">// 列表的最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> min = level[level.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x &lt; min) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素小于中间列表的最后一个元素，</span></span><br><span class=\"line\">        <span class=\"comment\">// 说明x应该添加到start～mid中的某一个列表中</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以缩小范围，从start～mid的列表中寻找</span></span><br><span class=\"line\">        end = mid</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素大于中间列表的最后一个元素，</span></span><br><span class=\"line\">        <span class=\"comment\">// 说明x不可能添加到start～mid中的任何一个列表中</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以缩小范围，从mid+1～end的列表中寻找</span></span><br><span class=\"line\">        start = mid + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mid = <span class=\"built_in\">Math</span>.floor((start + end) / <span class=\"number\">2</span>)</span><br><span class=\"line\">      level = levelList[mid]</span><br><span class=\"line\">      min = level[level.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (start &lt; end)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; min) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果停留在的那个列表的最后一个元素大于x，则将x添加到这个列表最后</span></span><br><span class=\"line\">      levelList[start].push(x)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果大于，说明没有合适的列表可以添加x进去，则在后面新增一个列表并添加x</span></span><br><span class=\"line\">      levelList.push([x])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 从这k个列表中获取最长子列表，时间复杂度O(n)</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> best = [</span><br><span class=\"line\">    levelList[levelList.length - <span class=\"number\">1</span>][<span class=\"number\">0</span>] <span class=\"comment\">// 最后一个列表的第一个元素</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = levelList.length - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i -= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> level = levelList[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; level.length; j += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> x = level[j]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x &lt; best[best.length - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一个小于之前找到的元素</span></span><br><span class=\"line\">        best.push(x)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 元素顺序要反转一下</span></span><br><span class=\"line\">  best.reverse()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> best</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> S1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> S2 = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> best = getBestList(S2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`S1: <span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`S2: <span class=\"subst\">$&#123;S2&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`最长子列表为：<span class=\"subst\">$&#123;best&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`所以进行<span class=\"subst\">$&#123;S1.length - best.length&#125;</span>次移动可以将S1转换为S2：`</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> actions = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; S2.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = S2[i]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (best.indexOf(x) === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      moveBefore(x, S2[i + <span class=\"number\">1</span>], S1)</span><br><span class=\"line\">      actions.push(<span class=\"string\">`将S1中的<span class=\"subst\">$&#123;x&#125;</span>移动到<span class=\"subst\">$&#123;S2[i + <span class=\"number\">1</span>]&#125;</span>的前面，S1变为：<span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      moveAfter(x, S2[i - <span class=\"number\">1</span>], S1)</span><br><span class=\"line\">      actions.push(<span class=\"string\">`将S1中的<span class=\"subst\">$&#123;x&#125;</span>移动到<span class=\"subst\">$&#123;S2[i - <span class=\"number\">1</span>]&#125;</span>的后面，S1变为：<span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    actions.push(<span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>不需要移动，S1为：<span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">actions.forEach(<span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`  <span class=\"subst\">$&#123;action&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>运行输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S1: 0,1,2,3,4,5</span><br><span class=\"line\">S2: 5,1,3,2,0,4</span><br><span class=\"line\">最长子列表为：1,3,4</span><br><span class=\"line\">所以进行3次移动可以将S1转换为S2：</span><br><span class=\"line\">  将S1中的5移动到1的前面，S1变为：0,5,1,2,3,4</span><br><span class=\"line\">  1不需要移动，S1为：0,5,1,2,3,4</span><br><span class=\"line\">  3不需要移动，S1为：0,5,1,2,3,4</span><br><span class=\"line\">  将S1中的2移动到3的后面，S1变为：0,5,1,3,2,4</span><br><span class=\"line\">  将S1中的0移动到2的后面，S1变为：5,1,3,2,0,4</span><br><span class=\"line\">  4不需要移动，S1为：5,1,3,2,0,4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"benchmark\"><a href=\"#benchmark\" class=\"headerlink\" title=\"benchmark\"></a>benchmark</h2><p>上面提到的新算法虽然总是能找到最长子列表，但是花在寻找上的时间也更多。所以这里需要做一个benchmark，看看新算法<strong>所减少的元素移动时间</strong>和<strong>寻找最长子列表的时间</strong>的大小关系。如果前者多于后者，说明新算法性能更好。</p>\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>【需要有一个测试实验结果】</p>\n<!-- 经过测试发现，insertBefore的第二个参数也接近结尾性能越好。 -->\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"玩转React系列2：寻找更高效的列表更新算法\"><a href=\"#玩转React系列2：寻找更高效的列表更新算法\" class=\"headerlink\" title=\"玩转React系列2：寻找更高效的列表更新算法\"></a>玩转React系列2：寻找更高效的列表更新算法</h1><p>本文接着上篇《玩转React系列1：React工作原理》最后提到的React列表更新的问题，来深入探讨下是否有更高效的列表更新方式。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>0. 问题描述</li>\n<li>1. 寻找更高效的方法</li>\n<li>2. benchmark</li>\n</ul>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>上一篇文章最后提到，React更新算法有一个问题，就是选取的不动子列表S可能不是最长的。比如将S1中的最后一个元素e<sub>n</sub>移动到第一个元素e<sub>1</sub>前面，变成S2的情况。React选取的不动子列表只包含最后一个元素e<sub>n</sub>，所以需要移动其他n-1个元素。但实际上可以将[e<sub>1</sub>, …, e<sub>n-1</sub>]作为不动子列表，从而只需要做一次移动操作，也就是将e<sub>n</sub>移动到e<sub>1</sub>的前面。</p>\n<p>本文尝试探索一种新的方法，来减少元素移动的次数。以及做一个基准测试来确定使用新的方法是否更省时。</p>\n<h2 id=\"寻找更高效的方法\"><a href=\"#寻找更高效的方法\" class=\"headerlink\" title=\"寻找更高效的方法\"></a>寻找更高效的方法</h2><p>为了更清晰的讨论这个问题，我们先做一个合理的假设，假设从列表S1（prevChildren）到列表S2（nextChildren），只是子元素的顺序变了，没有新增和删除子元素。这个假设是合理的，因为不管是哪种更新方式，新增和删除的操作都是一样的，不会影响算法复杂度。另外为了描述方便，假设S1和S2中的元素由该元素在S1中的位置（下标）代替，比如如果S1为d、c、a、b，S2为b、a、d、c。换成下标S1就是0、1、2、3（即d在S1中的位置、c在S1中的位置、a在S1中的位置、b在S1中的位置），S2就是3、2、0、1（即b在S1中的位置、a在S1中的位置、d在S1中的位置、c在S1中的位置）。</p>\n<p>首先我们将S2中的n个元素分成k个列表，分的方式是先把S2中第一个元素作为列表的第一个元素，然后顺序判断S2后面的元素，如果遇到的元素小于当前列表的最后一个元素，则将其添加到当前列表后面。S2中的元素全部判断完后，从S2中移除掉在当前列表中的元素。然后进行下一轮同样的操作，直到S2中的元素全部被移除。比如S2为5、1、3、2、0、4，则可以分成3个列表，第一个为5、1、0，第二个为3、2，第三个为4。分的过程如下：</p>\n<table>\n  <tr>\n    <td>初始S2为</td>\n    <td>5、1、3、2、0、4</td>\n  </tr>\n  <tr>\n    <td>第一轮找到的列表为</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>3、2、4</td>\n  </tr>\n  <tr>\n    <td>第二轮找到的列表为</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>移除掉找到的元素后S2为</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>第三轮找到的列表为</td>\n    <td>4</td>\n  </tr>\n</table>\n\n<p>然后就可以从分成的每个列表中找到一个元素，构成我们所要找的最长子列表。找的方式是这样子的：将最后一个列表的第一个元素作为最长子列表的最后一个元素，然后依次往前，在前一个列表中从前往后找到第一个小于这个元素的元素作为当前元素的前一个元素。以上面找到的3个列表为例，过程如下：</p>\n<table>\n  <tr>\n    <td>第三个列表</td>\n    <td>4</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>4（列表中的第一个元素）</td>\n  </tr>\n  <tr>\n    <td>第二个列表</td>\n    <td>3、2</td>\n  </tr>\n  <tr>\n    <td>所以找到的元素为</td>\n    <td>3（列表中第一个小于4的元素）</td>\n  </tr>\n  <tr>\n    <td>第一个列表</td>\n    <td>5、1、0</td>\n  </tr>\n  <tr>\n    <td>所找到的元素为</td>\n    <td>1（列表中第一个小于3的元素）</td>\n  </tr>\n  <tr>\n    <td>所要找的最长子列表为</td>\n    <td>1、3、4（将找到的元素反过来）</td>\n  </tr>\n</table>\n\n<p>有几个点需要证明：</p>\n<ol>\n<li>最长子列表中的元素一定来自于所分成的不同列表，最长子列表的长度一定小于等于k</li>\n<li>按照上面方式找到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致</li>\n</ol>\n<p>证明：</p>\n<ol>\n<li>按照定义，分成的每一个列表中元素的先后顺序，跟S2中这些元素的先后顺序一致，但是跟S1中这些元素的先后顺序相反。而最长子列表中元素的先后顺序要满足跟S2和S1中这些元素的先后顺序都一致。如果最长子列表有超过一个元素来自于同一个列表，则来自同一个列表的这几个元素是按照从大到小排列的。但是上面对S1的假设确定了S1中的元素是按照从小往大排列的，矛盾了。所以最长子列表中的元素一定来自于不同的列表，所以最长子列表的长度一定小于等于k。</li>\n<li>根据最长子列表和S2分成的列表的定义，假设找到的某个列表中的元素为a，找到的该列表的上一个列表中的元素为b，则a大于b，所以也就是要证明在S2中a排在b的后面。如果a排在b的前面且a大于b，但是上一个列表中只包含b而不包含a，这说明上一个列表中包含一个小于a但是大于b的元素c，且c排在a的前面。如果是这样的话，那么找到的上一个列表中的元素应该是c而不是b，因为c和b都在上一个列表中且c排在b的前面。所以a只能排在b的后面，因此得到的最长子列表中元素的先后顺序跟S2中这些元素的先后顺序一致。</li>\n</ol>\n<p>有了上面的定义，寻找最长子列表的步骤可以分成两步。一是将S2按照上面的分法分成k个列表。二是从这k个列表的最后一个列表开始，从每个列表中取出一个元素，就组成了所要找的最长子列表。</p>\n<p>算法实现如下（主要的优化点在如何将S2分成k个列表上面，详情请看注释）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBestList</span> (<span class=\"params\">S2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 将S2分成k个列表，时间复杂度O(nlogn)</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> levelList = [</span><br><span class=\"line\">    [S2[<span class=\"number\">0</span>]]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; S2.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = S2[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 二分法查寻找刚好比x大的那个列表，</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> start = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> end = levelList.length - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 中间位置</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((start + end) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 中间位置对应的列表</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> level = levelList[mid]</span><br><span class=\"line\">    <span class=\"comment\">// 列表的最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> min = level[level.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x &lt; min) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素小于中间列表的最后一个元素，</span></span><br><span class=\"line\">        <span class=\"comment\">// 说明x应该添加到start～mid中的某一个列表中</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以缩小范围，从start～mid的列表中寻找</span></span><br><span class=\"line\">        end = mid</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素大于中间列表的最后一个元素，</span></span><br><span class=\"line\">        <span class=\"comment\">// 说明x不可能添加到start～mid中的任何一个列表中</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以缩小范围，从mid+1～end的列表中寻找</span></span><br><span class=\"line\">        start = mid + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      mid = <span class=\"built_in\">Math</span>.floor((start + end) / <span class=\"number\">2</span>)</span><br><span class=\"line\">      level = levelList[mid]</span><br><span class=\"line\">      min = level[level.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (start &lt; end)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; min) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果停留在的那个列表的最后一个元素大于x，则将x添加到这个列表最后</span></span><br><span class=\"line\">      levelList[start].push(x)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果大于，说明没有合适的列表可以添加x进去，则在后面新增一个列表并添加x</span></span><br><span class=\"line\">      levelList.push([x])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 从这k个列表中获取最长子列表，时间复杂度O(n)</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> best = [</span><br><span class=\"line\">    levelList[levelList.length - <span class=\"number\">1</span>][<span class=\"number\">0</span>] <span class=\"comment\">// 最后一个列表的第一个元素</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = levelList.length - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i -= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> level = levelList[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; level.length; j += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> x = level[j]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x &lt; best[best.length - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一个小于之前找到的元素</span></span><br><span class=\"line\">        best.push(x)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 元素顺序要反转一下</span></span><br><span class=\"line\">  best.reverse()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> best</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> S1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> S2 = [<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> best = getBestList(S2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`S1: <span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`S2: <span class=\"subst\">$&#123;S2&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`最长子列表为：<span class=\"subst\">$&#123;best&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`所以进行<span class=\"subst\">$&#123;S1.length - best.length&#125;</span>次移动可以将S1转换为S2：`</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> actions = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; S2.length; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = S2[i]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (best.indexOf(x) === -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      moveBefore(x, S2[i + <span class=\"number\">1</span>], S1)</span><br><span class=\"line\">      actions.push(<span class=\"string\">`将S1中的<span class=\"subst\">$&#123;x&#125;</span>移动到<span class=\"subst\">$&#123;S2[i + <span class=\"number\">1</span>]&#125;</span>的前面，S1变为：<span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      moveAfter(x, S2[i - <span class=\"number\">1</span>], S1)</span><br><span class=\"line\">      actions.push(<span class=\"string\">`将S1中的<span class=\"subst\">$&#123;x&#125;</span>移动到<span class=\"subst\">$&#123;S2[i - <span class=\"number\">1</span>]&#125;</span>的后面，S1变为：<span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    actions.push(<span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>不需要移动，S1为：<span class=\"subst\">$&#123;S1&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">actions.forEach(<span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`  <span class=\"subst\">$&#123;action&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>运行输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S1: 0,1,2,3,4,5</span><br><span class=\"line\">S2: 5,1,3,2,0,4</span><br><span class=\"line\">最长子列表为：1,3,4</span><br><span class=\"line\">所以进行3次移动可以将S1转换为S2：</span><br><span class=\"line\">  将S1中的5移动到1的前面，S1变为：0,5,1,2,3,4</span><br><span class=\"line\">  1不需要移动，S1为：0,5,1,2,3,4</span><br><span class=\"line\">  3不需要移动，S1为：0,5,1,2,3,4</span><br><span class=\"line\">  将S1中的2移动到3的后面，S1变为：0,5,1,3,2,4</span><br><span class=\"line\">  将S1中的0移动到2的后面，S1变为：5,1,3,2,0,4</span><br><span class=\"line\">  4不需要移动，S1为：5,1,3,2,0,4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"benchmark\"><a href=\"#benchmark\" class=\"headerlink\" title=\"benchmark\"></a>benchmark</h2><p>上面提到的新算法虽然总是能找到最长子列表，但是花在寻找上的时间也更多。所以这里需要做一个benchmark，看看新算法<strong>所减少的元素移动时间</strong>和<strong>寻找最长子列表的时间</strong>的大小关系。如果前者多于后者，说明新算法性能更好。</p>\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>【需要有一个测试实验结果】</p>\n<!-- 经过测试发现，insertBefore的第二个参数也接近结尾性能越好。 -->\n"},{"title":"俄罗斯方块游戏规则整理","date":"2020-11-01T09:07:19.043Z","excerpt":"按：本文记录我在完成 Nand2Tetris Part2 课程中的Project3，开发一个俄罗斯方块游戏时做的俄罗斯方块游戏规则整理。主要参考的是《2009 Tetris Design Guideline》。","_content":"\n\n\n1. 基本情况：\n\n   1. 格子尺寸：10*20\n   2. 方块种类：O、I、T、L、J、S、Z\n\n2. 动作：\n\n   1. 左右移动（Movement）：向左和向右方向键\n   2. 软着陆（Soft Drop）：向下方向键\n   3. 硬着陆（Hard Drop）：空格键\n   4. 旋转（Rotation）：向上方向键（顺时间旋转）\n   5. 暂停（Pause）：Esc\n\n3. 超级旋转系统：\n\n   方位：\n\n   <img src=\"tetris.assets/image-20200728000757270.png\" alt=\"image-20200728000757270\" style=\"zoom:50%;\" />\n\n   1. \n\n4. 等级（15个等级，每个等级的目标为清除10行）：\n\n   1. normal-fall-speed = (0.8 - ((level - 1) * 0.007))^ (level-1)\n   2. soft-drop-speed = 20*normal-fall-speed\n   3. hard-drop-speed = 0.0001\n   4. lock delay = 0.50（如果是hard drop情况，则为0）\n   5. generate time = 0.2\n\n   ![image-20200726235018598](tetris.assets/image-20200726235018598.png)\n\n5. 记分系统（level为当前等级，n为下落格子数）：\n\n   1. 消除单行，Single：100*level\n   2. 消除双行，Double：300*level\n   3. 消除三行，Triple：500*level\n   4. 消除四行，Tetris：800*level\n   5. 软着陆：1*n\n   6. 硬着陆：2*n\n\n### 超级旋转系统（Super Rotation System）\n\n![image-20200728001916873](tetris.assets/image-20200728001916873.png)\n\n![image-20200728002438656](tetris.assets/image-20200728002438656.png)\n\n![image-20200728002726065](tetris.assets/image-20200728002726065.png)\n\n\n\n![image-20200728233251358](tetris.assets/image-20200728233251358.png)\n\n![image-20200728233318286](tetris.assets/image-20200728233318286.png)\n\n![image-20200728233340150](tetris.assets/image-20200728233340150.png)\n\n![image-20200728233359263](tetris.assets/image-20200728233359263.png)\n\n![image-20200728233415881](tetris.assets/image-20200728233415881.png)\n\n![image-20200728233431364](tetris.assets/image-20200728233431364.png)\n\n![image-20200728233447992](tetris.assets/image-20200728233447992.png)\n\n![image-20200729002721907](tetris.assets/image-20200729002721907.png)","source":"_drafts/tetris.md","raw":"---\ntitle: 俄罗斯方块游戏规则整理\ndate: 2020/07/xx\ntag:\n- 笔记\ncategory:\n- 笔记\nexcerpt: 按：本文记录我在完成 Nand2Tetris Part2 课程中的Project3，开发一个俄罗斯方块游戏时做的俄罗斯方块游戏规则整理。主要参考的是《2009 Tetris Design Guideline》。\n---\n\n\n\n1. 基本情况：\n\n   1. 格子尺寸：10*20\n   2. 方块种类：O、I、T、L、J、S、Z\n\n2. 动作：\n\n   1. 左右移动（Movement）：向左和向右方向键\n   2. 软着陆（Soft Drop）：向下方向键\n   3. 硬着陆（Hard Drop）：空格键\n   4. 旋转（Rotation）：向上方向键（顺时间旋转）\n   5. 暂停（Pause）：Esc\n\n3. 超级旋转系统：\n\n   方位：\n\n   <img src=\"tetris.assets/image-20200728000757270.png\" alt=\"image-20200728000757270\" style=\"zoom:50%;\" />\n\n   1. \n\n4. 等级（15个等级，每个等级的目标为清除10行）：\n\n   1. normal-fall-speed = (0.8 - ((level - 1) * 0.007))^ (level-1)\n   2. soft-drop-speed = 20*normal-fall-speed\n   3. hard-drop-speed = 0.0001\n   4. lock delay = 0.50（如果是hard drop情况，则为0）\n   5. generate time = 0.2\n\n   ![image-20200726235018598](tetris.assets/image-20200726235018598.png)\n\n5. 记分系统（level为当前等级，n为下落格子数）：\n\n   1. 消除单行，Single：100*level\n   2. 消除双行，Double：300*level\n   3. 消除三行，Triple：500*level\n   4. 消除四行，Tetris：800*level\n   5. 软着陆：1*n\n   6. 硬着陆：2*n\n\n### 超级旋转系统（Super Rotation System）\n\n![image-20200728001916873](tetris.assets/image-20200728001916873.png)\n\n![image-20200728002438656](tetris.assets/image-20200728002438656.png)\n\n![image-20200728002726065](tetris.assets/image-20200728002726065.png)\n\n\n\n![image-20200728233251358](tetris.assets/image-20200728233251358.png)\n\n![image-20200728233318286](tetris.assets/image-20200728233318286.png)\n\n![image-20200728233340150](tetris.assets/image-20200728233340150.png)\n\n![image-20200728233359263](tetris.assets/image-20200728233359263.png)\n\n![image-20200728233415881](tetris.assets/image-20200728233415881.png)\n\n![image-20200728233431364](tetris.assets/image-20200728233431364.png)\n\n![image-20200728233447992](tetris.assets/image-20200728233447992.png)\n\n![image-20200729002721907](tetris.assets/image-20200729002721907.png)","slug":"tetris","published":0,"updated":"2020-11-01T09:07:19.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk08001ernq70xbs03t7","content":"<ol>\n<li><p>基本情况：</p>\n<ol>\n<li>格子尺寸：10*20</li>\n<li>方块种类：O、I、T、L、J、S、Z</li>\n</ol>\n</li>\n<li><p>动作：</p>\n<ol>\n<li>左右移动（Movement）：向左和向右方向键</li>\n<li>软着陆（Soft Drop）：向下方向键</li>\n<li>硬着陆（Hard Drop）：空格键</li>\n<li>旋转（Rotation）：向上方向键（顺时间旋转）</li>\n<li>暂停（Pause）：Esc</li>\n</ol>\n</li>\n<li><p>超级旋转系统：</p>\n<p>方位：</p>\n<img src=\"tetris.assets/image-20200728000757270.png\" alt=\"image-20200728000757270\" style=\"zoom:50%;\" />\n\n<ol>\n<li></li>\n</ol>\n</li>\n<li><p>等级（15个等级，每个等级的目标为清除10行）：</p>\n<ol>\n<li>normal-fall-speed = (0.8 - ((level - 1) * 0.007))^ (level-1)</li>\n<li>soft-drop-speed = 20*normal-fall-speed</li>\n<li>hard-drop-speed = 0.0001</li>\n<li>lock delay = 0.50（如果是hard drop情况，则为0）</li>\n<li>generate time = 0.2</li>\n</ol>\n<p><img src=\"tetris.assets/image-20200726235018598.png\" alt=\"image-20200726235018598\"></p>\n</li>\n<li><p>记分系统（level为当前等级，n为下落格子数）：</p>\n<ol>\n<li>消除单行，Single：100*level</li>\n<li>消除双行，Double：300*level</li>\n<li>消除三行，Triple：500*level</li>\n<li>消除四行，Tetris：800*level</li>\n<li>软着陆：1*n</li>\n<li>硬着陆：2*n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"超级旋转系统（Super-Rotation-System）\"><a href=\"#超级旋转系统（Super-Rotation-System）\" class=\"headerlink\" title=\"超级旋转系统（Super Rotation System）\"></a>超级旋转系统（Super Rotation System）</h3><p><img src=\"tetris.assets/image-20200728001916873.png\" alt=\"image-20200728001916873\"></p>\n<p><img src=\"tetris.assets/image-20200728002438656.png\" alt=\"image-20200728002438656\"></p>\n<p><img src=\"tetris.assets/image-20200728002726065.png\" alt=\"image-20200728002726065\"></p>\n<p><img src=\"tetris.assets/image-20200728233251358.png\" alt=\"image-20200728233251358\"></p>\n<p><img src=\"tetris.assets/image-20200728233318286.png\" alt=\"image-20200728233318286\"></p>\n<p><img src=\"tetris.assets/image-20200728233340150.png\" alt=\"image-20200728233340150\"></p>\n<p><img src=\"tetris.assets/image-20200728233359263.png\" alt=\"image-20200728233359263\"></p>\n<p><img src=\"tetris.assets/image-20200728233415881.png\" alt=\"image-20200728233415881\"></p>\n<p><img src=\"tetris.assets/image-20200728233431364.png\" alt=\"image-20200728233431364\"></p>\n<p><img src=\"tetris.assets/image-20200728233447992.png\" alt=\"image-20200728233447992\"></p>\n<p><img src=\"tetris.assets/image-20200729002721907.png\" alt=\"image-20200729002721907\"></p>\n","site":{"data":{}},"more":"<ol>\n<li><p>基本情况：</p>\n<ol>\n<li>格子尺寸：10*20</li>\n<li>方块种类：O、I、T、L、J、S、Z</li>\n</ol>\n</li>\n<li><p>动作：</p>\n<ol>\n<li>左右移动（Movement）：向左和向右方向键</li>\n<li>软着陆（Soft Drop）：向下方向键</li>\n<li>硬着陆（Hard Drop）：空格键</li>\n<li>旋转（Rotation）：向上方向键（顺时间旋转）</li>\n<li>暂停（Pause）：Esc</li>\n</ol>\n</li>\n<li><p>超级旋转系统：</p>\n<p>方位：</p>\n<img src=\"tetris.assets/image-20200728000757270.png\" alt=\"image-20200728000757270\" style=\"zoom:50%;\" />\n\n<ol>\n<li></li>\n</ol>\n</li>\n<li><p>等级（15个等级，每个等级的目标为清除10行）：</p>\n<ol>\n<li>normal-fall-speed = (0.8 - ((level - 1) * 0.007))^ (level-1)</li>\n<li>soft-drop-speed = 20*normal-fall-speed</li>\n<li>hard-drop-speed = 0.0001</li>\n<li>lock delay = 0.50（如果是hard drop情况，则为0）</li>\n<li>generate time = 0.2</li>\n</ol>\n<p><img src=\"tetris.assets/image-20200726235018598.png\" alt=\"image-20200726235018598\"></p>\n</li>\n<li><p>记分系统（level为当前等级，n为下落格子数）：</p>\n<ol>\n<li>消除单行，Single：100*level</li>\n<li>消除双行，Double：300*level</li>\n<li>消除三行，Triple：500*level</li>\n<li>消除四行，Tetris：800*level</li>\n<li>软着陆：1*n</li>\n<li>硬着陆：2*n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"超级旋转系统（Super-Rotation-System）\"><a href=\"#超级旋转系统（Super-Rotation-System）\" class=\"headerlink\" title=\"超级旋转系统（Super Rotation System）\"></a>超级旋转系统（Super Rotation System）</h3><p><img src=\"tetris.assets/image-20200728001916873.png\" alt=\"image-20200728001916873\"></p>\n<p><img src=\"tetris.assets/image-20200728002438656.png\" alt=\"image-20200728002438656\"></p>\n<p><img src=\"tetris.assets/image-20200728002726065.png\" alt=\"image-20200728002726065\"></p>\n<p><img src=\"tetris.assets/image-20200728233251358.png\" alt=\"image-20200728233251358\"></p>\n<p><img src=\"tetris.assets/image-20200728233318286.png\" alt=\"image-20200728233318286\"></p>\n<p><img src=\"tetris.assets/image-20200728233340150.png\" alt=\"image-20200728233340150\"></p>\n<p><img src=\"tetris.assets/image-20200728233359263.png\" alt=\"image-20200728233359263\"></p>\n<p><img src=\"tetris.assets/image-20200728233415881.png\" alt=\"image-20200728233415881\"></p>\n<p><img src=\"tetris.assets/image-20200728233431364.png\" alt=\"image-20200728233431364\"></p>\n<p><img src=\"tetris.assets/image-20200728233447992.png\" alt=\"image-20200728233447992\"></p>\n<p><img src=\"tetris.assets/image-20200729002721907.png\" alt=\"image-20200729002721907\"></p>\n"},{"title":"《经济解释》卷一《科学说需求》","date":"2016-09-21T16:00:00.000Z","excerpt":"本文为我阅读《经济解释》四卷本的第一卷《科学说需求》的读书笔记。","_content":"\n本文为我阅读《经济解释》四卷本的第一卷《科学说需求》的读书笔记。\n\n## 第一章：科学的方法\n\n对于什么是科学？什么是科学的方法？我从来没有思考过。在《经济解释》四卷本的第一卷《科学说需求》的第一章《科学的方法》中，张五常先生专门表达了他对科学和科学的方法的看法。本文是我对这一章的总结。\n\n科学是有系统地解释现象的学问。感情的表达是艺术，理智的分析却是科学了。在追求科学的过程中，我们应该将感情和理智区分清楚，不能用主观的喜恶作为科学上的结论。\n\n现象必有规律，不管是大自然的还是人为的。科学的形成是基于三个重要的信念。一是现象或行为的存在是主观的判断，而我们不能在这上面有所分歧；二是任何现象都一定有迹可寻；三是我们必须坚信现象的发生一定有原因。\n\n事实不能解释事实，否则会有困难出现。在科学上，现像、事实、行为或观察所得是同一回事，解释现象往往需要非事实的抽象理论。\n\n有些理论是没有解释能力的，比如特殊理论和套套逻辑。前一种指理论特殊到只能解释某一种现象，解释力非常小，代价很高。被推翻的理论，总可以多加条件来挽救。挽救的代价是减少理论的解释能力。科学的进步，不是因为对的理论替代了错的，而是有较为广泛解释力的，替代了较窄的；后一种指理论不可能错，连想象的错都不可能，内容是空洞的，没有解释力。但是有时对套套逻辑加上一些条件，可以促成一个有很强解释力的理论。\n\n理论用于推测和解释现象，最重要的一点是理论的推测一定要“可能被事实推翻”。可能被事实推翻而没有被推翻，就算是被证实了。不能被事实推翻的理论没有解释能力。一个可能被事实推翻的理论，一定要可以在想象中是错的。\n\n除了套套逻辑，还有四种情况会使一个理论免于被事实推翻的可能。一是概念或分析模糊不清，不可能清楚地错，所以不可能清楚地被事实推翻；二是相互矛盾的理论；三是理论的推测不能被观察到；四是理论推测会发生的现象没有限制。\n\n因为事实不能以事实解释，以理论解释现象，在某种程度上一定是抽象的。理论有四种非真实，前三种可以接受。一是理论本身必定有抽象的成分，因为事实不能解释事实；二是事实或观察的描述必须经过简化，减少对无关属性的描述；三是为便于处理而作简化，减少无关现象所带来的复杂；四是验证条件的假设，虽为假设，却不能脱离现实。\n\n推测与解释是同一回事，但有事前与事后之分。\n\n读完该章，我决定在以后的讨论和分析中，对感性和理性一定要加以判断区分。如果是讨论一些主观上的东西，大可不必浪费时间去争论，此时最需要的是尊重他人的喜恶。但是，如果是讨论一些客观的，科学的东西，我应该秉着科学的态度，减小感情方面的因素所带来的影响。比如跟我讨论的那个人我不喜欢或嫉妒，又或者为了面子而坚持自己的想法肯定正确，别人的想法肯定错误。\n\n在解释某个理论或思想时，使用一些贴切的例子可以达到事半功倍的效果。这是我以后写文章需要加强的地方。\n\n## 第二章：从自私说起\n\n在这一章，张老指出了经济学最重要的几个基础假设。\n\n一，“个人”是所有经济分析的基本单位。这是因为所有取舍或选择都是由个人做主的。“人会做选择”。经济学的第一个公理是任何人的行为，都是由个人作出可以被推测的选择而起。\n\n二，每个人的任何行为，都是自私自利的。重要的不是人究竟是怎样，而是我们要假设人是怎样。然后以这个假设为出发点去推测事实。任何的行为都需要使用自私自利这个假设来解释，但解释时需要加入一些局限条件，否则就成了没有内容的套套逻辑。\n\n人的自私本质，来源于斯密的自然淘汰观。斯密指出了自私可以给社会整体带来巨大的利益，但却轻视了自私也会给社会带来害处。这是张老的重点。\n\n假若人的本质是自私的不能更改，那么一个基于人的自私可以被更改的“主义”，其制度政策会失败。\n\n说过了，这里说的“自私”是“局限下争取个人利益极大化”的简称，是个假设，毫无价值观，是好是坏无关宏旨也。\n\n## 第三章：缺乏与竞争\n\n在这一章中，张老讲了经济学中的两个不可或缺的概念：缺乏与竞争。\n\n以理论来解释行为，行为一定要受到理论的约束。\n\n凡是有胜于无的东西，不管有形或无形，都是物品。物品又可以分为两大类：其一是经济物品；其二是免费物品。在有胜于无之中，有一大部分是多胜于少的，其为经济物品。\n\n“多胜于少”是经济物品的定义，也是“缺乏”的定义。“缺乏”是因为在需求下，供应有限而引起的。凡是有人愿意付出或多或少的代价来争取多一点的物品，都是缺乏的、不足够的，那就是经济物品了。\n\n竞争的定义，是指一种经济物品的需求有多于一人的需求。因为缺乏而引起的竞争，跟任何运动一样，是要有游戏规则的。产权制度是竞争的游戏规则，也就是约束行为的一种局限条件。阿尔钦说得好，“产”、竞争、缺乏这三个词是同义的。\n\n在自由市场，价高者得，市价于是成为决定胜负的准则。促成这市价的游戏规则，是私有产权的制度。\n\n张老认为准则在先而游戏规则在后。因为决定胜负的准则所决定的，是人类以竞争来解决的问题，而游戏规则只不过是协助准则的成立而已。\n\n因为竞争准则对人的收入、享受有决定性的作用，所以在不同的准则下，人的行为会跟着不同。\n\n一般书本说的、比较容易明白但不大正确的浪费概念：一般而言，浪费是指有其他办法，或用其他资源使用的分配，可使社会的财富或收入增加，但这些“其他”办法却莫名其妙地不予采用。\n\n唯一没有浪费的竞争准则，是市价。\n\n在不同的竞争准则下，胜或负的人各各不同。一些人喜欢选择某一种准则，另一些人会选择另一种。这些行为属于经济学的范畴。但哪一种准则是好是坏，或对社会福利有何好处，则是伦理或价值观的事。\n\n经济学不能判断什么是好是坏。经济学的范畴包括三部分。\n\n第一，在知道有关的局限条件或游戏规则（即产权制度或人与人之间的权利划分）的情况下，推断所用的竞争准则是什么。\n\n第二，在有了竞争的准则的情况下，推断人的行为会怎样，资源的使用会怎样，财富或收入的分配会怎样。\n\n第三，解释游戏规则是怎样形成的。\n\n## 第四章：功用的理念\n\n在这一章中，张老反对功用理论。其主要原因是，“功用”只不过是经济学者想象出来的概念，不是事实，所以要推断出可以被事实验证的含意不仅困难，而且陷阱太多，以致推出来的很容易是套套逻辑。\n\n“功用”是武断地以数字排列选择的定名。引入“功用”只是为了给各种选择一个名称，方便描述选择。\n\n替换定理：每一个人都愿意牺牲任何物品来换取任何其他的物品，只要牺牲的够少，而换得的够多。\n\n“等优曲线”就是根据替换定理推出的，关于两种经济物品在这些点上的功用数字相同的曲线。（不明白以甲乙的什么为横纵轴。功用？）\n\n再增加行为约束，则等优曲线一定是内凸（向左下弯曲）的。因为假设功用数字不变（在同一等优曲线上），一个人拥有甲物品愈多，其意愿以乙物品替换甲物品的意图必定下降。\n\n收入增加而需求量减少的物品，称为贫穷物品。某物品的价格下降带来的实质收入增加，导致该物品的需求量下降，称为吉芬物品。吉芬物品只能在一人世界存在，不可能在有竞争的社会存在。\n\n对于不能在市场成交或无从以金钱度量的经济物品，可以用其代价做替换，从而完全抛弃功用理论。\n\n## 第五章：需求定律\n\n在这一章中，张老讲解了需求定理的定义和应用。\n\n需求定律是说任何物品的价格下降，其需求量必定上升。\n\n前一章的功用分析推不出一条一定向右下倾斜的需求曲线，无法推出需求定律。对于没有市价的物品，我们可以用代价或牺牲替换，需求定律依然可用。\n\n需求量是指需求者的意图之量，在真实世界不存在。因此，我们必须加上其他的验证条件（可以观察到的局限条件的转变），才可以用需求定律推出可以被事实验证的假说。\n\n关于观察，有三类。第一类是无从观察的，实际上不存在，比如需求量。第二类是可以观察到的真有其物，比如价格。第三类是原则上可以观察到，但实际上观察很困难，我们要想办法找寻间接的替代来作验证，比如边际产量。\n\n解释行为需要以事实验证假说，真实世界不存在的变量或术语愈少愈好。说故事与科学解释是两回事。\n\n以一种物品来说，除了这物品的价格与需求量这两个变量之外，可以影响该物品的需求量的其他变量或因素数之不尽。其他可变但假设不变的量称为参数。要维护需求定律的解释里，哪些量可变哪些量不可变是大话题。\n\n需求定律约束着价格或代价（一个变量）与需求量（另一个变量）之间的关系。然而，可以影响需求量的因素多如天上星，价格只是其中之一罢了。\n\n其他不变量的选择准则：只要需求定律的验证含意不被事实推翻，其他的不变因素愈少愈好——其他可变量愈多愈好——因为这会增加需求定律的解释现象的广泛性。\n\n在该准则下，如下的三项“不变”与“变”的界定是“安全”的——安全者，不被事实推翻也。\n\n（一）凡是直接影响价格的其他因素皆可变。\n（二）凡是直接影响需求量的其他因素皆不可变。\n（三）价格转变会导致需求量的转变，这价格转变也可能导致其他因素的转变，而这些“其他因素”可能再影响需求量。这些在“中间”的、间接地影响需求量的因素（变量）皆可变。\n\n要以需求定律解释行为，应该假设每个人的品味不变。以品味解释行为的困难是我们不是上帝，不能判断一个人的品味是怎样的，也不能判断这个人的品味是否改变了。即使我们知道品味是什么，如何变化。但是这时我们仍然需要知道品味转变的原因，但如果知道成因，我们根本无须提及品味的转变。\n\n斯密指出价值有两种，其一是用值，其二是换值。顾名思义，用值是某物品给予拥有者或享有者的最高所值，或这个人愿意付出的最高代价。换值是获取该物品时所需要付出的代价，而在市场上，换值就是该物品的市价了。\n\n何为价？价是一个消费者对某物品在边际上所愿意付出的最高代价。\n\n某物品的边际用值比市价高，消费者会多够一点；若比市价低，这消费者当然不会购买。这是个人争取最大利益的假设使然。\n\n何为量？成交量和需求量是两回事。成交量是事实，是可以观察到的。需求量不是事实，无从观察，是个概念，没有经济学者“需求量”是不存在的。\n\n概念上，需求量是指在不同的价格（换值）下，消费者意图换取的最高的量。需求曲线于是成为在不同价格下最高的不同需求量的界线。\n\n量，可分为“有质”的与“委托”的两大类，也有两者的合并。凡是质量被直接度量而算价的，是有质的量。相反则为委托的量。\n\n需求定律永远用于价格及其直接联系着的量之间的关系。（说白了就是价格体现在物品的什么上，是物品的重量，还是物品的数量）\n\n用值与换值的差额就是消费者的盈余。因为顾客的需求曲线各个不同，多些不同的收费安排，榨取消费者盈余可以“榨”得“尽”一点。\n\n价格下降，购买者对该物品的消费总额可能下降也可能上升。从出售者那边看，减价后的收入可能下降也可能上升。其决定关键是需求的价格弹性。要记着，价格弹性系数是从一个价位来算的。一条需求曲线有数之不尽的价位，价格弹性系数可以价价不同：曲线上某部分的弹性系数大于一，某部分小于一。\n\n阿尔钦与施蒂格勒提出需求第二定律：弹性系数的大小与时间是正相关的。他们认为，找寻替代物品来替换是需要时间的。时间愈长，替换的机会愈大，所以该物品的价格弹性系数是与时间正相关的。张老的反驳是，替换物品有时众所周知，不需要找寻。这样，价格上升，消费者立刻转用已知的替代物品，但用了一段时期，认为不称意，就转回旧物那方面去了。\n\n## 第六章：小试牛刀\n\n张老在这一章中展示了需求定律的预测能力。由需求定律推出来的事实可以向物理学或化学那样精确。\n\n差不多任何物品，要准确地判断其质量不容易。我们往往要花很大的功夫才能成为一样物品的衡量专家。所以一般来说，无知，加上自己以往的经验，同类之物，我们往往见到价格较高就会认为质量较好。这样的判断不一定对，但对的机会不会差。我们会认为市价较高质量应该较好，因为市场已作了鉴别。以价判质过程真实且重要。（这里的分析如下，如果有一个两克拉的钻石卖1000块，我们一般会觉得是假的，也就是说钻石的质量很低，自然我们就不愿意付1000块钱交换。）\n\n其他因素、验证条件与局限条件这三者有相同之处，但在角度上有重要的差别。下面以需求定律来解释。\n\n一条向右下倾斜的需求曲线约束某物品的价与量的关系，二者皆是变量。“其他因素”是指这两个变量之外的所有其他变量，有些我们让其变，有些不让其变。\n\n以需求定律而言，验证条件是其他因素中的一小部分，是那些为了要创造一个可以被事实验证的含意而指定的条件。如果在你面前有两个不同的假说，你可以想啊想，想出一个或几个验证条件。指定了之后，在逻辑上，事实或现象只可以支持两个假说的其中一个。这就是关键验证。\n\n“局限条件”是指约束行为的所有条件。以需求定律而言，局限条件不仅包括其他的有关因素，包括验证条件，也包括价格。\n\n整个经济学的原理或定理其实不多。问题是运用起来，以这些原理解释世事，其困难程度会大幅上升。大致上，困难有三方面的。\n\n（一）世界的局限条件——约束每个人争取最大利益的局限——非常复杂。\n（二）验证含意——甲的发生会导致乙的发生——这里的甲与乙，又或加上丙、丁等的有关变量，必须可以在真实世界中观察到。需求定律中的需求量是一个意图的变量，并非事实。那就是说，需求定律的本身是不可以验证的。我们要以需求定律，加上局限条件的变化，从逻辑推出可以被事实验证的含意。这里验证条件的指定要讲功夫了。\n（三）其他因素的变与不变的选择。\n\n需求定律是经济学的灵魂，而这灵魂的重点是要懂得怎样处理需求量这个抽象概念。以需求定律解释行为，我们要不是能以逻辑把需求量与成交量挂钩，就是不管成交量，单以需求量转变的含意来解释现象。\n\n“单质”是指一种物品只有一种质量，于是质多量多，质少量少，质与量相同。\n\n单质的需求验证。影印行为的示范：从加薪转到研究金的局限转变（验证条件），需求定律可以推出影印的数量会上升。解释：由于研究金能使用的范围小，所以研究金的一毫比加薪的一毫所值要少，比如是六仙。那么由需求定律，价格下降，需求量上升。而需求量表现为影印数量。\n\n多质的需求验证。例子：美国华盛顿州的顶级苹果（红苹果）大都卖出口（比如卖到香港），而本地人多吃次级苹果。解释：因为有了固定的运费，糖分及其他质量上升时（从次级变为顶级），这些质的间接之价在香港跌得很快。对于香港的消费者，不管是次级还是顶级苹果，都需要在糖分的费用上加上一个固定的运费，从而次级苹果的价格相对来说更贵。\n\n## 第七章：交易理论与市场需求\n\n张老在这一章，讲解了交易理论（主要是没有交易生产的交易）和市场需求（是个人需求之和，有两种换算方式）。\n\n要决解人与人之间的竞争，我们的社会发明了制度。制度有多种，市场是其中之一。\n\n交易是上下交征利（相互之间都得到利益），与没有交易相比，个人的利益增加大得惊人。但这庞大的利益增加，主要是由于每个人专业生产，然后交易。不谈生产而单论交易，利益还是有的，但比起有专业生产的存在，其交易的利益少很多，近于微不足道。\n\n没有专业生产的交易，大家有利可图，主要是因为大家对物品的边际用值不同。当边际用值与市值（换值）相等时，就达到了市场均衡，也达到了帕累托条件（帕累托说：资源的使用与物品的交易可以达到一个情况或条件，满足了这个条件，我们不可能改变资源的使用，使一个人得益而没有其他人受损。换言之，要是这个条件不达到，我们总可以改变资源的使用或市场的交易，而使社会起码有一个人得益而没有其他人受损——这也等于可使整个社会的人得益）。\n\n市场需求是所有个人需求加起来而成的。私用品（一个人享用其他的人就不能享用）的市场需求曲线是个别需求者的不同需求曲线向右横加（P为每价，Q为该价的所有需求者的需求量之和）而成的。\n\n每个需求的人都以市价与自己的边际用值相比，然后购进或沽出。每个人都这样做，其结果是每个人的边际用值皆与市价相等，而人与人之间对这物品的边际用值也因而相等。\n\n物品的市场需求曲线与市场供应曲线的相交之价，是市价，又称均衡市价，而每个需求者的边际用值与之看齐。相交之价，不是因为马歇尔所说的剪刀决定的。而是因为数之不尽的需求者与供应者，各自争取最高的交易利益，导致均衡市价出现。\n\n对于市价的厘定，不是像一些经济学者认为的是因为市场需求曲线与市场供应曲线相交。正相反，这市场二线相交，是因为数之不尽的需求者与供应者各自为战，争取自己的边际用值与市价相等，从而促成了市场二线相交。\n\n短缺与过剩皆空中楼阁，不是真实世界之物。\n\n经济学者发明的稳定的均衡与不稳定的均衡，是为了故扮高深，与世事无关。可以用简单的分析来处理复杂的均衡问题。价格若高于或低于市价，市场需求者的边际用值会低于或高于价格。他们为了增加私利，会沽出使价格下降，或购入使价格上升。市价于是因为人的自私而升降，也因为人的自私而安定下来。所以说，需求定律是包含着“个人争取利益极大化”这个假设或公理。\n\n价格管制是价格被管制在市价之下，需求的一方见自己的边际用值高于价格，竞争抢购不获，逼着要付出金钱价格之外的其他代价来作补充而争取。这些其他的补充准则可能是排队轮购，可能是论资排辈、武力解决、政治手法、人际关系等等。于是会有另一种均衡，不会有“短缺”，而竞争就会被解决了。“短缺”是因为经济学者的思想有所短缺而产生的。\n\n价格管制的分析困难，不是因为不均衡，而是我们不知道哪一种金钱之外的准则会被采用。\n\n市场这种制度的出现，是为了减少某些交易或社会费用，这些减少了的费用是些什么，是一个大难题。\n\n## 第八章：共用品的经济分析\n\n张老在这一章阐述了自己对共用品的认识。\n\n共用品的性质是共用，多人可以共享而不干扰他人的享用，多供应一个人的边际费用或成本为零。差不多所有的物品都具有共用品与私用品的性质。市场喜欢以私用品的量作价，因为私用品比较容易隔离不付费的享用者。这里注意区分私用和私有，以及共用和公有，他们是完全不同的概念。\n\n我们对同一个物品的边际用值不同，为了达到帕累托条件，商家需要实行价格分歧，但是价格分歧的费用奇高，因为商家不容易知道我们各自的边际用值。\n\n私用品的市场需求曲线是每价加量，即向右横加。共用品的市场需求曲线是每量加价，即向上竖加。\n\n萨缪尔森认为，共用品多供应一个人的边际费用或成本为零，所以共用品不应该收费。但是张老分析认为，如果边际成本为零不应该收费，那么近于零的也不应该收费。进而分析如果收费低于平均成本或费用，私营一定亏本，而如果收费等于或高于平均成本，那么收费会在边际成本之上（因为平均成本因为产量增加而下降）。所以，收费高于边际成本，对社会有害无益，从而得出不收费或由政府资助而又管制价格的上策。这是一种价值观，老生常谈了。\n\n牵扯到收费问题，共用品有互相矛盾的两种看法。其一是要采用价格分歧，收到尽，才可以达到帕累托条件。其二是多供应一个享用者的边际费用或成本是零，应该一律不收费。是有趣的价值观，不可以解释市场现象，却可以解释某些政客及经济学者的行为。\n\n张老举钢琴演奏家的例子来反驳萨缪尔森的观点。因为共用品可以私营产出，再把共用品捆绑着私用品一起销售，可以隔离不付费的人，减少交易费用。\n\n共用品大家可以一起享用，但也有挤迫情况，大家不是完全没有干扰。这里的要点是：无论怎么挤迫，只要共用品的量不变，不会因为挤迫而变为私用品。挤迫会导致个别享用者的需求曲线上、下移动，不会左、右移动。产出共用品的人要考虑的是市场的需求，不是个别人士的需求。\n\n## 第九章：经济学的理论结构与哲学性质\n\n张老在这一章讲了经济学的理论结构（通过一张图表），以及对经济学的哲学性质的思考。\n\n交易理论与市场需求图：\n\n![交易理论与市场需求](/images/economic-explanation-v1/Steven.Cheung's.Demand.jpg)\n\n注：附图以纵轴为价（P），横轴为量（Q）。竖直的S线代表着某物品的供应总量（Q\\*），假设固定不变。有A与B两个人，dA与dB分别是二者对该物品的需求曲线。先假设在交易之前该物品全部为B所有。这样，该物品给B的边际用值是M。A完全没有该物品，其边际用值是N。在这情况下，如果交易之价高于M，B会出售给A。另一方面，如果购买之价低于N，A会购入。均衡点是B的边际用值与A的边际用值相等。从图表可见，B出售到Y点，他的边际用值会跟A购入到X点的边际用值相等，而B的售出量（EY）一定与A的购入量（PX）相等。P是他俩的成交价，也即是市价。A获得的总用值是面积ONXqA，付出的总换值是面积OPXqA，所以面积NXP是A的交易总利。B放弃的总用值是面积YMQ\\*qB，获得的总换值是面积YEQ\\*qB（即OPXqA），所以面积YEM成为B出售给A所获的总利。把A的需求曲线dA与B的需求曲线dB每价向右横加而得到A与B合共的需求曲线，也就是市场的需求曲线了。B的需求曲线（dB）对着镜子就成了B的供应或售出曲线，即sB。sB在X那点与A的需求曲线（dA）相交，代表着B的边际成本与A的边际用值相等，是从另一个角度看市场均衡。\n\n张老认为的经济学的哲学性质：作为一门以武断假设或公理为起点的科学，除了边际产量下降定律，这些公理不是基于一些可以观察到的或真有其物的生理细胞或基因的运作，而是基于自然淘汰，是从人类的行为引申回头而获得的定义或规律。不同公理或武断假设之间没有矛盾，推得出可以用事实验证的假说，就成为一门实证科学了。因为经济学的公理的非真实性比自然科学的来得普及，科学的方法逻辑就比其他自然科学有较大的监管用场了。\n\n同样是公理性的科学，自然淘汰的思维，用于自然科学要从公理含意着的微小现象的变化入手，单用于经济学则要倒转过来，以人类行为的规律细节把公理或定义作修改或补充，是对还是错，最终的衡量是问这些公理约束着的人类的行为能否经得起自然淘汰的蹂躏。\n","source":"_posts/economic-explanation-v1.md","raw":"---\ntitle: 《经济解释》卷一《科学说需求》\ndate: 2016/09/22\ntag:\n- econ\ncategory:\n- note\nexcerpt: 本文为我阅读《经济解释》四卷本的第一卷《科学说需求》的读书笔记。\n---\n\n本文为我阅读《经济解释》四卷本的第一卷《科学说需求》的读书笔记。\n\n## 第一章：科学的方法\n\n对于什么是科学？什么是科学的方法？我从来没有思考过。在《经济解释》四卷本的第一卷《科学说需求》的第一章《科学的方法》中，张五常先生专门表达了他对科学和科学的方法的看法。本文是我对这一章的总结。\n\n科学是有系统地解释现象的学问。感情的表达是艺术，理智的分析却是科学了。在追求科学的过程中，我们应该将感情和理智区分清楚，不能用主观的喜恶作为科学上的结论。\n\n现象必有规律，不管是大自然的还是人为的。科学的形成是基于三个重要的信念。一是现象或行为的存在是主观的判断，而我们不能在这上面有所分歧；二是任何现象都一定有迹可寻；三是我们必须坚信现象的发生一定有原因。\n\n事实不能解释事实，否则会有困难出现。在科学上，现像、事实、行为或观察所得是同一回事，解释现象往往需要非事实的抽象理论。\n\n有些理论是没有解释能力的，比如特殊理论和套套逻辑。前一种指理论特殊到只能解释某一种现象，解释力非常小，代价很高。被推翻的理论，总可以多加条件来挽救。挽救的代价是减少理论的解释能力。科学的进步，不是因为对的理论替代了错的，而是有较为广泛解释力的，替代了较窄的；后一种指理论不可能错，连想象的错都不可能，内容是空洞的，没有解释力。但是有时对套套逻辑加上一些条件，可以促成一个有很强解释力的理论。\n\n理论用于推测和解释现象，最重要的一点是理论的推测一定要“可能被事实推翻”。可能被事实推翻而没有被推翻，就算是被证实了。不能被事实推翻的理论没有解释能力。一个可能被事实推翻的理论，一定要可以在想象中是错的。\n\n除了套套逻辑，还有四种情况会使一个理论免于被事实推翻的可能。一是概念或分析模糊不清，不可能清楚地错，所以不可能清楚地被事实推翻；二是相互矛盾的理论；三是理论的推测不能被观察到；四是理论推测会发生的现象没有限制。\n\n因为事实不能以事实解释，以理论解释现象，在某种程度上一定是抽象的。理论有四种非真实，前三种可以接受。一是理论本身必定有抽象的成分，因为事实不能解释事实；二是事实或观察的描述必须经过简化，减少对无关属性的描述；三是为便于处理而作简化，减少无关现象所带来的复杂；四是验证条件的假设，虽为假设，却不能脱离现实。\n\n推测与解释是同一回事，但有事前与事后之分。\n\n读完该章，我决定在以后的讨论和分析中，对感性和理性一定要加以判断区分。如果是讨论一些主观上的东西，大可不必浪费时间去争论，此时最需要的是尊重他人的喜恶。但是，如果是讨论一些客观的，科学的东西，我应该秉着科学的态度，减小感情方面的因素所带来的影响。比如跟我讨论的那个人我不喜欢或嫉妒，又或者为了面子而坚持自己的想法肯定正确，别人的想法肯定错误。\n\n在解释某个理论或思想时，使用一些贴切的例子可以达到事半功倍的效果。这是我以后写文章需要加强的地方。\n\n## 第二章：从自私说起\n\n在这一章，张老指出了经济学最重要的几个基础假设。\n\n一，“个人”是所有经济分析的基本单位。这是因为所有取舍或选择都是由个人做主的。“人会做选择”。经济学的第一个公理是任何人的行为，都是由个人作出可以被推测的选择而起。\n\n二，每个人的任何行为，都是自私自利的。重要的不是人究竟是怎样，而是我们要假设人是怎样。然后以这个假设为出发点去推测事实。任何的行为都需要使用自私自利这个假设来解释，但解释时需要加入一些局限条件，否则就成了没有内容的套套逻辑。\n\n人的自私本质，来源于斯密的自然淘汰观。斯密指出了自私可以给社会整体带来巨大的利益，但却轻视了自私也会给社会带来害处。这是张老的重点。\n\n假若人的本质是自私的不能更改，那么一个基于人的自私可以被更改的“主义”，其制度政策会失败。\n\n说过了，这里说的“自私”是“局限下争取个人利益极大化”的简称，是个假设，毫无价值观，是好是坏无关宏旨也。\n\n## 第三章：缺乏与竞争\n\n在这一章中，张老讲了经济学中的两个不可或缺的概念：缺乏与竞争。\n\n以理论来解释行为，行为一定要受到理论的约束。\n\n凡是有胜于无的东西，不管有形或无形，都是物品。物品又可以分为两大类：其一是经济物品；其二是免费物品。在有胜于无之中，有一大部分是多胜于少的，其为经济物品。\n\n“多胜于少”是经济物品的定义，也是“缺乏”的定义。“缺乏”是因为在需求下，供应有限而引起的。凡是有人愿意付出或多或少的代价来争取多一点的物品，都是缺乏的、不足够的，那就是经济物品了。\n\n竞争的定义，是指一种经济物品的需求有多于一人的需求。因为缺乏而引起的竞争，跟任何运动一样，是要有游戏规则的。产权制度是竞争的游戏规则，也就是约束行为的一种局限条件。阿尔钦说得好，“产”、竞争、缺乏这三个词是同义的。\n\n在自由市场，价高者得，市价于是成为决定胜负的准则。促成这市价的游戏规则，是私有产权的制度。\n\n张老认为准则在先而游戏规则在后。因为决定胜负的准则所决定的，是人类以竞争来解决的问题，而游戏规则只不过是协助准则的成立而已。\n\n因为竞争准则对人的收入、享受有决定性的作用，所以在不同的准则下，人的行为会跟着不同。\n\n一般书本说的、比较容易明白但不大正确的浪费概念：一般而言，浪费是指有其他办法，或用其他资源使用的分配，可使社会的财富或收入增加，但这些“其他”办法却莫名其妙地不予采用。\n\n唯一没有浪费的竞争准则，是市价。\n\n在不同的竞争准则下，胜或负的人各各不同。一些人喜欢选择某一种准则，另一些人会选择另一种。这些行为属于经济学的范畴。但哪一种准则是好是坏，或对社会福利有何好处，则是伦理或价值观的事。\n\n经济学不能判断什么是好是坏。经济学的范畴包括三部分。\n\n第一，在知道有关的局限条件或游戏规则（即产权制度或人与人之间的权利划分）的情况下，推断所用的竞争准则是什么。\n\n第二，在有了竞争的准则的情况下，推断人的行为会怎样，资源的使用会怎样，财富或收入的分配会怎样。\n\n第三，解释游戏规则是怎样形成的。\n\n## 第四章：功用的理念\n\n在这一章中，张老反对功用理论。其主要原因是，“功用”只不过是经济学者想象出来的概念，不是事实，所以要推断出可以被事实验证的含意不仅困难，而且陷阱太多，以致推出来的很容易是套套逻辑。\n\n“功用”是武断地以数字排列选择的定名。引入“功用”只是为了给各种选择一个名称，方便描述选择。\n\n替换定理：每一个人都愿意牺牲任何物品来换取任何其他的物品，只要牺牲的够少，而换得的够多。\n\n“等优曲线”就是根据替换定理推出的，关于两种经济物品在这些点上的功用数字相同的曲线。（不明白以甲乙的什么为横纵轴。功用？）\n\n再增加行为约束，则等优曲线一定是内凸（向左下弯曲）的。因为假设功用数字不变（在同一等优曲线上），一个人拥有甲物品愈多，其意愿以乙物品替换甲物品的意图必定下降。\n\n收入增加而需求量减少的物品，称为贫穷物品。某物品的价格下降带来的实质收入增加，导致该物品的需求量下降，称为吉芬物品。吉芬物品只能在一人世界存在，不可能在有竞争的社会存在。\n\n对于不能在市场成交或无从以金钱度量的经济物品，可以用其代价做替换，从而完全抛弃功用理论。\n\n## 第五章：需求定律\n\n在这一章中，张老讲解了需求定理的定义和应用。\n\n需求定律是说任何物品的价格下降，其需求量必定上升。\n\n前一章的功用分析推不出一条一定向右下倾斜的需求曲线，无法推出需求定律。对于没有市价的物品，我们可以用代价或牺牲替换，需求定律依然可用。\n\n需求量是指需求者的意图之量，在真实世界不存在。因此，我们必须加上其他的验证条件（可以观察到的局限条件的转变），才可以用需求定律推出可以被事实验证的假说。\n\n关于观察，有三类。第一类是无从观察的，实际上不存在，比如需求量。第二类是可以观察到的真有其物，比如价格。第三类是原则上可以观察到，但实际上观察很困难，我们要想办法找寻间接的替代来作验证，比如边际产量。\n\n解释行为需要以事实验证假说，真实世界不存在的变量或术语愈少愈好。说故事与科学解释是两回事。\n\n以一种物品来说，除了这物品的价格与需求量这两个变量之外，可以影响该物品的需求量的其他变量或因素数之不尽。其他可变但假设不变的量称为参数。要维护需求定律的解释里，哪些量可变哪些量不可变是大话题。\n\n需求定律约束着价格或代价（一个变量）与需求量（另一个变量）之间的关系。然而，可以影响需求量的因素多如天上星，价格只是其中之一罢了。\n\n其他不变量的选择准则：只要需求定律的验证含意不被事实推翻，其他的不变因素愈少愈好——其他可变量愈多愈好——因为这会增加需求定律的解释现象的广泛性。\n\n在该准则下，如下的三项“不变”与“变”的界定是“安全”的——安全者，不被事实推翻也。\n\n（一）凡是直接影响价格的其他因素皆可变。\n（二）凡是直接影响需求量的其他因素皆不可变。\n（三）价格转变会导致需求量的转变，这价格转变也可能导致其他因素的转变，而这些“其他因素”可能再影响需求量。这些在“中间”的、间接地影响需求量的因素（变量）皆可变。\n\n要以需求定律解释行为，应该假设每个人的品味不变。以品味解释行为的困难是我们不是上帝，不能判断一个人的品味是怎样的，也不能判断这个人的品味是否改变了。即使我们知道品味是什么，如何变化。但是这时我们仍然需要知道品味转变的原因，但如果知道成因，我们根本无须提及品味的转变。\n\n斯密指出价值有两种，其一是用值，其二是换值。顾名思义，用值是某物品给予拥有者或享有者的最高所值，或这个人愿意付出的最高代价。换值是获取该物品时所需要付出的代价，而在市场上，换值就是该物品的市价了。\n\n何为价？价是一个消费者对某物品在边际上所愿意付出的最高代价。\n\n某物品的边际用值比市价高，消费者会多够一点；若比市价低，这消费者当然不会购买。这是个人争取最大利益的假设使然。\n\n何为量？成交量和需求量是两回事。成交量是事实，是可以观察到的。需求量不是事实，无从观察，是个概念，没有经济学者“需求量”是不存在的。\n\n概念上，需求量是指在不同的价格（换值）下，消费者意图换取的最高的量。需求曲线于是成为在不同价格下最高的不同需求量的界线。\n\n量，可分为“有质”的与“委托”的两大类，也有两者的合并。凡是质量被直接度量而算价的，是有质的量。相反则为委托的量。\n\n需求定律永远用于价格及其直接联系着的量之间的关系。（说白了就是价格体现在物品的什么上，是物品的重量，还是物品的数量）\n\n用值与换值的差额就是消费者的盈余。因为顾客的需求曲线各个不同，多些不同的收费安排，榨取消费者盈余可以“榨”得“尽”一点。\n\n价格下降，购买者对该物品的消费总额可能下降也可能上升。从出售者那边看，减价后的收入可能下降也可能上升。其决定关键是需求的价格弹性。要记着，价格弹性系数是从一个价位来算的。一条需求曲线有数之不尽的价位，价格弹性系数可以价价不同：曲线上某部分的弹性系数大于一，某部分小于一。\n\n阿尔钦与施蒂格勒提出需求第二定律：弹性系数的大小与时间是正相关的。他们认为，找寻替代物品来替换是需要时间的。时间愈长，替换的机会愈大，所以该物品的价格弹性系数是与时间正相关的。张老的反驳是，替换物品有时众所周知，不需要找寻。这样，价格上升，消费者立刻转用已知的替代物品，但用了一段时期，认为不称意，就转回旧物那方面去了。\n\n## 第六章：小试牛刀\n\n张老在这一章中展示了需求定律的预测能力。由需求定律推出来的事实可以向物理学或化学那样精确。\n\n差不多任何物品，要准确地判断其质量不容易。我们往往要花很大的功夫才能成为一样物品的衡量专家。所以一般来说，无知，加上自己以往的经验，同类之物，我们往往见到价格较高就会认为质量较好。这样的判断不一定对，但对的机会不会差。我们会认为市价较高质量应该较好，因为市场已作了鉴别。以价判质过程真实且重要。（这里的分析如下，如果有一个两克拉的钻石卖1000块，我们一般会觉得是假的，也就是说钻石的质量很低，自然我们就不愿意付1000块钱交换。）\n\n其他因素、验证条件与局限条件这三者有相同之处，但在角度上有重要的差别。下面以需求定律来解释。\n\n一条向右下倾斜的需求曲线约束某物品的价与量的关系，二者皆是变量。“其他因素”是指这两个变量之外的所有其他变量，有些我们让其变，有些不让其变。\n\n以需求定律而言，验证条件是其他因素中的一小部分，是那些为了要创造一个可以被事实验证的含意而指定的条件。如果在你面前有两个不同的假说，你可以想啊想，想出一个或几个验证条件。指定了之后，在逻辑上，事实或现象只可以支持两个假说的其中一个。这就是关键验证。\n\n“局限条件”是指约束行为的所有条件。以需求定律而言，局限条件不仅包括其他的有关因素，包括验证条件，也包括价格。\n\n整个经济学的原理或定理其实不多。问题是运用起来，以这些原理解释世事，其困难程度会大幅上升。大致上，困难有三方面的。\n\n（一）世界的局限条件——约束每个人争取最大利益的局限——非常复杂。\n（二）验证含意——甲的发生会导致乙的发生——这里的甲与乙，又或加上丙、丁等的有关变量，必须可以在真实世界中观察到。需求定律中的需求量是一个意图的变量，并非事实。那就是说，需求定律的本身是不可以验证的。我们要以需求定律，加上局限条件的变化，从逻辑推出可以被事实验证的含意。这里验证条件的指定要讲功夫了。\n（三）其他因素的变与不变的选择。\n\n需求定律是经济学的灵魂，而这灵魂的重点是要懂得怎样处理需求量这个抽象概念。以需求定律解释行为，我们要不是能以逻辑把需求量与成交量挂钩，就是不管成交量，单以需求量转变的含意来解释现象。\n\n“单质”是指一种物品只有一种质量，于是质多量多，质少量少，质与量相同。\n\n单质的需求验证。影印行为的示范：从加薪转到研究金的局限转变（验证条件），需求定律可以推出影印的数量会上升。解释：由于研究金能使用的范围小，所以研究金的一毫比加薪的一毫所值要少，比如是六仙。那么由需求定律，价格下降，需求量上升。而需求量表现为影印数量。\n\n多质的需求验证。例子：美国华盛顿州的顶级苹果（红苹果）大都卖出口（比如卖到香港），而本地人多吃次级苹果。解释：因为有了固定的运费，糖分及其他质量上升时（从次级变为顶级），这些质的间接之价在香港跌得很快。对于香港的消费者，不管是次级还是顶级苹果，都需要在糖分的费用上加上一个固定的运费，从而次级苹果的价格相对来说更贵。\n\n## 第七章：交易理论与市场需求\n\n张老在这一章，讲解了交易理论（主要是没有交易生产的交易）和市场需求（是个人需求之和，有两种换算方式）。\n\n要决解人与人之间的竞争，我们的社会发明了制度。制度有多种，市场是其中之一。\n\n交易是上下交征利（相互之间都得到利益），与没有交易相比，个人的利益增加大得惊人。但这庞大的利益增加，主要是由于每个人专业生产，然后交易。不谈生产而单论交易，利益还是有的，但比起有专业生产的存在，其交易的利益少很多，近于微不足道。\n\n没有专业生产的交易，大家有利可图，主要是因为大家对物品的边际用值不同。当边际用值与市值（换值）相等时，就达到了市场均衡，也达到了帕累托条件（帕累托说：资源的使用与物品的交易可以达到一个情况或条件，满足了这个条件，我们不可能改变资源的使用，使一个人得益而没有其他人受损。换言之，要是这个条件不达到，我们总可以改变资源的使用或市场的交易，而使社会起码有一个人得益而没有其他人受损——这也等于可使整个社会的人得益）。\n\n市场需求是所有个人需求加起来而成的。私用品（一个人享用其他的人就不能享用）的市场需求曲线是个别需求者的不同需求曲线向右横加（P为每价，Q为该价的所有需求者的需求量之和）而成的。\n\n每个需求的人都以市价与自己的边际用值相比，然后购进或沽出。每个人都这样做，其结果是每个人的边际用值皆与市价相等，而人与人之间对这物品的边际用值也因而相等。\n\n物品的市场需求曲线与市场供应曲线的相交之价，是市价，又称均衡市价，而每个需求者的边际用值与之看齐。相交之价，不是因为马歇尔所说的剪刀决定的。而是因为数之不尽的需求者与供应者，各自争取最高的交易利益，导致均衡市价出现。\n\n对于市价的厘定，不是像一些经济学者认为的是因为市场需求曲线与市场供应曲线相交。正相反，这市场二线相交，是因为数之不尽的需求者与供应者各自为战，争取自己的边际用值与市价相等，从而促成了市场二线相交。\n\n短缺与过剩皆空中楼阁，不是真实世界之物。\n\n经济学者发明的稳定的均衡与不稳定的均衡，是为了故扮高深，与世事无关。可以用简单的分析来处理复杂的均衡问题。价格若高于或低于市价，市场需求者的边际用值会低于或高于价格。他们为了增加私利，会沽出使价格下降，或购入使价格上升。市价于是因为人的自私而升降，也因为人的自私而安定下来。所以说，需求定律是包含着“个人争取利益极大化”这个假设或公理。\n\n价格管制是价格被管制在市价之下，需求的一方见自己的边际用值高于价格，竞争抢购不获，逼着要付出金钱价格之外的其他代价来作补充而争取。这些其他的补充准则可能是排队轮购，可能是论资排辈、武力解决、政治手法、人际关系等等。于是会有另一种均衡，不会有“短缺”，而竞争就会被解决了。“短缺”是因为经济学者的思想有所短缺而产生的。\n\n价格管制的分析困难，不是因为不均衡，而是我们不知道哪一种金钱之外的准则会被采用。\n\n市场这种制度的出现，是为了减少某些交易或社会费用，这些减少了的费用是些什么，是一个大难题。\n\n## 第八章：共用品的经济分析\n\n张老在这一章阐述了自己对共用品的认识。\n\n共用品的性质是共用，多人可以共享而不干扰他人的享用，多供应一个人的边际费用或成本为零。差不多所有的物品都具有共用品与私用品的性质。市场喜欢以私用品的量作价，因为私用品比较容易隔离不付费的享用者。这里注意区分私用和私有，以及共用和公有，他们是完全不同的概念。\n\n我们对同一个物品的边际用值不同，为了达到帕累托条件，商家需要实行价格分歧，但是价格分歧的费用奇高，因为商家不容易知道我们各自的边际用值。\n\n私用品的市场需求曲线是每价加量，即向右横加。共用品的市场需求曲线是每量加价，即向上竖加。\n\n萨缪尔森认为，共用品多供应一个人的边际费用或成本为零，所以共用品不应该收费。但是张老分析认为，如果边际成本为零不应该收费，那么近于零的也不应该收费。进而分析如果收费低于平均成本或费用，私营一定亏本，而如果收费等于或高于平均成本，那么收费会在边际成本之上（因为平均成本因为产量增加而下降）。所以，收费高于边际成本，对社会有害无益，从而得出不收费或由政府资助而又管制价格的上策。这是一种价值观，老生常谈了。\n\n牵扯到收费问题，共用品有互相矛盾的两种看法。其一是要采用价格分歧，收到尽，才可以达到帕累托条件。其二是多供应一个享用者的边际费用或成本是零，应该一律不收费。是有趣的价值观，不可以解释市场现象，却可以解释某些政客及经济学者的行为。\n\n张老举钢琴演奏家的例子来反驳萨缪尔森的观点。因为共用品可以私营产出，再把共用品捆绑着私用品一起销售，可以隔离不付费的人，减少交易费用。\n\n共用品大家可以一起享用，但也有挤迫情况，大家不是完全没有干扰。这里的要点是：无论怎么挤迫，只要共用品的量不变，不会因为挤迫而变为私用品。挤迫会导致个别享用者的需求曲线上、下移动，不会左、右移动。产出共用品的人要考虑的是市场的需求，不是个别人士的需求。\n\n## 第九章：经济学的理论结构与哲学性质\n\n张老在这一章讲了经济学的理论结构（通过一张图表），以及对经济学的哲学性质的思考。\n\n交易理论与市场需求图：\n\n![交易理论与市场需求](/images/economic-explanation-v1/Steven.Cheung's.Demand.jpg)\n\n注：附图以纵轴为价（P），横轴为量（Q）。竖直的S线代表着某物品的供应总量（Q\\*），假设固定不变。有A与B两个人，dA与dB分别是二者对该物品的需求曲线。先假设在交易之前该物品全部为B所有。这样，该物品给B的边际用值是M。A完全没有该物品，其边际用值是N。在这情况下，如果交易之价高于M，B会出售给A。另一方面，如果购买之价低于N，A会购入。均衡点是B的边际用值与A的边际用值相等。从图表可见，B出售到Y点，他的边际用值会跟A购入到X点的边际用值相等，而B的售出量（EY）一定与A的购入量（PX）相等。P是他俩的成交价，也即是市价。A获得的总用值是面积ONXqA，付出的总换值是面积OPXqA，所以面积NXP是A的交易总利。B放弃的总用值是面积YMQ\\*qB，获得的总换值是面积YEQ\\*qB（即OPXqA），所以面积YEM成为B出售给A所获的总利。把A的需求曲线dA与B的需求曲线dB每价向右横加而得到A与B合共的需求曲线，也就是市场的需求曲线了。B的需求曲线（dB）对着镜子就成了B的供应或售出曲线，即sB。sB在X那点与A的需求曲线（dA）相交，代表着B的边际成本与A的边际用值相等，是从另一个角度看市场均衡。\n\n张老认为的经济学的哲学性质：作为一门以武断假设或公理为起点的科学，除了边际产量下降定律，这些公理不是基于一些可以观察到的或真有其物的生理细胞或基因的运作，而是基于自然淘汰，是从人类的行为引申回头而获得的定义或规律。不同公理或武断假设之间没有矛盾，推得出可以用事实验证的假说，就成为一门实证科学了。因为经济学的公理的非真实性比自然科学的来得普及，科学的方法逻辑就比其他自然科学有较大的监管用场了。\n\n同样是公理性的科学，自然淘汰的思维，用于自然科学要从公理含意着的微小现象的变化入手，单用于经济学则要倒转过来，以人类行为的规律细节把公理或定义作修改或补充，是对还是错，最终的衡量是问这些公理约束着的人类的行为能否经得起自然淘汰的蹂躏。\n","slug":"economic-explanation-v1","published":1,"updated":"2020-11-28T14:23:20.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk08001frnq7aobf9viw","content":"<p>本文为我阅读《经济解释》四卷本的第一卷《科学说需求》的读书笔记。</p>\n<h2 id=\"第一章：科学的方法\"><a href=\"#第一章：科学的方法\" class=\"headerlink\" title=\"第一章：科学的方法\"></a>第一章：科学的方法</h2><p>对于什么是科学？什么是科学的方法？我从来没有思考过。在《经济解释》四卷本的第一卷《科学说需求》的第一章《科学的方法》中，张五常先生专门表达了他对科学和科学的方法的看法。本文是我对这一章的总结。</p>\n<p>科学是有系统地解释现象的学问。感情的表达是艺术，理智的分析却是科学了。在追求科学的过程中，我们应该将感情和理智区分清楚，不能用主观的喜恶作为科学上的结论。</p>\n<p>现象必有规律，不管是大自然的还是人为的。科学的形成是基于三个重要的信念。一是现象或行为的存在是主观的判断，而我们不能在这上面有所分歧；二是任何现象都一定有迹可寻；三是我们必须坚信现象的发生一定有原因。</p>\n<p>事实不能解释事实，否则会有困难出现。在科学上，现像、事实、行为或观察所得是同一回事，解释现象往往需要非事实的抽象理论。</p>\n<p>有些理论是没有解释能力的，比如特殊理论和套套逻辑。前一种指理论特殊到只能解释某一种现象，解释力非常小，代价很高。被推翻的理论，总可以多加条件来挽救。挽救的代价是减少理论的解释能力。科学的进步，不是因为对的理论替代了错的，而是有较为广泛解释力的，替代了较窄的；后一种指理论不可能错，连想象的错都不可能，内容是空洞的，没有解释力。但是有时对套套逻辑加上一些条件，可以促成一个有很强解释力的理论。</p>\n<p>理论用于推测和解释现象，最重要的一点是理论的推测一定要“可能被事实推翻”。可能被事实推翻而没有被推翻，就算是被证实了。不能被事实推翻的理论没有解释能力。一个可能被事实推翻的理论，一定要可以在想象中是错的。</p>\n<p>除了套套逻辑，还有四种情况会使一个理论免于被事实推翻的可能。一是概念或分析模糊不清，不可能清楚地错，所以不可能清楚地被事实推翻；二是相互矛盾的理论；三是理论的推测不能被观察到；四是理论推测会发生的现象没有限制。</p>\n<p>因为事实不能以事实解释，以理论解释现象，在某种程度上一定是抽象的。理论有四种非真实，前三种可以接受。一是理论本身必定有抽象的成分，因为事实不能解释事实；二是事实或观察的描述必须经过简化，减少对无关属性的描述；三是为便于处理而作简化，减少无关现象所带来的复杂；四是验证条件的假设，虽为假设，却不能脱离现实。</p>\n<p>推测与解释是同一回事，但有事前与事后之分。</p>\n<p>读完该章，我决定在以后的讨论和分析中，对感性和理性一定要加以判断区分。如果是讨论一些主观上的东西，大可不必浪费时间去争论，此时最需要的是尊重他人的喜恶。但是，如果是讨论一些客观的，科学的东西，我应该秉着科学的态度，减小感情方面的因素所带来的影响。比如跟我讨论的那个人我不喜欢或嫉妒，又或者为了面子而坚持自己的想法肯定正确，别人的想法肯定错误。</p>\n<p>在解释某个理论或思想时，使用一些贴切的例子可以达到事半功倍的效果。这是我以后写文章需要加强的地方。</p>\n<h2 id=\"第二章：从自私说起\"><a href=\"#第二章：从自私说起\" class=\"headerlink\" title=\"第二章：从自私说起\"></a>第二章：从自私说起</h2><p>在这一章，张老指出了经济学最重要的几个基础假设。</p>\n<p>一，“个人”是所有经济分析的基本单位。这是因为所有取舍或选择都是由个人做主的。“人会做选择”。经济学的第一个公理是任何人的行为，都是由个人作出可以被推测的选择而起。</p>\n<p>二，每个人的任何行为，都是自私自利的。重要的不是人究竟是怎样，而是我们要假设人是怎样。然后以这个假设为出发点去推测事实。任何的行为都需要使用自私自利这个假设来解释，但解释时需要加入一些局限条件，否则就成了没有内容的套套逻辑。</p>\n<p>人的自私本质，来源于斯密的自然淘汰观。斯密指出了自私可以给社会整体带来巨大的利益，但却轻视了自私也会给社会带来害处。这是张老的重点。</p>\n<p>假若人的本质是自私的不能更改，那么一个基于人的自私可以被更改的“主义”，其制度政策会失败。</p>\n<p>说过了，这里说的“自私”是“局限下争取个人利益极大化”的简称，是个假设，毫无价值观，是好是坏无关宏旨也。</p>\n<h2 id=\"第三章：缺乏与竞争\"><a href=\"#第三章：缺乏与竞争\" class=\"headerlink\" title=\"第三章：缺乏与竞争\"></a>第三章：缺乏与竞争</h2><p>在这一章中，张老讲了经济学中的两个不可或缺的概念：缺乏与竞争。</p>\n<p>以理论来解释行为，行为一定要受到理论的约束。</p>\n<p>凡是有胜于无的东西，不管有形或无形，都是物品。物品又可以分为两大类：其一是经济物品；其二是免费物品。在有胜于无之中，有一大部分是多胜于少的，其为经济物品。</p>\n<p>“多胜于少”是经济物品的定义，也是“缺乏”的定义。“缺乏”是因为在需求下，供应有限而引起的。凡是有人愿意付出或多或少的代价来争取多一点的物品，都是缺乏的、不足够的，那就是经济物品了。</p>\n<p>竞争的定义，是指一种经济物品的需求有多于一人的需求。因为缺乏而引起的竞争，跟任何运动一样，是要有游戏规则的。产权制度是竞争的游戏规则，也就是约束行为的一种局限条件。阿尔钦说得好，“产”、竞争、缺乏这三个词是同义的。</p>\n<p>在自由市场，价高者得，市价于是成为决定胜负的准则。促成这市价的游戏规则，是私有产权的制度。</p>\n<p>张老认为准则在先而游戏规则在后。因为决定胜负的准则所决定的，是人类以竞争来解决的问题，而游戏规则只不过是协助准则的成立而已。</p>\n<p>因为竞争准则对人的收入、享受有决定性的作用，所以在不同的准则下，人的行为会跟着不同。</p>\n<p>一般书本说的、比较容易明白但不大正确的浪费概念：一般而言，浪费是指有其他办法，或用其他资源使用的分配，可使社会的财富或收入增加，但这些“其他”办法却莫名其妙地不予采用。</p>\n<p>唯一没有浪费的竞争准则，是市价。</p>\n<p>在不同的竞争准则下，胜或负的人各各不同。一些人喜欢选择某一种准则，另一些人会选择另一种。这些行为属于经济学的范畴。但哪一种准则是好是坏，或对社会福利有何好处，则是伦理或价值观的事。</p>\n<p>经济学不能判断什么是好是坏。经济学的范畴包括三部分。</p>\n<p>第一，在知道有关的局限条件或游戏规则（即产权制度或人与人之间的权利划分）的情况下，推断所用的竞争准则是什么。</p>\n<p>第二，在有了竞争的准则的情况下，推断人的行为会怎样，资源的使用会怎样，财富或收入的分配会怎样。</p>\n<p>第三，解释游戏规则是怎样形成的。</p>\n<h2 id=\"第四章：功用的理念\"><a href=\"#第四章：功用的理念\" class=\"headerlink\" title=\"第四章：功用的理念\"></a>第四章：功用的理念</h2><p>在这一章中，张老反对功用理论。其主要原因是，“功用”只不过是经济学者想象出来的概念，不是事实，所以要推断出可以被事实验证的含意不仅困难，而且陷阱太多，以致推出来的很容易是套套逻辑。</p>\n<p>“功用”是武断地以数字排列选择的定名。引入“功用”只是为了给各种选择一个名称，方便描述选择。</p>\n<p>替换定理：每一个人都愿意牺牲任何物品来换取任何其他的物品，只要牺牲的够少，而换得的够多。</p>\n<p>“等优曲线”就是根据替换定理推出的，关于两种经济物品在这些点上的功用数字相同的曲线。（不明白以甲乙的什么为横纵轴。功用？）</p>\n<p>再增加行为约束，则等优曲线一定是内凸（向左下弯曲）的。因为假设功用数字不变（在同一等优曲线上），一个人拥有甲物品愈多，其意愿以乙物品替换甲物品的意图必定下降。</p>\n<p>收入增加而需求量减少的物品，称为贫穷物品。某物品的价格下降带来的实质收入增加，导致该物品的需求量下降，称为吉芬物品。吉芬物品只能在一人世界存在，不可能在有竞争的社会存在。</p>\n<p>对于不能在市场成交或无从以金钱度量的经济物品，可以用其代价做替换，从而完全抛弃功用理论。</p>\n<h2 id=\"第五章：需求定律\"><a href=\"#第五章：需求定律\" class=\"headerlink\" title=\"第五章：需求定律\"></a>第五章：需求定律</h2><p>在这一章中，张老讲解了需求定理的定义和应用。</p>\n<p>需求定律是说任何物品的价格下降，其需求量必定上升。</p>\n<p>前一章的功用分析推不出一条一定向右下倾斜的需求曲线，无法推出需求定律。对于没有市价的物品，我们可以用代价或牺牲替换，需求定律依然可用。</p>\n<p>需求量是指需求者的意图之量，在真实世界不存在。因此，我们必须加上其他的验证条件（可以观察到的局限条件的转变），才可以用需求定律推出可以被事实验证的假说。</p>\n<p>关于观察，有三类。第一类是无从观察的，实际上不存在，比如需求量。第二类是可以观察到的真有其物，比如价格。第三类是原则上可以观察到，但实际上观察很困难，我们要想办法找寻间接的替代来作验证，比如边际产量。</p>\n<p>解释行为需要以事实验证假说，真实世界不存在的变量或术语愈少愈好。说故事与科学解释是两回事。</p>\n<p>以一种物品来说，除了这物品的价格与需求量这两个变量之外，可以影响该物品的需求量的其他变量或因素数之不尽。其他可变但假设不变的量称为参数。要维护需求定律的解释里，哪些量可变哪些量不可变是大话题。</p>\n<p>需求定律约束着价格或代价（一个变量）与需求量（另一个变量）之间的关系。然而，可以影响需求量的因素多如天上星，价格只是其中之一罢了。</p>\n<p>其他不变量的选择准则：只要需求定律的验证含意不被事实推翻，其他的不变因素愈少愈好——其他可变量愈多愈好——因为这会增加需求定律的解释现象的广泛性。</p>\n<p>在该准则下，如下的三项“不变”与“变”的界定是“安全”的——安全者，不被事实推翻也。</p>\n<p>（一）凡是直接影响价格的其他因素皆可变。<br>（二）凡是直接影响需求量的其他因素皆不可变。<br>（三）价格转变会导致需求量的转变，这价格转变也可能导致其他因素的转变，而这些“其他因素”可能再影响需求量。这些在“中间”的、间接地影响需求量的因素（变量）皆可变。</p>\n<p>要以需求定律解释行为，应该假设每个人的品味不变。以品味解释行为的困难是我们不是上帝，不能判断一个人的品味是怎样的，也不能判断这个人的品味是否改变了。即使我们知道品味是什么，如何变化。但是这时我们仍然需要知道品味转变的原因，但如果知道成因，我们根本无须提及品味的转变。</p>\n<p>斯密指出价值有两种，其一是用值，其二是换值。顾名思义，用值是某物品给予拥有者或享有者的最高所值，或这个人愿意付出的最高代价。换值是获取该物品时所需要付出的代价，而在市场上，换值就是该物品的市价了。</p>\n<p>何为价？价是一个消费者对某物品在边际上所愿意付出的最高代价。</p>\n<p>某物品的边际用值比市价高，消费者会多够一点；若比市价低，这消费者当然不会购买。这是个人争取最大利益的假设使然。</p>\n<p>何为量？成交量和需求量是两回事。成交量是事实，是可以观察到的。需求量不是事实，无从观察，是个概念，没有经济学者“需求量”是不存在的。</p>\n<p>概念上，需求量是指在不同的价格（换值）下，消费者意图换取的最高的量。需求曲线于是成为在不同价格下最高的不同需求量的界线。</p>\n<p>量，可分为“有质”的与“委托”的两大类，也有两者的合并。凡是质量被直接度量而算价的，是有质的量。相反则为委托的量。</p>\n<p>需求定律永远用于价格及其直接联系着的量之间的关系。（说白了就是价格体现在物品的什么上，是物品的重量，还是物品的数量）</p>\n<p>用值与换值的差额就是消费者的盈余。因为顾客的需求曲线各个不同，多些不同的收费安排，榨取消费者盈余可以“榨”得“尽”一点。</p>\n<p>价格下降，购买者对该物品的消费总额可能下降也可能上升。从出售者那边看，减价后的收入可能下降也可能上升。其决定关键是需求的价格弹性。要记着，价格弹性系数是从一个价位来算的。一条需求曲线有数之不尽的价位，价格弹性系数可以价价不同：曲线上某部分的弹性系数大于一，某部分小于一。</p>\n<p>阿尔钦与施蒂格勒提出需求第二定律：弹性系数的大小与时间是正相关的。他们认为，找寻替代物品来替换是需要时间的。时间愈长，替换的机会愈大，所以该物品的价格弹性系数是与时间正相关的。张老的反驳是，替换物品有时众所周知，不需要找寻。这样，价格上升，消费者立刻转用已知的替代物品，但用了一段时期，认为不称意，就转回旧物那方面去了。</p>\n<h2 id=\"第六章：小试牛刀\"><a href=\"#第六章：小试牛刀\" class=\"headerlink\" title=\"第六章：小试牛刀\"></a>第六章：小试牛刀</h2><p>张老在这一章中展示了需求定律的预测能力。由需求定律推出来的事实可以向物理学或化学那样精确。</p>\n<p>差不多任何物品，要准确地判断其质量不容易。我们往往要花很大的功夫才能成为一样物品的衡量专家。所以一般来说，无知，加上自己以往的经验，同类之物，我们往往见到价格较高就会认为质量较好。这样的判断不一定对，但对的机会不会差。我们会认为市价较高质量应该较好，因为市场已作了鉴别。以价判质过程真实且重要。（这里的分析如下，如果有一个两克拉的钻石卖1000块，我们一般会觉得是假的，也就是说钻石的质量很低，自然我们就不愿意付1000块钱交换。）</p>\n<p>其他因素、验证条件与局限条件这三者有相同之处，但在角度上有重要的差别。下面以需求定律来解释。</p>\n<p>一条向右下倾斜的需求曲线约束某物品的价与量的关系，二者皆是变量。“其他因素”是指这两个变量之外的所有其他变量，有些我们让其变，有些不让其变。</p>\n<p>以需求定律而言，验证条件是其他因素中的一小部分，是那些为了要创造一个可以被事实验证的含意而指定的条件。如果在你面前有两个不同的假说，你可以想啊想，想出一个或几个验证条件。指定了之后，在逻辑上，事实或现象只可以支持两个假说的其中一个。这就是关键验证。</p>\n<p>“局限条件”是指约束行为的所有条件。以需求定律而言，局限条件不仅包括其他的有关因素，包括验证条件，也包括价格。</p>\n<p>整个经济学的原理或定理其实不多。问题是运用起来，以这些原理解释世事，其困难程度会大幅上升。大致上，困难有三方面的。</p>\n<p>（一）世界的局限条件——约束每个人争取最大利益的局限——非常复杂。<br>（二）验证含意——甲的发生会导致乙的发生——这里的甲与乙，又或加上丙、丁等的有关变量，必须可以在真实世界中观察到。需求定律中的需求量是一个意图的变量，并非事实。那就是说，需求定律的本身是不可以验证的。我们要以需求定律，加上局限条件的变化，从逻辑推出可以被事实验证的含意。这里验证条件的指定要讲功夫了。<br>（三）其他因素的变与不变的选择。</p>\n<p>需求定律是经济学的灵魂，而这灵魂的重点是要懂得怎样处理需求量这个抽象概念。以需求定律解释行为，我们要不是能以逻辑把需求量与成交量挂钩，就是不管成交量，单以需求量转变的含意来解释现象。</p>\n<p>“单质”是指一种物品只有一种质量，于是质多量多，质少量少，质与量相同。</p>\n<p>单质的需求验证。影印行为的示范：从加薪转到研究金的局限转变（验证条件），需求定律可以推出影印的数量会上升。解释：由于研究金能使用的范围小，所以研究金的一毫比加薪的一毫所值要少，比如是六仙。那么由需求定律，价格下降，需求量上升。而需求量表现为影印数量。</p>\n<p>多质的需求验证。例子：美国华盛顿州的顶级苹果（红苹果）大都卖出口（比如卖到香港），而本地人多吃次级苹果。解释：因为有了固定的运费，糖分及其他质量上升时（从次级变为顶级），这些质的间接之价在香港跌得很快。对于香港的消费者，不管是次级还是顶级苹果，都需要在糖分的费用上加上一个固定的运费，从而次级苹果的价格相对来说更贵。</p>\n<h2 id=\"第七章：交易理论与市场需求\"><a href=\"#第七章：交易理论与市场需求\" class=\"headerlink\" title=\"第七章：交易理论与市场需求\"></a>第七章：交易理论与市场需求</h2><p>张老在这一章，讲解了交易理论（主要是没有交易生产的交易）和市场需求（是个人需求之和，有两种换算方式）。</p>\n<p>要决解人与人之间的竞争，我们的社会发明了制度。制度有多种，市场是其中之一。</p>\n<p>交易是上下交征利（相互之间都得到利益），与没有交易相比，个人的利益增加大得惊人。但这庞大的利益增加，主要是由于每个人专业生产，然后交易。不谈生产而单论交易，利益还是有的，但比起有专业生产的存在，其交易的利益少很多，近于微不足道。</p>\n<p>没有专业生产的交易，大家有利可图，主要是因为大家对物品的边际用值不同。当边际用值与市值（换值）相等时，就达到了市场均衡，也达到了帕累托条件（帕累托说：资源的使用与物品的交易可以达到一个情况或条件，满足了这个条件，我们不可能改变资源的使用，使一个人得益而没有其他人受损。换言之，要是这个条件不达到，我们总可以改变资源的使用或市场的交易，而使社会起码有一个人得益而没有其他人受损——这也等于可使整个社会的人得益）。</p>\n<p>市场需求是所有个人需求加起来而成的。私用品（一个人享用其他的人就不能享用）的市场需求曲线是个别需求者的不同需求曲线向右横加（P为每价，Q为该价的所有需求者的需求量之和）而成的。</p>\n<p>每个需求的人都以市价与自己的边际用值相比，然后购进或沽出。每个人都这样做，其结果是每个人的边际用值皆与市价相等，而人与人之间对这物品的边际用值也因而相等。</p>\n<p>物品的市场需求曲线与市场供应曲线的相交之价，是市价，又称均衡市价，而每个需求者的边际用值与之看齐。相交之价，不是因为马歇尔所说的剪刀决定的。而是因为数之不尽的需求者与供应者，各自争取最高的交易利益，导致均衡市价出现。</p>\n<p>对于市价的厘定，不是像一些经济学者认为的是因为市场需求曲线与市场供应曲线相交。正相反，这市场二线相交，是因为数之不尽的需求者与供应者各自为战，争取自己的边际用值与市价相等，从而促成了市场二线相交。</p>\n<p>短缺与过剩皆空中楼阁，不是真实世界之物。</p>\n<p>经济学者发明的稳定的均衡与不稳定的均衡，是为了故扮高深，与世事无关。可以用简单的分析来处理复杂的均衡问题。价格若高于或低于市价，市场需求者的边际用值会低于或高于价格。他们为了增加私利，会沽出使价格下降，或购入使价格上升。市价于是因为人的自私而升降，也因为人的自私而安定下来。所以说，需求定律是包含着“个人争取利益极大化”这个假设或公理。</p>\n<p>价格管制是价格被管制在市价之下，需求的一方见自己的边际用值高于价格，竞争抢购不获，逼着要付出金钱价格之外的其他代价来作补充而争取。这些其他的补充准则可能是排队轮购，可能是论资排辈、武力解决、政治手法、人际关系等等。于是会有另一种均衡，不会有“短缺”，而竞争就会被解决了。“短缺”是因为经济学者的思想有所短缺而产生的。</p>\n<p>价格管制的分析困难，不是因为不均衡，而是我们不知道哪一种金钱之外的准则会被采用。</p>\n<p>市场这种制度的出现，是为了减少某些交易或社会费用，这些减少了的费用是些什么，是一个大难题。</p>\n<h2 id=\"第八章：共用品的经济分析\"><a href=\"#第八章：共用品的经济分析\" class=\"headerlink\" title=\"第八章：共用品的经济分析\"></a>第八章：共用品的经济分析</h2><p>张老在这一章阐述了自己对共用品的认识。</p>\n<p>共用品的性质是共用，多人可以共享而不干扰他人的享用，多供应一个人的边际费用或成本为零。差不多所有的物品都具有共用品与私用品的性质。市场喜欢以私用品的量作价，因为私用品比较容易隔离不付费的享用者。这里注意区分私用和私有，以及共用和公有，他们是完全不同的概念。</p>\n<p>我们对同一个物品的边际用值不同，为了达到帕累托条件，商家需要实行价格分歧，但是价格分歧的费用奇高，因为商家不容易知道我们各自的边际用值。</p>\n<p>私用品的市场需求曲线是每价加量，即向右横加。共用品的市场需求曲线是每量加价，即向上竖加。</p>\n<p>萨缪尔森认为，共用品多供应一个人的边际费用或成本为零，所以共用品不应该收费。但是张老分析认为，如果边际成本为零不应该收费，那么近于零的也不应该收费。进而分析如果收费低于平均成本或费用，私营一定亏本，而如果收费等于或高于平均成本，那么收费会在边际成本之上（因为平均成本因为产量增加而下降）。所以，收费高于边际成本，对社会有害无益，从而得出不收费或由政府资助而又管制价格的上策。这是一种价值观，老生常谈了。</p>\n<p>牵扯到收费问题，共用品有互相矛盾的两种看法。其一是要采用价格分歧，收到尽，才可以达到帕累托条件。其二是多供应一个享用者的边际费用或成本是零，应该一律不收费。是有趣的价值观，不可以解释市场现象，却可以解释某些政客及经济学者的行为。</p>\n<p>张老举钢琴演奏家的例子来反驳萨缪尔森的观点。因为共用品可以私营产出，再把共用品捆绑着私用品一起销售，可以隔离不付费的人，减少交易费用。</p>\n<p>共用品大家可以一起享用，但也有挤迫情况，大家不是完全没有干扰。这里的要点是：无论怎么挤迫，只要共用品的量不变，不会因为挤迫而变为私用品。挤迫会导致个别享用者的需求曲线上、下移动，不会左、右移动。产出共用品的人要考虑的是市场的需求，不是个别人士的需求。</p>\n<h2 id=\"第九章：经济学的理论结构与哲学性质\"><a href=\"#第九章：经济学的理论结构与哲学性质\" class=\"headerlink\" title=\"第九章：经济学的理论结构与哲学性质\"></a>第九章：经济学的理论结构与哲学性质</h2><p>张老在这一章讲了经济学的理论结构（通过一张图表），以及对经济学的哲学性质的思考。</p>\n<p>交易理论与市场需求图：</p>\n<p><img src=\"/images/economic-explanation-v1/Steven.Cheung's.Demand.jpg\" alt=\"交易理论与市场需求\"></p>\n<p>注：附图以纵轴为价（P），横轴为量（Q）。竖直的S线代表着某物品的供应总量（Q*），假设固定不变。有A与B两个人，dA与dB分别是二者对该物品的需求曲线。先假设在交易之前该物品全部为B所有。这样，该物品给B的边际用值是M。A完全没有该物品，其边际用值是N。在这情况下，如果交易之价高于M，B会出售给A。另一方面，如果购买之价低于N，A会购入。均衡点是B的边际用值与A的边际用值相等。从图表可见，B出售到Y点，他的边际用值会跟A购入到X点的边际用值相等，而B的售出量（EY）一定与A的购入量（PX）相等。P是他俩的成交价，也即是市价。A获得的总用值是面积ONXqA，付出的总换值是面积OPXqA，所以面积NXP是A的交易总利。B放弃的总用值是面积YMQ*qB，获得的总换值是面积YEQ*qB（即OPXqA），所以面积YEM成为B出售给A所获的总利。把A的需求曲线dA与B的需求曲线dB每价向右横加而得到A与B合共的需求曲线，也就是市场的需求曲线了。B的需求曲线（dB）对着镜子就成了B的供应或售出曲线，即sB。sB在X那点与A的需求曲线（dA）相交，代表着B的边际成本与A的边际用值相等，是从另一个角度看市场均衡。</p>\n<p>张老认为的经济学的哲学性质：作为一门以武断假设或公理为起点的科学，除了边际产量下降定律，这些公理不是基于一些可以观察到的或真有其物的生理细胞或基因的运作，而是基于自然淘汰，是从人类的行为引申回头而获得的定义或规律。不同公理或武断假设之间没有矛盾，推得出可以用事实验证的假说，就成为一门实证科学了。因为经济学的公理的非真实性比自然科学的来得普及，科学的方法逻辑就比其他自然科学有较大的监管用场了。</p>\n<p>同样是公理性的科学，自然淘汰的思维，用于自然科学要从公理含意着的微小现象的变化入手，单用于经济学则要倒转过来，以人类行为的规律细节把公理或定义作修改或补充，是对还是错，最终的衡量是问这些公理约束着的人类的行为能否经得起自然淘汰的蹂躏。</p>\n","site":{"data":{}},"more":"<p>本文为我阅读《经济解释》四卷本的第一卷《科学说需求》的读书笔记。</p>\n<h2 id=\"第一章：科学的方法\"><a href=\"#第一章：科学的方法\" class=\"headerlink\" title=\"第一章：科学的方法\"></a>第一章：科学的方法</h2><p>对于什么是科学？什么是科学的方法？我从来没有思考过。在《经济解释》四卷本的第一卷《科学说需求》的第一章《科学的方法》中，张五常先生专门表达了他对科学和科学的方法的看法。本文是我对这一章的总结。</p>\n<p>科学是有系统地解释现象的学问。感情的表达是艺术，理智的分析却是科学了。在追求科学的过程中，我们应该将感情和理智区分清楚，不能用主观的喜恶作为科学上的结论。</p>\n<p>现象必有规律，不管是大自然的还是人为的。科学的形成是基于三个重要的信念。一是现象或行为的存在是主观的判断，而我们不能在这上面有所分歧；二是任何现象都一定有迹可寻；三是我们必须坚信现象的发生一定有原因。</p>\n<p>事实不能解释事实，否则会有困难出现。在科学上，现像、事实、行为或观察所得是同一回事，解释现象往往需要非事实的抽象理论。</p>\n<p>有些理论是没有解释能力的，比如特殊理论和套套逻辑。前一种指理论特殊到只能解释某一种现象，解释力非常小，代价很高。被推翻的理论，总可以多加条件来挽救。挽救的代价是减少理论的解释能力。科学的进步，不是因为对的理论替代了错的，而是有较为广泛解释力的，替代了较窄的；后一种指理论不可能错，连想象的错都不可能，内容是空洞的，没有解释力。但是有时对套套逻辑加上一些条件，可以促成一个有很强解释力的理论。</p>\n<p>理论用于推测和解释现象，最重要的一点是理论的推测一定要“可能被事实推翻”。可能被事实推翻而没有被推翻，就算是被证实了。不能被事实推翻的理论没有解释能力。一个可能被事实推翻的理论，一定要可以在想象中是错的。</p>\n<p>除了套套逻辑，还有四种情况会使一个理论免于被事实推翻的可能。一是概念或分析模糊不清，不可能清楚地错，所以不可能清楚地被事实推翻；二是相互矛盾的理论；三是理论的推测不能被观察到；四是理论推测会发生的现象没有限制。</p>\n<p>因为事实不能以事实解释，以理论解释现象，在某种程度上一定是抽象的。理论有四种非真实，前三种可以接受。一是理论本身必定有抽象的成分，因为事实不能解释事实；二是事实或观察的描述必须经过简化，减少对无关属性的描述；三是为便于处理而作简化，减少无关现象所带来的复杂；四是验证条件的假设，虽为假设，却不能脱离现实。</p>\n<p>推测与解释是同一回事，但有事前与事后之分。</p>\n<p>读完该章，我决定在以后的讨论和分析中，对感性和理性一定要加以判断区分。如果是讨论一些主观上的东西，大可不必浪费时间去争论，此时最需要的是尊重他人的喜恶。但是，如果是讨论一些客观的，科学的东西，我应该秉着科学的态度，减小感情方面的因素所带来的影响。比如跟我讨论的那个人我不喜欢或嫉妒，又或者为了面子而坚持自己的想法肯定正确，别人的想法肯定错误。</p>\n<p>在解释某个理论或思想时，使用一些贴切的例子可以达到事半功倍的效果。这是我以后写文章需要加强的地方。</p>\n<h2 id=\"第二章：从自私说起\"><a href=\"#第二章：从自私说起\" class=\"headerlink\" title=\"第二章：从自私说起\"></a>第二章：从自私说起</h2><p>在这一章，张老指出了经济学最重要的几个基础假设。</p>\n<p>一，“个人”是所有经济分析的基本单位。这是因为所有取舍或选择都是由个人做主的。“人会做选择”。经济学的第一个公理是任何人的行为，都是由个人作出可以被推测的选择而起。</p>\n<p>二，每个人的任何行为，都是自私自利的。重要的不是人究竟是怎样，而是我们要假设人是怎样。然后以这个假设为出发点去推测事实。任何的行为都需要使用自私自利这个假设来解释，但解释时需要加入一些局限条件，否则就成了没有内容的套套逻辑。</p>\n<p>人的自私本质，来源于斯密的自然淘汰观。斯密指出了自私可以给社会整体带来巨大的利益，但却轻视了自私也会给社会带来害处。这是张老的重点。</p>\n<p>假若人的本质是自私的不能更改，那么一个基于人的自私可以被更改的“主义”，其制度政策会失败。</p>\n<p>说过了，这里说的“自私”是“局限下争取个人利益极大化”的简称，是个假设，毫无价值观，是好是坏无关宏旨也。</p>\n<h2 id=\"第三章：缺乏与竞争\"><a href=\"#第三章：缺乏与竞争\" class=\"headerlink\" title=\"第三章：缺乏与竞争\"></a>第三章：缺乏与竞争</h2><p>在这一章中，张老讲了经济学中的两个不可或缺的概念：缺乏与竞争。</p>\n<p>以理论来解释行为，行为一定要受到理论的约束。</p>\n<p>凡是有胜于无的东西，不管有形或无形，都是物品。物品又可以分为两大类：其一是经济物品；其二是免费物品。在有胜于无之中，有一大部分是多胜于少的，其为经济物品。</p>\n<p>“多胜于少”是经济物品的定义，也是“缺乏”的定义。“缺乏”是因为在需求下，供应有限而引起的。凡是有人愿意付出或多或少的代价来争取多一点的物品，都是缺乏的、不足够的，那就是经济物品了。</p>\n<p>竞争的定义，是指一种经济物品的需求有多于一人的需求。因为缺乏而引起的竞争，跟任何运动一样，是要有游戏规则的。产权制度是竞争的游戏规则，也就是约束行为的一种局限条件。阿尔钦说得好，“产”、竞争、缺乏这三个词是同义的。</p>\n<p>在自由市场，价高者得，市价于是成为决定胜负的准则。促成这市价的游戏规则，是私有产权的制度。</p>\n<p>张老认为准则在先而游戏规则在后。因为决定胜负的准则所决定的，是人类以竞争来解决的问题，而游戏规则只不过是协助准则的成立而已。</p>\n<p>因为竞争准则对人的收入、享受有决定性的作用，所以在不同的准则下，人的行为会跟着不同。</p>\n<p>一般书本说的、比较容易明白但不大正确的浪费概念：一般而言，浪费是指有其他办法，或用其他资源使用的分配，可使社会的财富或收入增加，但这些“其他”办法却莫名其妙地不予采用。</p>\n<p>唯一没有浪费的竞争准则，是市价。</p>\n<p>在不同的竞争准则下，胜或负的人各各不同。一些人喜欢选择某一种准则，另一些人会选择另一种。这些行为属于经济学的范畴。但哪一种准则是好是坏，或对社会福利有何好处，则是伦理或价值观的事。</p>\n<p>经济学不能判断什么是好是坏。经济学的范畴包括三部分。</p>\n<p>第一，在知道有关的局限条件或游戏规则（即产权制度或人与人之间的权利划分）的情况下，推断所用的竞争准则是什么。</p>\n<p>第二，在有了竞争的准则的情况下，推断人的行为会怎样，资源的使用会怎样，财富或收入的分配会怎样。</p>\n<p>第三，解释游戏规则是怎样形成的。</p>\n<h2 id=\"第四章：功用的理念\"><a href=\"#第四章：功用的理念\" class=\"headerlink\" title=\"第四章：功用的理念\"></a>第四章：功用的理念</h2><p>在这一章中，张老反对功用理论。其主要原因是，“功用”只不过是经济学者想象出来的概念，不是事实，所以要推断出可以被事实验证的含意不仅困难，而且陷阱太多，以致推出来的很容易是套套逻辑。</p>\n<p>“功用”是武断地以数字排列选择的定名。引入“功用”只是为了给各种选择一个名称，方便描述选择。</p>\n<p>替换定理：每一个人都愿意牺牲任何物品来换取任何其他的物品，只要牺牲的够少，而换得的够多。</p>\n<p>“等优曲线”就是根据替换定理推出的，关于两种经济物品在这些点上的功用数字相同的曲线。（不明白以甲乙的什么为横纵轴。功用？）</p>\n<p>再增加行为约束，则等优曲线一定是内凸（向左下弯曲）的。因为假设功用数字不变（在同一等优曲线上），一个人拥有甲物品愈多，其意愿以乙物品替换甲物品的意图必定下降。</p>\n<p>收入增加而需求量减少的物品，称为贫穷物品。某物品的价格下降带来的实质收入增加，导致该物品的需求量下降，称为吉芬物品。吉芬物品只能在一人世界存在，不可能在有竞争的社会存在。</p>\n<p>对于不能在市场成交或无从以金钱度量的经济物品，可以用其代价做替换，从而完全抛弃功用理论。</p>\n<h2 id=\"第五章：需求定律\"><a href=\"#第五章：需求定律\" class=\"headerlink\" title=\"第五章：需求定律\"></a>第五章：需求定律</h2><p>在这一章中，张老讲解了需求定理的定义和应用。</p>\n<p>需求定律是说任何物品的价格下降，其需求量必定上升。</p>\n<p>前一章的功用分析推不出一条一定向右下倾斜的需求曲线，无法推出需求定律。对于没有市价的物品，我们可以用代价或牺牲替换，需求定律依然可用。</p>\n<p>需求量是指需求者的意图之量，在真实世界不存在。因此，我们必须加上其他的验证条件（可以观察到的局限条件的转变），才可以用需求定律推出可以被事实验证的假说。</p>\n<p>关于观察，有三类。第一类是无从观察的，实际上不存在，比如需求量。第二类是可以观察到的真有其物，比如价格。第三类是原则上可以观察到，但实际上观察很困难，我们要想办法找寻间接的替代来作验证，比如边际产量。</p>\n<p>解释行为需要以事实验证假说，真实世界不存在的变量或术语愈少愈好。说故事与科学解释是两回事。</p>\n<p>以一种物品来说，除了这物品的价格与需求量这两个变量之外，可以影响该物品的需求量的其他变量或因素数之不尽。其他可变但假设不变的量称为参数。要维护需求定律的解释里，哪些量可变哪些量不可变是大话题。</p>\n<p>需求定律约束着价格或代价（一个变量）与需求量（另一个变量）之间的关系。然而，可以影响需求量的因素多如天上星，价格只是其中之一罢了。</p>\n<p>其他不变量的选择准则：只要需求定律的验证含意不被事实推翻，其他的不变因素愈少愈好——其他可变量愈多愈好——因为这会增加需求定律的解释现象的广泛性。</p>\n<p>在该准则下，如下的三项“不变”与“变”的界定是“安全”的——安全者，不被事实推翻也。</p>\n<p>（一）凡是直接影响价格的其他因素皆可变。<br>（二）凡是直接影响需求量的其他因素皆不可变。<br>（三）价格转变会导致需求量的转变，这价格转变也可能导致其他因素的转变，而这些“其他因素”可能再影响需求量。这些在“中间”的、间接地影响需求量的因素（变量）皆可变。</p>\n<p>要以需求定律解释行为，应该假设每个人的品味不变。以品味解释行为的困难是我们不是上帝，不能判断一个人的品味是怎样的，也不能判断这个人的品味是否改变了。即使我们知道品味是什么，如何变化。但是这时我们仍然需要知道品味转变的原因，但如果知道成因，我们根本无须提及品味的转变。</p>\n<p>斯密指出价值有两种，其一是用值，其二是换值。顾名思义，用值是某物品给予拥有者或享有者的最高所值，或这个人愿意付出的最高代价。换值是获取该物品时所需要付出的代价，而在市场上，换值就是该物品的市价了。</p>\n<p>何为价？价是一个消费者对某物品在边际上所愿意付出的最高代价。</p>\n<p>某物品的边际用值比市价高，消费者会多够一点；若比市价低，这消费者当然不会购买。这是个人争取最大利益的假设使然。</p>\n<p>何为量？成交量和需求量是两回事。成交量是事实，是可以观察到的。需求量不是事实，无从观察，是个概念，没有经济学者“需求量”是不存在的。</p>\n<p>概念上，需求量是指在不同的价格（换值）下，消费者意图换取的最高的量。需求曲线于是成为在不同价格下最高的不同需求量的界线。</p>\n<p>量，可分为“有质”的与“委托”的两大类，也有两者的合并。凡是质量被直接度量而算价的，是有质的量。相反则为委托的量。</p>\n<p>需求定律永远用于价格及其直接联系着的量之间的关系。（说白了就是价格体现在物品的什么上，是物品的重量，还是物品的数量）</p>\n<p>用值与换值的差额就是消费者的盈余。因为顾客的需求曲线各个不同，多些不同的收费安排，榨取消费者盈余可以“榨”得“尽”一点。</p>\n<p>价格下降，购买者对该物品的消费总额可能下降也可能上升。从出售者那边看，减价后的收入可能下降也可能上升。其决定关键是需求的价格弹性。要记着，价格弹性系数是从一个价位来算的。一条需求曲线有数之不尽的价位，价格弹性系数可以价价不同：曲线上某部分的弹性系数大于一，某部分小于一。</p>\n<p>阿尔钦与施蒂格勒提出需求第二定律：弹性系数的大小与时间是正相关的。他们认为，找寻替代物品来替换是需要时间的。时间愈长，替换的机会愈大，所以该物品的价格弹性系数是与时间正相关的。张老的反驳是，替换物品有时众所周知，不需要找寻。这样，价格上升，消费者立刻转用已知的替代物品，但用了一段时期，认为不称意，就转回旧物那方面去了。</p>\n<h2 id=\"第六章：小试牛刀\"><a href=\"#第六章：小试牛刀\" class=\"headerlink\" title=\"第六章：小试牛刀\"></a>第六章：小试牛刀</h2><p>张老在这一章中展示了需求定律的预测能力。由需求定律推出来的事实可以向物理学或化学那样精确。</p>\n<p>差不多任何物品，要准确地判断其质量不容易。我们往往要花很大的功夫才能成为一样物品的衡量专家。所以一般来说，无知，加上自己以往的经验，同类之物，我们往往见到价格较高就会认为质量较好。这样的判断不一定对，但对的机会不会差。我们会认为市价较高质量应该较好，因为市场已作了鉴别。以价判质过程真实且重要。（这里的分析如下，如果有一个两克拉的钻石卖1000块，我们一般会觉得是假的，也就是说钻石的质量很低，自然我们就不愿意付1000块钱交换。）</p>\n<p>其他因素、验证条件与局限条件这三者有相同之处，但在角度上有重要的差别。下面以需求定律来解释。</p>\n<p>一条向右下倾斜的需求曲线约束某物品的价与量的关系，二者皆是变量。“其他因素”是指这两个变量之外的所有其他变量，有些我们让其变，有些不让其变。</p>\n<p>以需求定律而言，验证条件是其他因素中的一小部分，是那些为了要创造一个可以被事实验证的含意而指定的条件。如果在你面前有两个不同的假说，你可以想啊想，想出一个或几个验证条件。指定了之后，在逻辑上，事实或现象只可以支持两个假说的其中一个。这就是关键验证。</p>\n<p>“局限条件”是指约束行为的所有条件。以需求定律而言，局限条件不仅包括其他的有关因素，包括验证条件，也包括价格。</p>\n<p>整个经济学的原理或定理其实不多。问题是运用起来，以这些原理解释世事，其困难程度会大幅上升。大致上，困难有三方面的。</p>\n<p>（一）世界的局限条件——约束每个人争取最大利益的局限——非常复杂。<br>（二）验证含意——甲的发生会导致乙的发生——这里的甲与乙，又或加上丙、丁等的有关变量，必须可以在真实世界中观察到。需求定律中的需求量是一个意图的变量，并非事实。那就是说，需求定律的本身是不可以验证的。我们要以需求定律，加上局限条件的变化，从逻辑推出可以被事实验证的含意。这里验证条件的指定要讲功夫了。<br>（三）其他因素的变与不变的选择。</p>\n<p>需求定律是经济学的灵魂，而这灵魂的重点是要懂得怎样处理需求量这个抽象概念。以需求定律解释行为，我们要不是能以逻辑把需求量与成交量挂钩，就是不管成交量，单以需求量转变的含意来解释现象。</p>\n<p>“单质”是指一种物品只有一种质量，于是质多量多，质少量少，质与量相同。</p>\n<p>单质的需求验证。影印行为的示范：从加薪转到研究金的局限转变（验证条件），需求定律可以推出影印的数量会上升。解释：由于研究金能使用的范围小，所以研究金的一毫比加薪的一毫所值要少，比如是六仙。那么由需求定律，价格下降，需求量上升。而需求量表现为影印数量。</p>\n<p>多质的需求验证。例子：美国华盛顿州的顶级苹果（红苹果）大都卖出口（比如卖到香港），而本地人多吃次级苹果。解释：因为有了固定的运费，糖分及其他质量上升时（从次级变为顶级），这些质的间接之价在香港跌得很快。对于香港的消费者，不管是次级还是顶级苹果，都需要在糖分的费用上加上一个固定的运费，从而次级苹果的价格相对来说更贵。</p>\n<h2 id=\"第七章：交易理论与市场需求\"><a href=\"#第七章：交易理论与市场需求\" class=\"headerlink\" title=\"第七章：交易理论与市场需求\"></a>第七章：交易理论与市场需求</h2><p>张老在这一章，讲解了交易理论（主要是没有交易生产的交易）和市场需求（是个人需求之和，有两种换算方式）。</p>\n<p>要决解人与人之间的竞争，我们的社会发明了制度。制度有多种，市场是其中之一。</p>\n<p>交易是上下交征利（相互之间都得到利益），与没有交易相比，个人的利益增加大得惊人。但这庞大的利益增加，主要是由于每个人专业生产，然后交易。不谈生产而单论交易，利益还是有的，但比起有专业生产的存在，其交易的利益少很多，近于微不足道。</p>\n<p>没有专业生产的交易，大家有利可图，主要是因为大家对物品的边际用值不同。当边际用值与市值（换值）相等时，就达到了市场均衡，也达到了帕累托条件（帕累托说：资源的使用与物品的交易可以达到一个情况或条件，满足了这个条件，我们不可能改变资源的使用，使一个人得益而没有其他人受损。换言之，要是这个条件不达到，我们总可以改变资源的使用或市场的交易，而使社会起码有一个人得益而没有其他人受损——这也等于可使整个社会的人得益）。</p>\n<p>市场需求是所有个人需求加起来而成的。私用品（一个人享用其他的人就不能享用）的市场需求曲线是个别需求者的不同需求曲线向右横加（P为每价，Q为该价的所有需求者的需求量之和）而成的。</p>\n<p>每个需求的人都以市价与自己的边际用值相比，然后购进或沽出。每个人都这样做，其结果是每个人的边际用值皆与市价相等，而人与人之间对这物品的边际用值也因而相等。</p>\n<p>物品的市场需求曲线与市场供应曲线的相交之价，是市价，又称均衡市价，而每个需求者的边际用值与之看齐。相交之价，不是因为马歇尔所说的剪刀决定的。而是因为数之不尽的需求者与供应者，各自争取最高的交易利益，导致均衡市价出现。</p>\n<p>对于市价的厘定，不是像一些经济学者认为的是因为市场需求曲线与市场供应曲线相交。正相反，这市场二线相交，是因为数之不尽的需求者与供应者各自为战，争取自己的边际用值与市价相等，从而促成了市场二线相交。</p>\n<p>短缺与过剩皆空中楼阁，不是真实世界之物。</p>\n<p>经济学者发明的稳定的均衡与不稳定的均衡，是为了故扮高深，与世事无关。可以用简单的分析来处理复杂的均衡问题。价格若高于或低于市价，市场需求者的边际用值会低于或高于价格。他们为了增加私利，会沽出使价格下降，或购入使价格上升。市价于是因为人的自私而升降，也因为人的自私而安定下来。所以说，需求定律是包含着“个人争取利益极大化”这个假设或公理。</p>\n<p>价格管制是价格被管制在市价之下，需求的一方见自己的边际用值高于价格，竞争抢购不获，逼着要付出金钱价格之外的其他代价来作补充而争取。这些其他的补充准则可能是排队轮购，可能是论资排辈、武力解决、政治手法、人际关系等等。于是会有另一种均衡，不会有“短缺”，而竞争就会被解决了。“短缺”是因为经济学者的思想有所短缺而产生的。</p>\n<p>价格管制的分析困难，不是因为不均衡，而是我们不知道哪一种金钱之外的准则会被采用。</p>\n<p>市场这种制度的出现，是为了减少某些交易或社会费用，这些减少了的费用是些什么，是一个大难题。</p>\n<h2 id=\"第八章：共用品的经济分析\"><a href=\"#第八章：共用品的经济分析\" class=\"headerlink\" title=\"第八章：共用品的经济分析\"></a>第八章：共用品的经济分析</h2><p>张老在这一章阐述了自己对共用品的认识。</p>\n<p>共用品的性质是共用，多人可以共享而不干扰他人的享用，多供应一个人的边际费用或成本为零。差不多所有的物品都具有共用品与私用品的性质。市场喜欢以私用品的量作价，因为私用品比较容易隔离不付费的享用者。这里注意区分私用和私有，以及共用和公有，他们是完全不同的概念。</p>\n<p>我们对同一个物品的边际用值不同，为了达到帕累托条件，商家需要实行价格分歧，但是价格分歧的费用奇高，因为商家不容易知道我们各自的边际用值。</p>\n<p>私用品的市场需求曲线是每价加量，即向右横加。共用品的市场需求曲线是每量加价，即向上竖加。</p>\n<p>萨缪尔森认为，共用品多供应一个人的边际费用或成本为零，所以共用品不应该收费。但是张老分析认为，如果边际成本为零不应该收费，那么近于零的也不应该收费。进而分析如果收费低于平均成本或费用，私营一定亏本，而如果收费等于或高于平均成本，那么收费会在边际成本之上（因为平均成本因为产量增加而下降）。所以，收费高于边际成本，对社会有害无益，从而得出不收费或由政府资助而又管制价格的上策。这是一种价值观，老生常谈了。</p>\n<p>牵扯到收费问题，共用品有互相矛盾的两种看法。其一是要采用价格分歧，收到尽，才可以达到帕累托条件。其二是多供应一个享用者的边际费用或成本是零，应该一律不收费。是有趣的价值观，不可以解释市场现象，却可以解释某些政客及经济学者的行为。</p>\n<p>张老举钢琴演奏家的例子来反驳萨缪尔森的观点。因为共用品可以私营产出，再把共用品捆绑着私用品一起销售，可以隔离不付费的人，减少交易费用。</p>\n<p>共用品大家可以一起享用，但也有挤迫情况，大家不是完全没有干扰。这里的要点是：无论怎么挤迫，只要共用品的量不变，不会因为挤迫而变为私用品。挤迫会导致个别享用者的需求曲线上、下移动，不会左、右移动。产出共用品的人要考虑的是市场的需求，不是个别人士的需求。</p>\n<h2 id=\"第九章：经济学的理论结构与哲学性质\"><a href=\"#第九章：经济学的理论结构与哲学性质\" class=\"headerlink\" title=\"第九章：经济学的理论结构与哲学性质\"></a>第九章：经济学的理论结构与哲学性质</h2><p>张老在这一章讲了经济学的理论结构（通过一张图表），以及对经济学的哲学性质的思考。</p>\n<p>交易理论与市场需求图：</p>\n<p><img src=\"/images/economic-explanation-v1/Steven.Cheung's.Demand.jpg\" alt=\"交易理论与市场需求\"></p>\n<p>注：附图以纵轴为价（P），横轴为量（Q）。竖直的S线代表着某物品的供应总量（Q*），假设固定不变。有A与B两个人，dA与dB分别是二者对该物品的需求曲线。先假设在交易之前该物品全部为B所有。这样，该物品给B的边际用值是M。A完全没有该物品，其边际用值是N。在这情况下，如果交易之价高于M，B会出售给A。另一方面，如果购买之价低于N，A会购入。均衡点是B的边际用值与A的边际用值相等。从图表可见，B出售到Y点，他的边际用值会跟A购入到X点的边际用值相等，而B的售出量（EY）一定与A的购入量（PX）相等。P是他俩的成交价，也即是市价。A获得的总用值是面积ONXqA，付出的总换值是面积OPXqA，所以面积NXP是A的交易总利。B放弃的总用值是面积YMQ*qB，获得的总换值是面积YEQ*qB（即OPXqA），所以面积YEM成为B出售给A所获的总利。把A的需求曲线dA与B的需求曲线dB每价向右横加而得到A与B合共的需求曲线，也就是市场的需求曲线了。B的需求曲线（dB）对着镜子就成了B的供应或售出曲线，即sB。sB在X那点与A的需求曲线（dA）相交，代表着B的边际成本与A的边际用值相等，是从另一个角度看市场均衡。</p>\n<p>张老认为的经济学的哲学性质：作为一门以武断假设或公理为起点的科学，除了边际产量下降定律，这些公理不是基于一些可以观察到的或真有其物的生理细胞或基因的运作，而是基于自然淘汰，是从人类的行为引申回头而获得的定义或规律。不同公理或武断假设之间没有矛盾，推得出可以用事实验证的假说，就成为一门实证科学了。因为经济学的公理的非真实性比自然科学的来得普及，科学的方法逻辑就比其他自然科学有较大的监管用场了。</p>\n<p>同样是公理性的科学，自然淘汰的思维，用于自然科学要从公理含意着的微小现象的变化入手，单用于经济学则要倒转过来，以人类行为的规律细节把公理或定义作修改或补充，是对还是错，最终的衡量是问这些公理约束着的人类的行为能否经得起自然淘汰的蹂躏。</p>\n"},{"title":"学习LLVM第1篇：官方入门教程笔记","date":"2020-07-08T16:18:02.000Z","excerpt":"按：本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。","_content":"\n官方教程地址：https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\n\n\n\n## 简介\n\n这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。\n\n教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。\n\n如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。\n\n\n\n## 每个章节详解\n\n下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。\n\n\n\n### 第1、2章\n\n实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。\n\n词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。\n\n语法解析部分使用了自顶向下的递归下降语法分析方法（[Recursive Descent Parsing](http://en.wikipedia.org/wiki/Recursive_descent_parser)），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。\n\n不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（[Operator-Precedence Parsing](http://en.wikipedia.org/wiki/Operator-precedence_parser)）。具体的原理大概是这样子的，比如对于`a + b * c`表达式，`+`的优先级为10，`*`的优先级为20。在解析到`+`号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析`+`号。具体到这个例子，`*`号的优先级比`+`号的高，所以在解析到`a + b`的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的`*`号是否优先级更高。因为`*`号的优先级较高，所以会让`a +`先等着，先解析`b * c`。得到一个表达式后作为一个完整的操作数（作为`+`号的第二个操作数），并回来解析`a +`。\n\n语言BNF定义如下：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n示例代码：\n\n```\nextern sin(arg); # 外部函数\nsin(1);\n\ndef f(a b c)\n  a + (b * c);\nf(1, 2, 3);\n```\n\n\n\n### 第3章\n\n这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：\n\n![](/images/llvm-1/AST.png)\n\n接下来我们来看两个示例，看下他们对应的AST的样子：\n\n1. 函数定义示例\n\n   ```\n   def add (a b)\n     a + b;\n   ```\n\n   ![](/images/llvm-1/FuncDef.png)\n\n2. 表达式示例\n\n   ```\n   add(1, 2);\n   ```\n\n   ![](/images/llvm-1/Expr.png)\n\n有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用`ConstantFP::get(TheContext, APFloat(Val))`即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：\n\n```c++\n// NumExpr:\nConstantFP::get(TheContext, APFloat(Val));\n\n// VariableExpr:\n// 根据名称从NamedValues Map中获取对应的Value\nValue *V = NamedValues[Name];\n\n// CallExpr:\n// 1. 根据函数名称获取前面定义了的函数实例\nFunction *CalleeF = TheModule->getFunction(Callee);\n// 2. 确定每个参数的Value\nstd::vector<Value *> ArgsV;\nfor (unsigned i = 0, e = Args.size(); i != e; ++i) {\n  ArgsV.push_back(Args[i]->codegen());\n  if (!ArgsV.back())\n    return nullptr;\n}\n// 3. 创建Call指令\nBuilder.CreateCall(CalleeF, ArgsV, \"calltmp\");\n\n// BinaryExpr:\n// 1. 确定左右操作数的Value\nValue *L = LHS->codegen();\nValue *R = RHS->codegen();\n// 2. 根据操作符，创建对应的操作\nswitch (Op) {\n  case '+':\n    return Builder.CreateFAdd(L, R, \"addtmp\");\n  case '-':\n    return Builder.CreateFSub(L, R, \"subtmp\");\n  case '*':\n    return Builder.CreateFMul(L, R, \"multmp\");\n  case '<':\n    L = Builder.CreateFCmpULT(L, R, \"cmptmp\");\n    // Convert bool 0/1 to double 0.0 or 1.0\n    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), \"booltmp\");\n}\n\n// FuncProto:\n// 创建参数列表的类型\nstd::vector<Type *> Doubles(Args.size(), Type::getDoubleTy(TheContext));\n// 函数原型\nFunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);\n// 生成函数实例\nFunction *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());\n\n// FuncDef:\nFunction *TheFunction = Proto->codegen();\n// 收集参数变量，用于body中的访问\nNamedValues.clear();\nfor (auto &Arg : TheFunction->args()) {\n  NamedValues[Arg.getName()] = &Arg;\n}\n// 创建函数的body BB，并设置指令插入的位置为底部\nBasicBlock *BB = BasicBlock::Create(TheContext, \"entry\", TheFunction);\nBuilder.SetInsertPoint(BB);\nValue *RetVal = Body->codegen();\n// 设置返回指定，指定返回的内容\nBuilder.CreateRet(RetVal);\n```\n\n在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：\n\n```\nextern foo(a);\ndef foo(b) b; // 两个函数原型的参数名称不一样\n```\n\n下面给出我的解决方法：\n\n```c++\nFunction *TheFunction = TheModule->getFunction(Proto->getName());\nif (!TheFunction) {\n  TheFunction = Proto->codegen();\n} else {\n  // 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了\n  unsigned idx = 0;\n  for (auto &Arg : TheFunction->args()) {\n    // getArgName是新增的根据idx获取参数名称的方法\n    Arg.setName(Proto->getArgName(idx++));\n  }\n}\n```\n\n\n\n### 第4章\n\n讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。\n\n关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：\n\n```c++\nvoid InitializeModuleAndPassManager(void) {\n  TheModule = std::make_unique<Module>(\"my cool jit\", TheContext);\n  TheFPM = std::make_unique<FunctionPassManager>(TheModule.get());\n\n  // 优化一：Do simple \"peephole\" optimizations and bit-twiddling optzns.\n  TheFPM->add(createInstructionCombiningPass());\n  // 优化二：Reassociate expressions.\n  TheFPM->add(createReassociatePass());\n  // 优化三：Eliminate Common SubExpressions.\n  TheFPM->add(createGVNPass());\n  // 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).\n  TheFPM->add(createCFGSimplificationPass());\n\n  TheFPM->doInitialization();\n}\n```\n\n对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：\n\n```c++\n  if (auto FnAST = ParseTopLevelExpr()) {\n    if (FnAST->codegen()) {\n      // 将TopLevelExpr所在的模块添加到JIT实例中\n      auto H = TheJIT->addModule(std::move(TheModule));\n      InitializeModuleAndPassManager();\n\n      // 编译万之后找到__anon_expr的内存地址\n      auto ExprSymbol = TheJIT->findSymbol(\"__anon_expr\");\n      // 转化为函数指针后进行调用\n      double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();\n      fprintf(stderr, \"Evaluated to %f\\n\", FP());\n      // 执行完之后删除\n      TheJIT->removeModule(H);\n    }\n```\n\n另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。\n\n\n\n### 第5章\n\n本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。\n\n扩展后语言的BNF定义如下：\n\n```\n...\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n...\n```\n\n示例代码：\n\n```\n# If语句\nif 1 < 2 \nthen 3\nelse f(1, 2, 3);\n\n# For语句，1.00增长步伐可以省略\nfor i = 0, i < 100, 1.00 in\n  f(1, 2, i);\n```\n\nIR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。\n\n生成条件语句的LLVM IR：\n\n```c++\nValue *CondV = Cond->codegen();\nCondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(TheContext, APFloat(0.0)), \"ifcond\");\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *ThenBB = BasicBlock::Create(TheContext, \"then\", TheFunction); // 自动加到函数中\nBasicBlock *ElseBB = BasicBlock::Create(TheContext, \"else\");\nBasicBlock *MergeBB = BasicBlock::Create(TheContext, \"ifcont\");\n\nBuilder.CreateCondBr(CondV, ThenBB, ElseBB); // 插入条件分支语句的指令\n\n// Then语句处理\nBuilder.SetInsertPoint(ThenBB);\nValue *ThenV = Then->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nThenBB = Builder.GetInsertBlock(); // 获取Then语句的出口\n\n// Else语句处理\nTheFunction->getBasicBlockList().push_back(ElseBB); // 添加到函数中去\nBuilder.SetInsertPoint(ElseBB);\nValue *ElseV = Else->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nElseBB = Builder.GetInsertBlock(); // 获取Else语句的出口\n\n// PHI指令的生成\nTheFunction->getBasicBlockList().push_back(MergeBB);\nBuilder.SetInsertPoint(MergeBB);\nPHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, \"iftmp\");\nPN->addIncoming(ThenV, ThenBB);\nPN->addIncoming(ElseV, ElseBB);\n```\n\n生成For语句的LLVM IR：\n\n```c++\nValue *StartVal = Start->codegen();\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *PreheaderBB = Builder.GetInsertBlock();\nBasicBlock *LoopBB = BasicBlock::Create(TheContext, \"loop\", TheFunction);\nBuilder.CreateBr(LoopBB); // 跳转到Loop分支\n\nBuilder.SetInsertPoint(LoopBB);\n// 创建PHI节点\nPHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, VarName.c_str());\nVariable->addIncoming(StartVal, PreheaderBB);\nNamedValues[VarName] = Variable; // 将for定义的变量添加到作用域中\nBody->codegen();\nValue *StepVal = Step->codegen();\nValue *NextVar = Builder.CreateFAdd(Variable, StepVal, \"nextvar\");\nValue *EndCond = End->codegen();\nEndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(TheContext, APFloat(0.0)), \"loopcond\");\nBasicBlock *LoopEndBB = Builder.GetInsertBlock(); // 为啥不可以直接使用LoopBB，而是还要获取一次呢？\nBasicBlock *AfterBB = BasicBlock::Create(TheContext, \"afterloop\", TheFunction);\nBuilder.CreateCondBr(EndCond, LoopBB, AfterBB);\n\nBuilder.SetInsertPoint(AfterBB);\nVariable->addIncoming(NextVar, LoopEndBB);\n```\n\n\n\n### 第6章\n\n本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：\n\n```\n...\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\n...\n```\n\n示例代码：\n\n```\n# 取反\ndef unary ! (v)\n  if v then 0 else 1;\n\n# 或运算，5为二元操作符的优先级\ndef binary | 5 (LHS RHS)\n  if LHS then\n    1\n  else \n    if RHS then\n      1\n    else\n      0;\n```\n\n这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。\n\n\n\n### 第7章\n\n本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了`mem2reg`的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用`mem2reg`Pass进行转化即可。\n\n这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为`mem2reg`只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。\n\n语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n              |  ident \"=\" Expr\n              |  \"var\" VarDef [ \",\" VarDef ] \"in\" Expr\nVarDef        -> ident | ident \"=\" Expr\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n新增语法对应的示例代码：\n\n```\ndef binary : 1 (x y) y; # 取两个表达式中的后一个表达式\n\ndef fib(x)\n  var a = 1, b = 1, c in\n  (for i = 3, i < x in\n     c = a + b :\n     a = b :\n     b = c) :\n  b;\n\nfib(10);\n```\n\n\n\n### 第8章\n\n本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。\n\n```c++\nauto TargetTriple = sys::getDefaultTargetTriple();\nInitializeAllTargetInfos();\nInitializeAllTargets();\nInitializeAllTargetMCs();\nInitializeAllAsmParsers();\nInitializeAllAsmPrinters();\n// 获取当前平台相关的Target\nstd::string Error;\nauto Target = TargetRegistry::lookupTarget(TargetTriple, Error);\n// 生成TargetMatchine\nauto CPU = \"generic\";\nauto Features = \"\";\nTargetOptions opt;\nauto RM = Optional<Reloc::Model>();\nauto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, RM);\n// 生成目标代码\nauto Filename = \"output.o\";\nstd::error_code EC;\nraw_fd_ostream dest(Filename, EC, sys::fs::OF_None);\nlegacy::PassManager pass;\nauto FileType = CGFT_ObjectFile;\nTargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)\npass.run(*TheModule);\ndest.flush(); // 更新到磁盘\n```\n\n\n\n### 第9章\n\n本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是[DWARF](http://dwarfstd.org)标准格式的调试信息。\n\n具体的代码可以直接看对应的章节。\n\n\n\n### 第10章\n\n本章是最后的总结。\n\n首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。\n\n然后是讲了下LLVM的一些属性：\n\n- LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。\n- LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。\n- 编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass\n\n最后提到了两个避坑指令：\n\n- 关于`offset/sizeof`的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt)。\n\n- 关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt)\n\n\n\n## 遇到的问题\n\n- 第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给`--libs`增加`orcjit`参数\n  - 原来：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native`\n  - 需改为：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit` \n  - 或者直接改为`all`：`llvm-config --cxxflags --ldflags --system-libs --libs all`\n\n","source":"_posts/llvm-1.md","raw":"---\ntitle: 学习LLVM第1篇：官方入门教程笔记\ndate: 2020-07-09 00:18:02\ncategories:\n- llvm\ntags:\n- llvm\nexcerpt: 按：本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。\n---\n\n官方教程地址：https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\n\n\n\n## 简介\n\n这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。\n\n教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。\n\n如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。\n\n\n\n## 每个章节详解\n\n下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。\n\n\n\n### 第1、2章\n\n实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。\n\n词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。\n\n语法解析部分使用了自顶向下的递归下降语法分析方法（[Recursive Descent Parsing](http://en.wikipedia.org/wiki/Recursive_descent_parser)），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。\n\n不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（[Operator-Precedence Parsing](http://en.wikipedia.org/wiki/Operator-precedence_parser)）。具体的原理大概是这样子的，比如对于`a + b * c`表达式，`+`的优先级为10，`*`的优先级为20。在解析到`+`号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析`+`号。具体到这个例子，`*`号的优先级比`+`号的高，所以在解析到`a + b`的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的`*`号是否优先级更高。因为`*`号的优先级较高，所以会让`a +`先等着，先解析`b * c`。得到一个表达式后作为一个完整的操作数（作为`+`号的第二个操作数），并回来解析`a +`。\n\n语言BNF定义如下：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n示例代码：\n\n```\nextern sin(arg); # 外部函数\nsin(1);\n\ndef f(a b c)\n  a + (b * c);\nf(1, 2, 3);\n```\n\n\n\n### 第3章\n\n这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：\n\n![](/images/llvm-1/AST.png)\n\n接下来我们来看两个示例，看下他们对应的AST的样子：\n\n1. 函数定义示例\n\n   ```\n   def add (a b)\n     a + b;\n   ```\n\n   ![](/images/llvm-1/FuncDef.png)\n\n2. 表达式示例\n\n   ```\n   add(1, 2);\n   ```\n\n   ![](/images/llvm-1/Expr.png)\n\n有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用`ConstantFP::get(TheContext, APFloat(Val))`即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：\n\n```c++\n// NumExpr:\nConstantFP::get(TheContext, APFloat(Val));\n\n// VariableExpr:\n// 根据名称从NamedValues Map中获取对应的Value\nValue *V = NamedValues[Name];\n\n// CallExpr:\n// 1. 根据函数名称获取前面定义了的函数实例\nFunction *CalleeF = TheModule->getFunction(Callee);\n// 2. 确定每个参数的Value\nstd::vector<Value *> ArgsV;\nfor (unsigned i = 0, e = Args.size(); i != e; ++i) {\n  ArgsV.push_back(Args[i]->codegen());\n  if (!ArgsV.back())\n    return nullptr;\n}\n// 3. 创建Call指令\nBuilder.CreateCall(CalleeF, ArgsV, \"calltmp\");\n\n// BinaryExpr:\n// 1. 确定左右操作数的Value\nValue *L = LHS->codegen();\nValue *R = RHS->codegen();\n// 2. 根据操作符，创建对应的操作\nswitch (Op) {\n  case '+':\n    return Builder.CreateFAdd(L, R, \"addtmp\");\n  case '-':\n    return Builder.CreateFSub(L, R, \"subtmp\");\n  case '*':\n    return Builder.CreateFMul(L, R, \"multmp\");\n  case '<':\n    L = Builder.CreateFCmpULT(L, R, \"cmptmp\");\n    // Convert bool 0/1 to double 0.0 or 1.0\n    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), \"booltmp\");\n}\n\n// FuncProto:\n// 创建参数列表的类型\nstd::vector<Type *> Doubles(Args.size(), Type::getDoubleTy(TheContext));\n// 函数原型\nFunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);\n// 生成函数实例\nFunction *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());\n\n// FuncDef:\nFunction *TheFunction = Proto->codegen();\n// 收集参数变量，用于body中的访问\nNamedValues.clear();\nfor (auto &Arg : TheFunction->args()) {\n  NamedValues[Arg.getName()] = &Arg;\n}\n// 创建函数的body BB，并设置指令插入的位置为底部\nBasicBlock *BB = BasicBlock::Create(TheContext, \"entry\", TheFunction);\nBuilder.SetInsertPoint(BB);\nValue *RetVal = Body->codegen();\n// 设置返回指定，指定返回的内容\nBuilder.CreateRet(RetVal);\n```\n\n在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：\n\n```\nextern foo(a);\ndef foo(b) b; // 两个函数原型的参数名称不一样\n```\n\n下面给出我的解决方法：\n\n```c++\nFunction *TheFunction = TheModule->getFunction(Proto->getName());\nif (!TheFunction) {\n  TheFunction = Proto->codegen();\n} else {\n  // 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了\n  unsigned idx = 0;\n  for (auto &Arg : TheFunction->args()) {\n    // getArgName是新增的根据idx获取参数名称的方法\n    Arg.setName(Proto->getArgName(idx++));\n  }\n}\n```\n\n\n\n### 第4章\n\n讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。\n\n关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：\n\n```c++\nvoid InitializeModuleAndPassManager(void) {\n  TheModule = std::make_unique<Module>(\"my cool jit\", TheContext);\n  TheFPM = std::make_unique<FunctionPassManager>(TheModule.get());\n\n  // 优化一：Do simple \"peephole\" optimizations and bit-twiddling optzns.\n  TheFPM->add(createInstructionCombiningPass());\n  // 优化二：Reassociate expressions.\n  TheFPM->add(createReassociatePass());\n  // 优化三：Eliminate Common SubExpressions.\n  TheFPM->add(createGVNPass());\n  // 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).\n  TheFPM->add(createCFGSimplificationPass());\n\n  TheFPM->doInitialization();\n}\n```\n\n对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：\n\n```c++\n  if (auto FnAST = ParseTopLevelExpr()) {\n    if (FnAST->codegen()) {\n      // 将TopLevelExpr所在的模块添加到JIT实例中\n      auto H = TheJIT->addModule(std::move(TheModule));\n      InitializeModuleAndPassManager();\n\n      // 编译万之后找到__anon_expr的内存地址\n      auto ExprSymbol = TheJIT->findSymbol(\"__anon_expr\");\n      // 转化为函数指针后进行调用\n      double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();\n      fprintf(stderr, \"Evaluated to %f\\n\", FP());\n      // 执行完之后删除\n      TheJIT->removeModule(H);\n    }\n```\n\n另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。\n\n\n\n### 第5章\n\n本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。\n\n扩展后语言的BNF定义如下：\n\n```\n...\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n...\n```\n\n示例代码：\n\n```\n# If语句\nif 1 < 2 \nthen 3\nelse f(1, 2, 3);\n\n# For语句，1.00增长步伐可以省略\nfor i = 0, i < 100, 1.00 in\n  f(1, 2, i);\n```\n\nIR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。\n\n生成条件语句的LLVM IR：\n\n```c++\nValue *CondV = Cond->codegen();\nCondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(TheContext, APFloat(0.0)), \"ifcond\");\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *ThenBB = BasicBlock::Create(TheContext, \"then\", TheFunction); // 自动加到函数中\nBasicBlock *ElseBB = BasicBlock::Create(TheContext, \"else\");\nBasicBlock *MergeBB = BasicBlock::Create(TheContext, \"ifcont\");\n\nBuilder.CreateCondBr(CondV, ThenBB, ElseBB); // 插入条件分支语句的指令\n\n// Then语句处理\nBuilder.SetInsertPoint(ThenBB);\nValue *ThenV = Then->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nThenBB = Builder.GetInsertBlock(); // 获取Then语句的出口\n\n// Else语句处理\nTheFunction->getBasicBlockList().push_back(ElseBB); // 添加到函数中去\nBuilder.SetInsertPoint(ElseBB);\nValue *ElseV = Else->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nElseBB = Builder.GetInsertBlock(); // 获取Else语句的出口\n\n// PHI指令的生成\nTheFunction->getBasicBlockList().push_back(MergeBB);\nBuilder.SetInsertPoint(MergeBB);\nPHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, \"iftmp\");\nPN->addIncoming(ThenV, ThenBB);\nPN->addIncoming(ElseV, ElseBB);\n```\n\n生成For语句的LLVM IR：\n\n```c++\nValue *StartVal = Start->codegen();\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *PreheaderBB = Builder.GetInsertBlock();\nBasicBlock *LoopBB = BasicBlock::Create(TheContext, \"loop\", TheFunction);\nBuilder.CreateBr(LoopBB); // 跳转到Loop分支\n\nBuilder.SetInsertPoint(LoopBB);\n// 创建PHI节点\nPHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, VarName.c_str());\nVariable->addIncoming(StartVal, PreheaderBB);\nNamedValues[VarName] = Variable; // 将for定义的变量添加到作用域中\nBody->codegen();\nValue *StepVal = Step->codegen();\nValue *NextVar = Builder.CreateFAdd(Variable, StepVal, \"nextvar\");\nValue *EndCond = End->codegen();\nEndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(TheContext, APFloat(0.0)), \"loopcond\");\nBasicBlock *LoopEndBB = Builder.GetInsertBlock(); // 为啥不可以直接使用LoopBB，而是还要获取一次呢？\nBasicBlock *AfterBB = BasicBlock::Create(TheContext, \"afterloop\", TheFunction);\nBuilder.CreateCondBr(EndCond, LoopBB, AfterBB);\n\nBuilder.SetInsertPoint(AfterBB);\nVariable->addIncoming(NextVar, LoopEndBB);\n```\n\n\n\n### 第6章\n\n本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：\n\n```\n...\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\n...\n```\n\n示例代码：\n\n```\n# 取反\ndef unary ! (v)\n  if v then 0 else 1;\n\n# 或运算，5为二元操作符的优先级\ndef binary | 5 (LHS RHS)\n  if LHS then\n    1\n  else \n    if RHS then\n      1\n    else\n      0;\n```\n\n这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。\n\n\n\n### 第7章\n\n本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了`mem2reg`的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用`mem2reg`Pass进行转化即可。\n\n这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为`mem2reg`只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。\n\n语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n              |  ident \"=\" Expr\n              |  \"var\" VarDef [ \",\" VarDef ] \"in\" Expr\nVarDef        -> ident | ident \"=\" Expr\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n新增语法对应的示例代码：\n\n```\ndef binary : 1 (x y) y; # 取两个表达式中的后一个表达式\n\ndef fib(x)\n  var a = 1, b = 1, c in\n  (for i = 3, i < x in\n     c = a + b :\n     a = b :\n     b = c) :\n  b;\n\nfib(10);\n```\n\n\n\n### 第8章\n\n本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。\n\n```c++\nauto TargetTriple = sys::getDefaultTargetTriple();\nInitializeAllTargetInfos();\nInitializeAllTargets();\nInitializeAllTargetMCs();\nInitializeAllAsmParsers();\nInitializeAllAsmPrinters();\n// 获取当前平台相关的Target\nstd::string Error;\nauto Target = TargetRegistry::lookupTarget(TargetTriple, Error);\n// 生成TargetMatchine\nauto CPU = \"generic\";\nauto Features = \"\";\nTargetOptions opt;\nauto RM = Optional<Reloc::Model>();\nauto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, RM);\n// 生成目标代码\nauto Filename = \"output.o\";\nstd::error_code EC;\nraw_fd_ostream dest(Filename, EC, sys::fs::OF_None);\nlegacy::PassManager pass;\nauto FileType = CGFT_ObjectFile;\nTargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)\npass.run(*TheModule);\ndest.flush(); // 更新到磁盘\n```\n\n\n\n### 第9章\n\n本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是[DWARF](http://dwarfstd.org)标准格式的调试信息。\n\n具体的代码可以直接看对应的章节。\n\n\n\n### 第10章\n\n本章是最后的总结。\n\n首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。\n\n然后是讲了下LLVM的一些属性：\n\n- LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。\n- LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。\n- 编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass\n\n最后提到了两个避坑指令：\n\n- 关于`offset/sizeof`的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt)。\n\n- 关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt)\n\n\n\n## 遇到的问题\n\n- 第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给`--libs`增加`orcjit`参数\n  - 原来：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native`\n  - 需改为：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit` \n  - 或者直接改为`all`：`llvm-config --cxxflags --ldflags --system-libs --libs all`\n\n","slug":"llvm-1","published":1,"updated":"2020-11-01T09:07:19.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk09001grnq77j2p1cji","content":"<p>官方教程地址：<a href=\"https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。</p>\n<p>教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。</p>\n<p>如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。</p>\n<h2 id=\"每个章节详解\"><a href=\"#每个章节详解\" class=\"headerlink\" title=\"每个章节详解\"></a>每个章节详解</h2><p>下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。</p>\n<h3 id=\"第1、2章\"><a href=\"#第1、2章\" class=\"headerlink\" title=\"第1、2章\"></a>第1、2章</h3><p>实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。</p>\n<p>词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。</p>\n<p>语法解析部分使用了自顶向下的递归下降语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Recursive_descent_parser\">Recursive Descent Parsing</a>），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。</p>\n<p>不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Operator-precedence_parser\">Operator-Precedence Parsing</a>）。具体的原理大概是这样子的，比如对于<code>a + b * c</code>表达式，<code>+</code>的优先级为10，<code>*</code>的优先级为20。在解析到<code>+</code>号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析<code>+</code>号。具体到这个例子，<code>*</code>号的优先级比<code>+</code>号的高，所以在解析到<code>a + b</code>的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的<code>*</code>号是否优先级更高。因为<code>*</code>号的优先级较高，所以会让<code>a +</code>先等着，先解析<code>b * c</code>。得到一个表达式后作为一个完整的操作数（作为<code>+</code>号的第二个操作数），并回来解析<code>a +</code>。</p>\n<p>语言BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern sin(arg); # 外部函数</span><br><span class=\"line\">sin(1);</span><br><span class=\"line\"></span><br><span class=\"line\">def f(a b c)</span><br><span class=\"line\">  a + (b * c);</span><br><span class=\"line\">f(1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第3章\"><a href=\"#第3章\" class=\"headerlink\" title=\"第3章\"></a>第3章</h3><p>这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：</p>\n<p><img src=\"/images/llvm-1/AST.png\"></p>\n<p>接下来我们来看两个示例，看下他们对应的AST的样子：</p>\n<ol>\n<li><p>函数定义示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def add (a b)</span><br><span class=\"line\">  a + b;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/FuncDef.png\"></p>\n</li>\n<li><p>表达式示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1, 2);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/Expr.png\"></p>\n</li>\n</ol>\n<p>有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用<code>ConstantFP::get(TheContext, APFloat(Val))</code>即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NumExpr:</span></span><br><span class=\"line\">ConstantFP::get(TheContext, APFloat(Val));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VariableExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称从NamedValues Map中获取对应的Value</span></span><br><span class=\"line\">Value *V = NamedValues[Name];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CallExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 根据函数名称获取前面定义了的函数实例</span></span><br><span class=\"line\">Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class=\"line\"><span class=\"comment\">// 2. 确定每个参数的Value</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class=\"line\">  ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!ArgsV.back())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 3. 创建Call指令</span></span><br><span class=\"line\">Builder.CreateCall(CalleeF, ArgsV, <span class=\"string\">&quot;calltmp&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BinaryExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 确定左右操作数的Value</span></span><br><span class=\"line\">Value *L = LHS-&gt;codegen();</span><br><span class=\"line\">Value *R = RHS-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 2. 根据操作符，创建对应的操作</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (Op) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFAdd(L, R, <span class=\"string\">&quot;addtmp&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFSub(L, R, <span class=\"string\">&quot;subtmp&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFMul(L, R, <span class=\"string\">&quot;multmp&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&lt;&#x27;</span>:</span><br><span class=\"line\">    L = Builder.CreateFCmpULT(L, R, <span class=\"string\">&quot;cmptmp&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class=\"string\">&quot;booltmp&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncProto:</span></span><br><span class=\"line\"><span class=\"comment\">// 创建参数列表的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Type *&gt; <span class=\"title\">Doubles</span><span class=\"params\">(Args.size(), Type::getDoubleTy(TheContext))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 函数原型</span></span><br><span class=\"line\">FunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 生成函数实例</span></span><br><span class=\"line\">Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncDef:</span></span><br><span class=\"line\">Function *TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 收集参数变量，用于body中的访问</span></span><br><span class=\"line\">NamedValues.clear();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">  NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建函数的body BB，并设置指令插入的位置为底部</span></span><br><span class=\"line\">BasicBlock *BB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;entry&quot;</span>, TheFunction);</span><br><span class=\"line\">Builder.SetInsertPoint(BB);</span><br><span class=\"line\">Value *RetVal = Body-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 设置返回指定，指定返回的内容</span></span><br><span class=\"line\">Builder.CreateRet(RetVal);</span><br></pre></td></tr></table></figure>\n\n<p>在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern foo(a);</span><br><span class=\"line\">def foo(b) b; &#x2F;&#x2F; 两个函数原型的参数名称不一样</span><br></pre></td></tr></table></figure>\n\n<p>下面给出我的解决方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!TheFunction) &#123;</span><br><span class=\"line\">  TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// getArgName是新增的根据idx获取参数名称的方法</span></span><br><span class=\"line\">    Arg.setName(Proto-&gt;getArgName(idx++));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><p>讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。</p>\n<p>关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitializeModuleAndPassManager</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  TheModule = <span class=\"built_in\">std</span>::make_unique&lt;Module&gt;(<span class=\"string\">&quot;my cool jit&quot;</span>, TheContext);</span><br><span class=\"line\">  TheFPM = <span class=\"built_in\">std</span>::make_unique&lt;FunctionPassManager&gt;(TheModule.get());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优化一：Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化二：Reassociate expressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createReassociatePass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化三：Eliminate Common SubExpressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createGVNPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class=\"line\">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class=\"line\"></span><br><span class=\"line\">  TheFPM-&gt;doInitialization();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将TopLevelExpr所在的模块添加到JIT实例中</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> H = TheJIT-&gt;addModule(<span class=\"built_in\">std</span>::move(TheModule));</span><br><span class=\"line\">    InitializeModuleAndPassManager();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 编译万之后找到__anon_expr的内存地址</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class=\"string\">&quot;__anon_expr&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 转化为函数指针后进行调用</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> (*FP)() = (<span class=\"keyword\">double</span> (*)())(<span class=\"keyword\">intptr_t</span>)ExprSymbol.getAddress();</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Evaluated to %f\\n&quot;</span>, FP());</span><br><span class=\"line\">    <span class=\"comment\">// 执行完之后删除</span></span><br><span class=\"line\">    TheJIT-&gt;removeModule(H);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。</p>\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><p>本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。</p>\n<p>扩展后语言的BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># If语句</span><br><span class=\"line\">if 1 &lt; 2 </span><br><span class=\"line\">then 3</span><br><span class=\"line\">else f(1, 2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\"># For语句，1.00增长步伐可以省略</span><br><span class=\"line\">for i &#x3D; 0, i &lt; 100, 1.00 in</span><br><span class=\"line\">  f(1, 2, i);</span><br></pre></td></tr></table></figure>\n\n<p>IR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。</p>\n<p>生成条件语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *CondV = Cond-&gt;codegen();</span><br><span class=\"line\">CondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">&quot;ifcond&quot;</span>);</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;then&quot;</span>, TheFunction); <span class=\"comment\">// 自动加到函数中</span></span><br><span class=\"line\">BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;else&quot;</span>);</span><br><span class=\"line\">BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;ifcont&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.CreateCondBr(CondV, ThenBB, ElseBB); <span class=\"comment\">// 插入条件分支语句的指令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Then语句处理</span></span><br><span class=\"line\">Builder.SetInsertPoint(ThenBB);</span><br><span class=\"line\">Value *ThenV = Then-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ThenBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Then语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Else语句处理</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(ElseBB); <span class=\"comment\">// 添加到函数中去</span></span><br><span class=\"line\">Builder.SetInsertPoint(ElseBB);</span><br><span class=\"line\">Value *ElseV = Else-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ElseBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Else语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PHI指令的生成</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(MergeBB);</span><br><span class=\"line\">Builder.SetInsertPoint(MergeBB);</span><br><span class=\"line\">PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, <span class=\"string\">&quot;iftmp&quot;</span>);</span><br><span class=\"line\">PN-&gt;addIncoming(ThenV, ThenBB);</span><br><span class=\"line\">PN-&gt;addIncoming(ElseV, ElseBB);</span><br></pre></td></tr></table></figure>\n\n<p>生成For语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *StartVal = Start-&gt;codegen();</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *PreheaderBB = Builder.GetInsertBlock();</span><br><span class=\"line\">BasicBlock *LoopBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;loop&quot;</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateBr(LoopBB); <span class=\"comment\">// 跳转到Loop分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(LoopBB);</span><br><span class=\"line\"><span class=\"comment\">// 创建PHI节点</span></span><br><span class=\"line\">PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, VarName.c_str());</span><br><span class=\"line\">Variable-&gt;addIncoming(StartVal, PreheaderBB);</span><br><span class=\"line\">NamedValues[VarName] = Variable; <span class=\"comment\">// 将for定义的变量添加到作用域中</span></span><br><span class=\"line\">Body-&gt;codegen();</span><br><span class=\"line\">Value *StepVal = Step-&gt;codegen();</span><br><span class=\"line\">Value *NextVar = Builder.CreateFAdd(Variable, StepVal, <span class=\"string\">&quot;nextvar&quot;</span>);</span><br><span class=\"line\">Value *EndCond = End-&gt;codegen();</span><br><span class=\"line\">EndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">&quot;loopcond&quot;</span>);</span><br><span class=\"line\">BasicBlock *LoopEndBB = Builder.GetInsertBlock(); <span class=\"comment\">// 为啥不可以直接使用LoopBB，而是还要获取一次呢？</span></span><br><span class=\"line\">BasicBlock *AfterBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;afterloop&quot;</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(AfterBB);</span><br><span class=\"line\">Variable-&gt;addIncoming(NextVar, LoopEndBB);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><p>本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 取反</span><br><span class=\"line\">def unary ! (v)</span><br><span class=\"line\">  if v then 0 else 1;</span><br><span class=\"line\"></span><br><span class=\"line\"># 或运算，5为二元操作符的优先级</span><br><span class=\"line\">def binary | 5 (LHS RHS)</span><br><span class=\"line\">  if LHS then</span><br><span class=\"line\">    1</span><br><span class=\"line\">  else </span><br><span class=\"line\">    if RHS then</span><br><span class=\"line\">      1</span><br><span class=\"line\">    else</span><br><span class=\"line\">      0;</span><br></pre></td></tr></table></figure>\n\n<p>这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p>本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了<code>mem2reg</code>的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用<code>mem2reg</code>Pass进行转化即可。</p>\n<p>这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为<code>mem2reg</code>只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。</p>\n<p>语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">              |  &quot;var&quot; VarDef [ &quot;,&quot; VarDef ] &quot;in&quot; Expr</span><br><span class=\"line\">VarDef        -&gt; ident | ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>新增语法对应的示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary : 1 (x y) y; # 取两个表达式中的后一个表达式</span><br><span class=\"line\"></span><br><span class=\"line\">def fib(x)</span><br><span class=\"line\">  var a &#x3D; 1, b &#x3D; 1, c in</span><br><span class=\"line\">  (for i &#x3D; 3, i &lt; x in</span><br><span class=\"line\">     c &#x3D; a + b :</span><br><span class=\"line\">     a &#x3D; b :</span><br><span class=\"line\">     b &#x3D; c) :</span><br><span class=\"line\">  b;</span><br><span class=\"line\"></span><br><span class=\"line\">fib(10);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><p>本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> TargetTriple = sys::getDefaultTargetTriple();</span><br><span class=\"line\">InitializeAllTargetInfos();</span><br><span class=\"line\">InitializeAllTargets();</span><br><span class=\"line\">InitializeAllTargetMCs();</span><br><span class=\"line\">InitializeAllAsmParsers();</span><br><span class=\"line\">InitializeAllAsmPrinters();</span><br><span class=\"line\"><span class=\"comment\">// 获取当前平台相关的Target</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> Error;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Target = TargetRegistry::lookupTarget(TargetTriple, Error);</span><br><span class=\"line\"><span class=\"comment\">// 生成TargetMatchine</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> CPU = <span class=\"string\">&quot;generic&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Features = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">TargetOptions opt;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> RM = Optional&lt;Reloc::Model&gt;();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</span><br><span class=\"line\"><span class=\"comment\">// 生成目标代码</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> Filename = <span class=\"string\">&quot;output.o&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::error_code EC;</span><br><span class=\"line\"><span class=\"function\">raw_fd_ostream <span class=\"title\">dest</span><span class=\"params\">(Filename, EC, sys::fs::OF_None)</span></span>;</span><br><span class=\"line\">legacy::PassManager pass;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> FileType = CGFT_ObjectFile;</span><br><span class=\"line\">TargetMachine-&gt;addPassesToEmitFile(pass, dest, <span class=\"literal\">nullptr</span>, FileType)</span><br><span class=\"line\">pass.run(*TheModule);</span><br><span class=\"line\">dest.flush(); <span class=\"comment\">// 更新到磁盘</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第9章\"><a href=\"#第9章\" class=\"headerlink\" title=\"第9章\"></a>第9章</h3><p>本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是<a href=\"http://dwarfstd.org/\">DWARF</a>标准格式的调试信息。</p>\n<p>具体的代码可以直接看对应的章节。</p>\n<h3 id=\"第10章\"><a href=\"#第10章\" class=\"headerlink\" title=\"第10章\"></a>第10章</h3><p>本章是最后的总结。</p>\n<p>首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。</p>\n<p>然后是讲了下LLVM的一些属性：</p>\n<ul>\n<li>LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。</li>\n<li>LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。</li>\n<li>编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass</li>\n</ul>\n<p>最后提到了两个避坑指令：</p>\n<ul>\n<li><p>关于<code>offset/sizeof</code>的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt\">这里</a>。</p>\n</li>\n<li><p>关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt\">这里</a></p>\n</li>\n</ul>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给<code>--libs</code>增加<code>orcjit</code>参数<ul>\n<li>原来：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native</code></li>\n<li>需改为：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit</code> </li>\n<li>或者直接改为<code>all</code>：<code>llvm-config --cxxflags --ldflags --system-libs --libs all</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"more":"<p>官方教程地址：<a href=\"https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。</p>\n<p>教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。</p>\n<p>如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。</p>\n<h2 id=\"每个章节详解\"><a href=\"#每个章节详解\" class=\"headerlink\" title=\"每个章节详解\"></a>每个章节详解</h2><p>下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。</p>\n<h3 id=\"第1、2章\"><a href=\"#第1、2章\" class=\"headerlink\" title=\"第1、2章\"></a>第1、2章</h3><p>实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。</p>\n<p>词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。</p>\n<p>语法解析部分使用了自顶向下的递归下降语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Recursive_descent_parser\">Recursive Descent Parsing</a>），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。</p>\n<p>不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Operator-precedence_parser\">Operator-Precedence Parsing</a>）。具体的原理大概是这样子的，比如对于<code>a + b * c</code>表达式，<code>+</code>的优先级为10，<code>*</code>的优先级为20。在解析到<code>+</code>号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析<code>+</code>号。具体到这个例子，<code>*</code>号的优先级比<code>+</code>号的高，所以在解析到<code>a + b</code>的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的<code>*</code>号是否优先级更高。因为<code>*</code>号的优先级较高，所以会让<code>a +</code>先等着，先解析<code>b * c</code>。得到一个表达式后作为一个完整的操作数（作为<code>+</code>号的第二个操作数），并回来解析<code>a +</code>。</p>\n<p>语言BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern sin(arg); # 外部函数</span><br><span class=\"line\">sin(1);</span><br><span class=\"line\"></span><br><span class=\"line\">def f(a b c)</span><br><span class=\"line\">  a + (b * c);</span><br><span class=\"line\">f(1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第3章\"><a href=\"#第3章\" class=\"headerlink\" title=\"第3章\"></a>第3章</h3><p>这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：</p>\n<p><img src=\"/images/llvm-1/AST.png\"></p>\n<p>接下来我们来看两个示例，看下他们对应的AST的样子：</p>\n<ol>\n<li><p>函数定义示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def add (a b)</span><br><span class=\"line\">  a + b;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/FuncDef.png\"></p>\n</li>\n<li><p>表达式示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1, 2);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/Expr.png\"></p>\n</li>\n</ol>\n<p>有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用<code>ConstantFP::get(TheContext, APFloat(Val))</code>即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NumExpr:</span></span><br><span class=\"line\">ConstantFP::get(TheContext, APFloat(Val));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VariableExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称从NamedValues Map中获取对应的Value</span></span><br><span class=\"line\">Value *V = NamedValues[Name];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CallExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 根据函数名称获取前面定义了的函数实例</span></span><br><span class=\"line\">Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class=\"line\"><span class=\"comment\">// 2. 确定每个参数的Value</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class=\"line\">  ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!ArgsV.back())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 3. 创建Call指令</span></span><br><span class=\"line\">Builder.CreateCall(CalleeF, ArgsV, <span class=\"string\">&quot;calltmp&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BinaryExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 确定左右操作数的Value</span></span><br><span class=\"line\">Value *L = LHS-&gt;codegen();</span><br><span class=\"line\">Value *R = RHS-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 2. 根据操作符，创建对应的操作</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (Op) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFAdd(L, R, <span class=\"string\">&quot;addtmp&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFSub(L, R, <span class=\"string\">&quot;subtmp&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFMul(L, R, <span class=\"string\">&quot;multmp&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&lt;&#x27;</span>:</span><br><span class=\"line\">    L = Builder.CreateFCmpULT(L, R, <span class=\"string\">&quot;cmptmp&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class=\"string\">&quot;booltmp&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncProto:</span></span><br><span class=\"line\"><span class=\"comment\">// 创建参数列表的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Type *&gt; <span class=\"title\">Doubles</span><span class=\"params\">(Args.size(), Type::getDoubleTy(TheContext))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 函数原型</span></span><br><span class=\"line\">FunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 生成函数实例</span></span><br><span class=\"line\">Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncDef:</span></span><br><span class=\"line\">Function *TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 收集参数变量，用于body中的访问</span></span><br><span class=\"line\">NamedValues.clear();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">  NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建函数的body BB，并设置指令插入的位置为底部</span></span><br><span class=\"line\">BasicBlock *BB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;entry&quot;</span>, TheFunction);</span><br><span class=\"line\">Builder.SetInsertPoint(BB);</span><br><span class=\"line\">Value *RetVal = Body-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 设置返回指定，指定返回的内容</span></span><br><span class=\"line\">Builder.CreateRet(RetVal);</span><br></pre></td></tr></table></figure>\n\n<p>在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern foo(a);</span><br><span class=\"line\">def foo(b) b; &#x2F;&#x2F; 两个函数原型的参数名称不一样</span><br></pre></td></tr></table></figure>\n\n<p>下面给出我的解决方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!TheFunction) &#123;</span><br><span class=\"line\">  TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// getArgName是新增的根据idx获取参数名称的方法</span></span><br><span class=\"line\">    Arg.setName(Proto-&gt;getArgName(idx++));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><p>讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。</p>\n<p>关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitializeModuleAndPassManager</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  TheModule = <span class=\"built_in\">std</span>::make_unique&lt;Module&gt;(<span class=\"string\">&quot;my cool jit&quot;</span>, TheContext);</span><br><span class=\"line\">  TheFPM = <span class=\"built_in\">std</span>::make_unique&lt;FunctionPassManager&gt;(TheModule.get());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优化一：Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化二：Reassociate expressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createReassociatePass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化三：Eliminate Common SubExpressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createGVNPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class=\"line\">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class=\"line\"></span><br><span class=\"line\">  TheFPM-&gt;doInitialization();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将TopLevelExpr所在的模块添加到JIT实例中</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> H = TheJIT-&gt;addModule(<span class=\"built_in\">std</span>::move(TheModule));</span><br><span class=\"line\">    InitializeModuleAndPassManager();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 编译万之后找到__anon_expr的内存地址</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class=\"string\">&quot;__anon_expr&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 转化为函数指针后进行调用</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> (*FP)() = (<span class=\"keyword\">double</span> (*)())(<span class=\"keyword\">intptr_t</span>)ExprSymbol.getAddress();</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Evaluated to %f\\n&quot;</span>, FP());</span><br><span class=\"line\">    <span class=\"comment\">// 执行完之后删除</span></span><br><span class=\"line\">    TheJIT-&gt;removeModule(H);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。</p>\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><p>本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。</p>\n<p>扩展后语言的BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># If语句</span><br><span class=\"line\">if 1 &lt; 2 </span><br><span class=\"line\">then 3</span><br><span class=\"line\">else f(1, 2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\"># For语句，1.00增长步伐可以省略</span><br><span class=\"line\">for i &#x3D; 0, i &lt; 100, 1.00 in</span><br><span class=\"line\">  f(1, 2, i);</span><br></pre></td></tr></table></figure>\n\n<p>IR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。</p>\n<p>生成条件语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *CondV = Cond-&gt;codegen();</span><br><span class=\"line\">CondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">&quot;ifcond&quot;</span>);</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;then&quot;</span>, TheFunction); <span class=\"comment\">// 自动加到函数中</span></span><br><span class=\"line\">BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;else&quot;</span>);</span><br><span class=\"line\">BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;ifcont&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.CreateCondBr(CondV, ThenBB, ElseBB); <span class=\"comment\">// 插入条件分支语句的指令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Then语句处理</span></span><br><span class=\"line\">Builder.SetInsertPoint(ThenBB);</span><br><span class=\"line\">Value *ThenV = Then-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ThenBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Then语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Else语句处理</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(ElseBB); <span class=\"comment\">// 添加到函数中去</span></span><br><span class=\"line\">Builder.SetInsertPoint(ElseBB);</span><br><span class=\"line\">Value *ElseV = Else-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ElseBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Else语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PHI指令的生成</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(MergeBB);</span><br><span class=\"line\">Builder.SetInsertPoint(MergeBB);</span><br><span class=\"line\">PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, <span class=\"string\">&quot;iftmp&quot;</span>);</span><br><span class=\"line\">PN-&gt;addIncoming(ThenV, ThenBB);</span><br><span class=\"line\">PN-&gt;addIncoming(ElseV, ElseBB);</span><br></pre></td></tr></table></figure>\n\n<p>生成For语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *StartVal = Start-&gt;codegen();</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *PreheaderBB = Builder.GetInsertBlock();</span><br><span class=\"line\">BasicBlock *LoopBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;loop&quot;</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateBr(LoopBB); <span class=\"comment\">// 跳转到Loop分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(LoopBB);</span><br><span class=\"line\"><span class=\"comment\">// 创建PHI节点</span></span><br><span class=\"line\">PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, VarName.c_str());</span><br><span class=\"line\">Variable-&gt;addIncoming(StartVal, PreheaderBB);</span><br><span class=\"line\">NamedValues[VarName] = Variable; <span class=\"comment\">// 将for定义的变量添加到作用域中</span></span><br><span class=\"line\">Body-&gt;codegen();</span><br><span class=\"line\">Value *StepVal = Step-&gt;codegen();</span><br><span class=\"line\">Value *NextVar = Builder.CreateFAdd(Variable, StepVal, <span class=\"string\">&quot;nextvar&quot;</span>);</span><br><span class=\"line\">Value *EndCond = End-&gt;codegen();</span><br><span class=\"line\">EndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">&quot;loopcond&quot;</span>);</span><br><span class=\"line\">BasicBlock *LoopEndBB = Builder.GetInsertBlock(); <span class=\"comment\">// 为啥不可以直接使用LoopBB，而是还要获取一次呢？</span></span><br><span class=\"line\">BasicBlock *AfterBB = BasicBlock::Create(TheContext, <span class=\"string\">&quot;afterloop&quot;</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(AfterBB);</span><br><span class=\"line\">Variable-&gt;addIncoming(NextVar, LoopEndBB);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><p>本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 取反</span><br><span class=\"line\">def unary ! (v)</span><br><span class=\"line\">  if v then 0 else 1;</span><br><span class=\"line\"></span><br><span class=\"line\"># 或运算，5为二元操作符的优先级</span><br><span class=\"line\">def binary | 5 (LHS RHS)</span><br><span class=\"line\">  if LHS then</span><br><span class=\"line\">    1</span><br><span class=\"line\">  else </span><br><span class=\"line\">    if RHS then</span><br><span class=\"line\">      1</span><br><span class=\"line\">    else</span><br><span class=\"line\">      0;</span><br></pre></td></tr></table></figure>\n\n<p>这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p>本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了<code>mem2reg</code>的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用<code>mem2reg</code>Pass进行转化即可。</p>\n<p>这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为<code>mem2reg</code>只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。</p>\n<p>语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">              |  &quot;var&quot; VarDef [ &quot;,&quot; VarDef ] &quot;in&quot; Expr</span><br><span class=\"line\">VarDef        -&gt; ident | ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>新增语法对应的示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary : 1 (x y) y; # 取两个表达式中的后一个表达式</span><br><span class=\"line\"></span><br><span class=\"line\">def fib(x)</span><br><span class=\"line\">  var a &#x3D; 1, b &#x3D; 1, c in</span><br><span class=\"line\">  (for i &#x3D; 3, i &lt; x in</span><br><span class=\"line\">     c &#x3D; a + b :</span><br><span class=\"line\">     a &#x3D; b :</span><br><span class=\"line\">     b &#x3D; c) :</span><br><span class=\"line\">  b;</span><br><span class=\"line\"></span><br><span class=\"line\">fib(10);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><p>本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> TargetTriple = sys::getDefaultTargetTriple();</span><br><span class=\"line\">InitializeAllTargetInfos();</span><br><span class=\"line\">InitializeAllTargets();</span><br><span class=\"line\">InitializeAllTargetMCs();</span><br><span class=\"line\">InitializeAllAsmParsers();</span><br><span class=\"line\">InitializeAllAsmPrinters();</span><br><span class=\"line\"><span class=\"comment\">// 获取当前平台相关的Target</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> Error;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Target = TargetRegistry::lookupTarget(TargetTriple, Error);</span><br><span class=\"line\"><span class=\"comment\">// 生成TargetMatchine</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> CPU = <span class=\"string\">&quot;generic&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Features = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">TargetOptions opt;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> RM = Optional&lt;Reloc::Model&gt;();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</span><br><span class=\"line\"><span class=\"comment\">// 生成目标代码</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> Filename = <span class=\"string\">&quot;output.o&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::error_code EC;</span><br><span class=\"line\"><span class=\"function\">raw_fd_ostream <span class=\"title\">dest</span><span class=\"params\">(Filename, EC, sys::fs::OF_None)</span></span>;</span><br><span class=\"line\">legacy::PassManager pass;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> FileType = CGFT_ObjectFile;</span><br><span class=\"line\">TargetMachine-&gt;addPassesToEmitFile(pass, dest, <span class=\"literal\">nullptr</span>, FileType)</span><br><span class=\"line\">pass.run(*TheModule);</span><br><span class=\"line\">dest.flush(); <span class=\"comment\">// 更新到磁盘</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第9章\"><a href=\"#第9章\" class=\"headerlink\" title=\"第9章\"></a>第9章</h3><p>本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是<a href=\"http://dwarfstd.org/\">DWARF</a>标准格式的调试信息。</p>\n<p>具体的代码可以直接看对应的章节。</p>\n<h3 id=\"第10章\"><a href=\"#第10章\" class=\"headerlink\" title=\"第10章\"></a>第10章</h3><p>本章是最后的总结。</p>\n<p>首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。</p>\n<p>然后是讲了下LLVM的一些属性：</p>\n<ul>\n<li>LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。</li>\n<li>LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。</li>\n<li>编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass</li>\n</ul>\n<p>最后提到了两个避坑指令：</p>\n<ul>\n<li><p>关于<code>offset/sizeof</code>的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt\">这里</a>。</p>\n</li>\n<li><p>关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt\">这里</a></p>\n</li>\n</ul>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给<code>--libs</code>增加<code>orcjit</code>参数<ul>\n<li>原来：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native</code></li>\n<li>需改为：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit</code> </li>\n<li>或者直接改为<code>all</code>：<code>llvm-config --cxxflags --ldflags --system-libs --libs all</code></li>\n</ul>\n</li>\n</ul>\n"},{"title":"玩转React系列1：React工作原理","date":"2019-05-12T16:00:00.000Z","excerpt":"本文是玩转React系列的第一篇，全景式的讲解React的工作原理。","_content":"\n<!-- \n分享感受：2019年3月27日进行了React v15框架原理的分享。这次分享从19:10讲到了21:10多，共2个多小时。非常开心能有机会分享给这么多人听，而且一次分享了这么长时间。 \n-->\n\n## 目录\n\n- 0\\. 演示demo\n- 1\\. React Element及其渲染过程\n  - 1.1. 首次渲染过程\n  - 1.2. 更新渲染过程\n  - 1.3. 如果高效地更新渲染\n- 2\\. 从源码看渲染过程\n  - 2.1. 代码调用图\n  - 2.2. 首次渲染过程\n  - 2.3. 更新渲染过程\n  - 2.4. React列表更新策略的问题\n- A\\. 参考\n\n笔者在工作中持续使用了一年多的React，慢慢感觉React使用起来很简单，但是要掌握各种局限条件下的最佳实战却很难。比如怎么去封装好一个通用组件？哪些东西该暴露？哪些东西又不该暴露呢？为啥React这么强大却用起来很简单？这些问题，驱使我去探索React及其配套，我想看看React的设计原理，想看看一些优秀的第三方库的设计好坏。为此，我计划边探索边把自己的所得输出出来，形成一系列文章。相信输出过程可以让自己更加深入地理解React，也希望能给读者带来一些新的理解。本文是玩转系列的第一篇，全景式的讲解React的工作原理。\n\n本文包括两部分内容。首先整体介绍React中的核心概念**元素**（element，也叫虚拟DOM）及React对它的渲染过程。然后从源代码角度展示这一过程。本文阅读的是React v15版本的最新源码([GitHub地址](https://github.com/facebook/react/tree/15-stable))，包括react模块和浏览器环境下的renderer（react-dom模块中的一部分，不包括server render）。\n\n## 0. 演示demo\n\n为了讲解方便，引入一个基本的demo。另外为了简化起见，也没有使用jsx语法糖，对应的jsx可以在注释中看到。这个demo的功能是展示一个消息列表，涉及React初次渲染、更新渲染（包括列表）的功能，基本上涵盖了React的各个方面。[在线演示地址](https://codepen.io/lhtin/pen/JqvXQr)\n\ndemo主要的代码如下：\n\n```jsx\nclass Item extends React.Component {\n  render () {\n    return (\n      /* <p style={{color: this.props.color}}>{this.props.children}</p> */\n      React.createElement(\n        'p',\n        {style: {color: this.props.color}},\n        this.props.children\n      )\n    )\n  }\n}\nconst List = (props) => {\n  return (\n    /* <div> ... </div> */\n    React.createElement(\n      'div',\n      null,\n      props.list.map((item) => (\n        /* <Item key={item.key} color={item.color}>{item.content}</Item> */\n        React.createElement(\n          Item,\n          {\n            key: item.key,\n            color: item.color\n          },\n          item.content\n        )\n      ))\n    )\n  )\n}\nclass App extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      msgList: [{\n        key: 1,\n        color: '#f44336', // red\n        content: 'in constructor'\n      }]\n    }\n  }\n  componentDidMount () {\n    setTimeout(() => {\n      this.setState({\n        msgList: [\n          ...this.state.msgList,\n          {\n            key: 2,\n            color: '#4caf50', // green\n            content: 'in setTimeout'\n          }\n        ]\n      })\n    }, 3000)\n  }\n  render () {\n    return (\n      /* <List list={this.state.msgList} /> */\n      React.createElement(\n        List,\n        {list: this.state.msgList},\n        null\n      )\n    )\n  }\n}\nReactDOM.render(\n  /* <App /> */\n  React.createElement(App, null, null),\n  document.getElementById('app')\n)\n```\n\n## 1. React Element及其渲染过程\n\n在React中，有一种数据结构叫**元素**（element），通过`React.createElement(...)`或者使用JSX语法糖（最终也是编译为前者）创建。渲染过程，就是将React中的元素转换为UI界面（即`UI = render(element)`，浏览器环境下就是DOM树了）。元素是一个纯JS对象，仅包含type和props两个字段。type确定了元素的类型，props确定了渲染时的输入。根据type，可以将元素分两类，type是字符串的**host元素**和type是函数或class的**component元素**。整个渲染过程就是一步步递归渲染元素，最终结果是生成一颗纯host元素树，然后根据这个树去调用浏览器对应的API，创建DOM树。component元素的作用在于组合其他元素，**渲染它相当于渲染它所渲染的元素**。将host元素转换为DOM是一个繁琐的苦力活，需要处理好不同浏览器的兼容问题，本文不涉及这部分内容。\n\n对于host元素，React会先创建对应的DOM节点，然后递归渲染host元素的子元素列表（存储于`props.children`中），并将渲染后的子节点插入到当前节点中。对于component元素需要分情况看。如果component元素的type是一个函数，则将props当作参数传入执行，返回值为该元素所渲染的元素。如果type是一个class，则首先传入props初始化（如果之前没有初始化的话），然后调用实例的render方法获取所渲染的元素。host和component元素的渲染方式，在1.1和1.2小节中有详细的示例演示。\n\nReact的每一次渲染，从整体来看，可以分成两个独立的过程。首先是递归渲染，消除所有的component元素，得到一个纯host的元素树。然后，将host元素树转换为浏览器对于的DOM树。\n\n![渲染过程](/assets/react-v15/render-pass.jpg)\n\n示例demo的整体渲染过程（下面会具体讲解demo的每个渲染过程）：\n\n![示例渲染过程](/assets/react-v15/render-demo-pass.png)\n\n因为首次渲染和再次渲染有所区别，所以可以将所有的渲染分成两类，分别是首次渲染和更新渲染。\n\n### 1.1. 首次渲染过程\n\n首次渲染过程是从顶层元素开始的，顶层元素就是传给ReactDOM.render方法的元素。示例中的顶层元素是一个comoponent元素，type是App class，props为空，数据结构如下所示：\n\n```js\n{\n  type: App,\n  props: {}\n}\n```\n\n因为App是一个class，所以先初始化App，再调用实例的render方法得到所渲染的元素（见实例的`render`渲染方法），如下所示：\n\n```js\n{\n  type: List,\n  props: {\n    list: [{\n      key: 1,\n      color: '#f44336',\n      content: 'in constructor'\n    }]\n  }\n}\n```\n\n继续渲染上面的List元素，因为List是一个函数，直接将props作为参数传入调用List就得到了所渲染的元素，如下所示：\n\n```js\n{\n  type: 'div',\n  props: {\n    children: [{\n      type: Item,\n      props: {\n        key: 1,\n        color: '#f44336',\n        children: 'in constructor'\n      }\n    }]\n  }\n}\n```\n\n这时所渲染的元素是host元素，继续递归渲染其children元素，这里是type为Item class的元素，跟App元素一样的渲染方式，最终得到一颗纯host的元素树，如下所示：\n\n```js\n{\n  type: 'div',\n  props: {\n    children: [{\n      type: 'p',\n      props: {\n        key: 1,\n        style: { color: '#f44336' },\n        children: 'in constructor'\n      }\n    }]\n  }\n}\n```\n\n以上是渲染的第一个步骤，将元素递归渲染成纯host的元素树。第二步，将这颗纯host的元素树转化为等价的DOM树，用html语法表示如下：\n\n```html\n<div>\n  <p style=\"color: #f44336;\">in constructor</p>\n</div>\n```\n\n### 1.2. 更新渲染过程\n\n在demo中，首次渲染App元素时会得到一个App实例，渲染完成后调用该实例的`componentDidMount`生命周期。里面设置了一个定时器，3秒之后调用`setState`来更新App实例的状态，这时会促使React进入更新渲染过程。首次渲染过程是从顶层元素开始，而更新渲染过程是从被改变的元素开始。进一步，更新渲染过程从实例状态改变后**影响到的元素**（也就是实例所渲染的元素）开始。具体到demo中，就是从App实例所渲染的元素开始。\n\n更新前App实例所渲染的元素如下所示：\n\n```js\n{\n  type: List,\n  props: {\n    list: [{\n      key: 1,\n      color: '#f44336',\n      content: 'in constructor'\n    }]\n  }\n}\n```\n\n更新之后，msgList数据改变了，重新调用App组件实例的render方法，获取状态变化后所渲染的元素（相比于更新前，props中的list多了一项），如下所示：\n\n```js\n{\n  type: List,\n  props: {\n    list: [{\n      key: 1,\n      color: '#f44336',\n      content: 'in constructor'\n    }, {\n      key: 2,\n      color: '#4caf50',\n      content: 'in setTimeout'\n    }]\n  }\n}\n```\n\n之后的过程跟首次渲染过程一样，最终得到一颗纯host的元素树，如下所示：\n\n```js\n{\n  type: 'div',\n  props: {\n    children: [{\n      type: 'p',\n      props: {\n        style: { color: '#f44336' },\n        children: 'in constructor'\n      }\n    }, {\n      type: 'p',\n      props: {\n        style: { color: '#4caf50' },\n        children: 'in setTimeout'\n      }\n    }]\n  }\n}\n```\n\n对应的DOM树如下：\n\n```html\n<div>\n  <p style=\"color: #f44336;\">in constructor</p>\n  <p style=\"color: #4caf50;\">in setTimeout</p>\n</div>\n```\n\n### 1.3. 如何高效地更新渲染\n\n在实际的应用中，更新渲染是一个极其频繁的过程，网络数据的拉取（比如拉取到用户数据后展示出来）和用户的交互（比如点击展开详情按钮）都会触发更新渲染。在应用的元素数量比较多时，需要有一个高效的方式去更新。\n\n更新方式有两个极端。一是每次都完全创建新的DOM，即使只是DOM的属性变了。二是尽可能多地复用已有的DOM，减少创建。显然第一种方式是不能接受的，每次都重新创建的成本太高。即使只是元素的颜色变了，都会导致DOM的重建。而第二种方式，要达到目标，需要花大量时间在更新前后DOM树的判断上，让尽可能多的DOM复用。n个节点的DOM树，[目前的算法](https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf)时间复杂度为O(n<sup>3</sup>)，也就是说1000个元素的树需要进行10亿次比较，显然太耗时。\n\nReact综合了两种极端，实现了一种启发式算法。首先只对同层元素做比较。如果元素的type都不同，就认为是一颗全新的元素树，直接重建，不会往下递归比较子元素。如果type相同，则只更新属性，不需要重建。然后对于同type情况下的元素列表的更新，开发者可以通过指定key，来提示React带相同key的元素走更新而不是创建流程，从而进一步减少元素的更新次数：\n\n- diff算法关键点1：只比较同层元素（图片来自[React’s diff algorithm](https://calendar.perfplanet.com/2013/diff/)）\n  \n  ![diff1](/assets/react-v15/diff1.png)\n- diff算法关键点2：指定key，减少元素更新次数（图片来自[React’s diff algorithm](https://calendar.perfplanet.com/2013/diff/)）\n  \n  ![diff2](/assets/react-v15/diff2.png)\n\n## 2. 从源码看渲染过程\n\n上面从整体介绍了React的渲染过程，下面我们来看看这些过程在源码中的体现。在阅读文字描述时，建议读者参照下面给出的代码调用图，同时克隆源码([GitHub地址](https://github.com/facebook/react/tree/15-stable))并找到对应的方法。这样可以更容易理解源码的实现逻辑。\n\n### 2.1. 渲染逻辑代码调用流程图\n\n![代码调用图](/assets/react-v15/react-render.svg)\n<!-- https://drive.google.com/file/d/1OYSEFm-i4KGKMrcDj2G09PE1SwH3kes-/view?usp=sharing -->\n\n### 2.2. 首次渲染过程\n\n首次渲染，首先调用instantiateReactComponent初始化一个内部实例internalInstance（这个内部实例的作用是记录各种信息，供更新渲染的时候使用）。内部实例类型共四种，ReactCompositeComponent、ReactDOMComponent、ReactDOMEmptyComponent和ReactDOMTextComponent，后两种比较简单，重点看下前两种的。ReactCompositeComponent用于承载type为函数和class的元素，ReactDOMComponent用于承载type为字符串的元素。\n\n根据类型初始化对应的内部实例后，调用内部实例的mountComponent方法来获取当前元素所渲染的DOM树，然后将DOM树插入指定的容器中，显示在页面上。先来看下ReactCompositeComponent的该方法，首先是初始化当前元素的type，将得到的组件实例挂到内部实例的_instance属性上。对于type是函数类型的组件，内部会将其转化为一个等价的无状态的class组件。然后调用下组件的componentWillMount生命周期函数，之后调用组件实例的render方法获取当前元素所渲染的元素_renderedElement。有了子元素之后，就继续递归调用instantiateReactComponent初始化子元素对应的内部实例，然后调用对应的mountComponent方法，将它的返回值作为当前的方法返回出去。完成之后调用componentDidMount生命周期函数。详细流程图如下：\n\n![](/assets/react-v15/react-first-render-component-element.svg)\n\n如果是ReactDOMComponent，mountComponent过程首先是创建元素对应的DOM节点，同时将节点挂到内部实例的_hostNode属性上，然后将props中的属性更新到节点上，完了之后遍历props的children，依次初始化每个子元素对应的内部实例，然后调用其mountComponent，得到子节点列表，之后将子节点列表依次插到当前节点中，然后返回当前节点。详细流程图如下：\n\n![](/assets/react-v15/react-first-render-host-element.svg)\n\n### 2.3. 更新渲染过程\n\n当class组件实例在某些情况下调用setState时（比如demo中的App组件，在componentDidMount中3秒后调用了setState），就进入了更新流程。首先是将待更新的state添加到内部实例的_pendingStateQueue数组中，然后启动批量更新流程（如果不处在批量更新中的话），并将内部实例添加到dirtyComponents中。\n\n批量更新流程是这样子的，首先对dirtyComponents里面的组件进行排序，确保父组件比子组件先更新（减少子组件的更新次数），然后调用内部实例的updateComponent进行更新。在updateComponent里面，首先调用componentWillReceiveProps生命周期函数，再将state和_pendingStateQueue合并获得最新的状态nextState，然后调用shouldComponentUpdate（如果有的话）确定是否真的要更新。如果不需要更新，则只是简单的更新组件实例的props、state等属性。如果要更新，则再进一步判断是走更新渲染还是销毁重建。\n\n判断过程首先会先调用componentWillUpdate生命周期函数，之后更新组件实例的props、state等属性，更新完之后重新调用组件实例_instance的render方法获取新渲染的元素nextRenderedElement。比较_renderedElement和nextRenderedElement的type（**diff算法的第一个关键：只比较同层的元素，并且认为type不同的元素所渲染的元素不同，从而不需要再递归比较下去**），如果不同就进行销毁重建。销毁重建过程，首先调用所渲染元素对应的内部实例的unmountComponent销毁，然后跟首次渲染一样渲染nextRenderedElement（见2.2小节）。如果type相同，则走更新流程。详细流程图如下：\n\n![](/assets/react-v15/react-update-render-component-element.svg)\n\n在更新流程中，如果所渲染的内部实例是ReactCompositeComponent，则更新流程跟上文一样。如果是ReactDOMComponent，则首先根据新的props更新当前节点_hostNode的属性，然后递归更新子元素列表children。children的更新方式比较复杂，涉及到新增、移动和删除child元素。\n\nchildren的更新方式是，在prevChildren的基础上，通过判断type和key确定每个子元素是否可以复用（**diff算法的第二个关键，通过用户显式地指定key，确定哪些子元素可以复用**）。可以复用就保留child并更新，不能则移除掉。然后找到nextChildren中第一个同时出现在prevChildren中的child组成的最长子列表（出现的先后顺序与prevChildren一样）。详细流程图如下：\n\n![](/assets/react-v15/react-update-render-host-element.svg)\n\n举个例子。比如prevChildren是A、B、C、D，nextChildren是B、E、D、A、C，则最长子列表是B、D。因为在nextChildren第一个同时出现在prevChildren中的是B，往后找到最长的跟prevChildren先后顺序一样的子列表就是B、D了。接下来遍历nextChildren，如果child是B或者D，则不动，否则将其移动到前一个child后面。更形象的表示见下图：\n\n![](/assets/react-v15/update-children-demo.png)\n\n### 2.4. React列表更新策略的问题\n\n如果nextChildren只是将prevChildren的最后一个元素移动到第一个元素前面，按照前面children的更新方式，假设列表长度为n，则会造成n-1次移动，而实际上只需要移动一次（即将最后一个元素移动到第一个元素前面）。造成这样子的原因是因为固定不动的子列表是从nextChildren中第一个元素（同时出现在prevChildren）开始找的，因为第一个元素在prevChildren中是最后一个元素，自然不会再有更后面的元素了，所以这样找到的子列表就只包含了prevChildren中的最后一个元素。但是在这种情况下，nextChildren后面n-1个元素组成的子列表才是最长的。所以最好的方式应该是从nextChildren中找到最长的那一个子列表（出现的先后顺序跟prevChildren一致）。这个子列表可以不是从最早出现在prevChildren中的那个元素开始。如下图所示，不从第一个元素开始的话，找到的最长子元素是C、E、G、H，这样只需要移动4次就可以从S1转化为S2：\n\n![](/assets/react-v15/update-children-2-demo.png)\n\n那么是否存在这样一个可以接受的算法（时间复杂度在O(nlogn)以内），找到这个最长的子列表呢？如果找到了，是否性能就真的会更好？且听下回分解。\n\n## 参考\n\n- [React Components, Elements, and Instances](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)（本文完整的介绍了React涉及到的三个核心概念**组件**、**元素**、**组件实例**）\n- [Implementation Notes](https://reactjs.org/docs/implementation-notes.html)（本文最小实现了Rect v15的原理，代码结构跟源码类似）\n- [Reconciliation](https://reactjs.org/docs/reconciliation.html)、[React's diff algorithm](https://calendar.perfplanet.com/2013/diff/)、[React源码剖析系列——不可思议的react diff](https://zhuanlan.zhihu.com/p/20346379)（这三篇文章详细的介绍了React的更新策略）\n","source":"_posts/react-1.md","raw":"---\ntitle: 玩转React系列1：React工作原理\ndate: 2019/05/13\ncategories:\n- react\ntags:\n- note\nexcerpt: 本文是玩转React系列的第一篇，全景式的讲解React的工作原理。\n---\n\n<!-- \n分享感受：2019年3月27日进行了React v15框架原理的分享。这次分享从19:10讲到了21:10多，共2个多小时。非常开心能有机会分享给这么多人听，而且一次分享了这么长时间。 \n-->\n\n## 目录\n\n- 0\\. 演示demo\n- 1\\. React Element及其渲染过程\n  - 1.1. 首次渲染过程\n  - 1.2. 更新渲染过程\n  - 1.3. 如果高效地更新渲染\n- 2\\. 从源码看渲染过程\n  - 2.1. 代码调用图\n  - 2.2. 首次渲染过程\n  - 2.3. 更新渲染过程\n  - 2.4. React列表更新策略的问题\n- A\\. 参考\n\n笔者在工作中持续使用了一年多的React，慢慢感觉React使用起来很简单，但是要掌握各种局限条件下的最佳实战却很难。比如怎么去封装好一个通用组件？哪些东西该暴露？哪些东西又不该暴露呢？为啥React这么强大却用起来很简单？这些问题，驱使我去探索React及其配套，我想看看React的设计原理，想看看一些优秀的第三方库的设计好坏。为此，我计划边探索边把自己的所得输出出来，形成一系列文章。相信输出过程可以让自己更加深入地理解React，也希望能给读者带来一些新的理解。本文是玩转系列的第一篇，全景式的讲解React的工作原理。\n\n本文包括两部分内容。首先整体介绍React中的核心概念**元素**（element，也叫虚拟DOM）及React对它的渲染过程。然后从源代码角度展示这一过程。本文阅读的是React v15版本的最新源码([GitHub地址](https://github.com/facebook/react/tree/15-stable))，包括react模块和浏览器环境下的renderer（react-dom模块中的一部分，不包括server render）。\n\n## 0. 演示demo\n\n为了讲解方便，引入一个基本的demo。另外为了简化起见，也没有使用jsx语法糖，对应的jsx可以在注释中看到。这个demo的功能是展示一个消息列表，涉及React初次渲染、更新渲染（包括列表）的功能，基本上涵盖了React的各个方面。[在线演示地址](https://codepen.io/lhtin/pen/JqvXQr)\n\ndemo主要的代码如下：\n\n```jsx\nclass Item extends React.Component {\n  render () {\n    return (\n      /* <p style={{color: this.props.color}}>{this.props.children}</p> */\n      React.createElement(\n        'p',\n        {style: {color: this.props.color}},\n        this.props.children\n      )\n    )\n  }\n}\nconst List = (props) => {\n  return (\n    /* <div> ... </div> */\n    React.createElement(\n      'div',\n      null,\n      props.list.map((item) => (\n        /* <Item key={item.key} color={item.color}>{item.content}</Item> */\n        React.createElement(\n          Item,\n          {\n            key: item.key,\n            color: item.color\n          },\n          item.content\n        )\n      ))\n    )\n  )\n}\nclass App extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      msgList: [{\n        key: 1,\n        color: '#f44336', // red\n        content: 'in constructor'\n      }]\n    }\n  }\n  componentDidMount () {\n    setTimeout(() => {\n      this.setState({\n        msgList: [\n          ...this.state.msgList,\n          {\n            key: 2,\n            color: '#4caf50', // green\n            content: 'in setTimeout'\n          }\n        ]\n      })\n    }, 3000)\n  }\n  render () {\n    return (\n      /* <List list={this.state.msgList} /> */\n      React.createElement(\n        List,\n        {list: this.state.msgList},\n        null\n      )\n    )\n  }\n}\nReactDOM.render(\n  /* <App /> */\n  React.createElement(App, null, null),\n  document.getElementById('app')\n)\n```\n\n## 1. React Element及其渲染过程\n\n在React中，有一种数据结构叫**元素**（element），通过`React.createElement(...)`或者使用JSX语法糖（最终也是编译为前者）创建。渲染过程，就是将React中的元素转换为UI界面（即`UI = render(element)`，浏览器环境下就是DOM树了）。元素是一个纯JS对象，仅包含type和props两个字段。type确定了元素的类型，props确定了渲染时的输入。根据type，可以将元素分两类，type是字符串的**host元素**和type是函数或class的**component元素**。整个渲染过程就是一步步递归渲染元素，最终结果是生成一颗纯host元素树，然后根据这个树去调用浏览器对应的API，创建DOM树。component元素的作用在于组合其他元素，**渲染它相当于渲染它所渲染的元素**。将host元素转换为DOM是一个繁琐的苦力活，需要处理好不同浏览器的兼容问题，本文不涉及这部分内容。\n\n对于host元素，React会先创建对应的DOM节点，然后递归渲染host元素的子元素列表（存储于`props.children`中），并将渲染后的子节点插入到当前节点中。对于component元素需要分情况看。如果component元素的type是一个函数，则将props当作参数传入执行，返回值为该元素所渲染的元素。如果type是一个class，则首先传入props初始化（如果之前没有初始化的话），然后调用实例的render方法获取所渲染的元素。host和component元素的渲染方式，在1.1和1.2小节中有详细的示例演示。\n\nReact的每一次渲染，从整体来看，可以分成两个独立的过程。首先是递归渲染，消除所有的component元素，得到一个纯host的元素树。然后，将host元素树转换为浏览器对于的DOM树。\n\n![渲染过程](/assets/react-v15/render-pass.jpg)\n\n示例demo的整体渲染过程（下面会具体讲解demo的每个渲染过程）：\n\n![示例渲染过程](/assets/react-v15/render-demo-pass.png)\n\n因为首次渲染和再次渲染有所区别，所以可以将所有的渲染分成两类，分别是首次渲染和更新渲染。\n\n### 1.1. 首次渲染过程\n\n首次渲染过程是从顶层元素开始的，顶层元素就是传给ReactDOM.render方法的元素。示例中的顶层元素是一个comoponent元素，type是App class，props为空，数据结构如下所示：\n\n```js\n{\n  type: App,\n  props: {}\n}\n```\n\n因为App是一个class，所以先初始化App，再调用实例的render方法得到所渲染的元素（见实例的`render`渲染方法），如下所示：\n\n```js\n{\n  type: List,\n  props: {\n    list: [{\n      key: 1,\n      color: '#f44336',\n      content: 'in constructor'\n    }]\n  }\n}\n```\n\n继续渲染上面的List元素，因为List是一个函数，直接将props作为参数传入调用List就得到了所渲染的元素，如下所示：\n\n```js\n{\n  type: 'div',\n  props: {\n    children: [{\n      type: Item,\n      props: {\n        key: 1,\n        color: '#f44336',\n        children: 'in constructor'\n      }\n    }]\n  }\n}\n```\n\n这时所渲染的元素是host元素，继续递归渲染其children元素，这里是type为Item class的元素，跟App元素一样的渲染方式，最终得到一颗纯host的元素树，如下所示：\n\n```js\n{\n  type: 'div',\n  props: {\n    children: [{\n      type: 'p',\n      props: {\n        key: 1,\n        style: { color: '#f44336' },\n        children: 'in constructor'\n      }\n    }]\n  }\n}\n```\n\n以上是渲染的第一个步骤，将元素递归渲染成纯host的元素树。第二步，将这颗纯host的元素树转化为等价的DOM树，用html语法表示如下：\n\n```html\n<div>\n  <p style=\"color: #f44336;\">in constructor</p>\n</div>\n```\n\n### 1.2. 更新渲染过程\n\n在demo中，首次渲染App元素时会得到一个App实例，渲染完成后调用该实例的`componentDidMount`生命周期。里面设置了一个定时器，3秒之后调用`setState`来更新App实例的状态，这时会促使React进入更新渲染过程。首次渲染过程是从顶层元素开始，而更新渲染过程是从被改变的元素开始。进一步，更新渲染过程从实例状态改变后**影响到的元素**（也就是实例所渲染的元素）开始。具体到demo中，就是从App实例所渲染的元素开始。\n\n更新前App实例所渲染的元素如下所示：\n\n```js\n{\n  type: List,\n  props: {\n    list: [{\n      key: 1,\n      color: '#f44336',\n      content: 'in constructor'\n    }]\n  }\n}\n```\n\n更新之后，msgList数据改变了，重新调用App组件实例的render方法，获取状态变化后所渲染的元素（相比于更新前，props中的list多了一项），如下所示：\n\n```js\n{\n  type: List,\n  props: {\n    list: [{\n      key: 1,\n      color: '#f44336',\n      content: 'in constructor'\n    }, {\n      key: 2,\n      color: '#4caf50',\n      content: 'in setTimeout'\n    }]\n  }\n}\n```\n\n之后的过程跟首次渲染过程一样，最终得到一颗纯host的元素树，如下所示：\n\n```js\n{\n  type: 'div',\n  props: {\n    children: [{\n      type: 'p',\n      props: {\n        style: { color: '#f44336' },\n        children: 'in constructor'\n      }\n    }, {\n      type: 'p',\n      props: {\n        style: { color: '#4caf50' },\n        children: 'in setTimeout'\n      }\n    }]\n  }\n}\n```\n\n对应的DOM树如下：\n\n```html\n<div>\n  <p style=\"color: #f44336;\">in constructor</p>\n  <p style=\"color: #4caf50;\">in setTimeout</p>\n</div>\n```\n\n### 1.3. 如何高效地更新渲染\n\n在实际的应用中，更新渲染是一个极其频繁的过程，网络数据的拉取（比如拉取到用户数据后展示出来）和用户的交互（比如点击展开详情按钮）都会触发更新渲染。在应用的元素数量比较多时，需要有一个高效的方式去更新。\n\n更新方式有两个极端。一是每次都完全创建新的DOM，即使只是DOM的属性变了。二是尽可能多地复用已有的DOM，减少创建。显然第一种方式是不能接受的，每次都重新创建的成本太高。即使只是元素的颜色变了，都会导致DOM的重建。而第二种方式，要达到目标，需要花大量时间在更新前后DOM树的判断上，让尽可能多的DOM复用。n个节点的DOM树，[目前的算法](https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf)时间复杂度为O(n<sup>3</sup>)，也就是说1000个元素的树需要进行10亿次比较，显然太耗时。\n\nReact综合了两种极端，实现了一种启发式算法。首先只对同层元素做比较。如果元素的type都不同，就认为是一颗全新的元素树，直接重建，不会往下递归比较子元素。如果type相同，则只更新属性，不需要重建。然后对于同type情况下的元素列表的更新，开发者可以通过指定key，来提示React带相同key的元素走更新而不是创建流程，从而进一步减少元素的更新次数：\n\n- diff算法关键点1：只比较同层元素（图片来自[React’s diff algorithm](https://calendar.perfplanet.com/2013/diff/)）\n  \n  ![diff1](/assets/react-v15/diff1.png)\n- diff算法关键点2：指定key，减少元素更新次数（图片来自[React’s diff algorithm](https://calendar.perfplanet.com/2013/diff/)）\n  \n  ![diff2](/assets/react-v15/diff2.png)\n\n## 2. 从源码看渲染过程\n\n上面从整体介绍了React的渲染过程，下面我们来看看这些过程在源码中的体现。在阅读文字描述时，建议读者参照下面给出的代码调用图，同时克隆源码([GitHub地址](https://github.com/facebook/react/tree/15-stable))并找到对应的方法。这样可以更容易理解源码的实现逻辑。\n\n### 2.1. 渲染逻辑代码调用流程图\n\n![代码调用图](/assets/react-v15/react-render.svg)\n<!-- https://drive.google.com/file/d/1OYSEFm-i4KGKMrcDj2G09PE1SwH3kes-/view?usp=sharing -->\n\n### 2.2. 首次渲染过程\n\n首次渲染，首先调用instantiateReactComponent初始化一个内部实例internalInstance（这个内部实例的作用是记录各种信息，供更新渲染的时候使用）。内部实例类型共四种，ReactCompositeComponent、ReactDOMComponent、ReactDOMEmptyComponent和ReactDOMTextComponent，后两种比较简单，重点看下前两种的。ReactCompositeComponent用于承载type为函数和class的元素，ReactDOMComponent用于承载type为字符串的元素。\n\n根据类型初始化对应的内部实例后，调用内部实例的mountComponent方法来获取当前元素所渲染的DOM树，然后将DOM树插入指定的容器中，显示在页面上。先来看下ReactCompositeComponent的该方法，首先是初始化当前元素的type，将得到的组件实例挂到内部实例的_instance属性上。对于type是函数类型的组件，内部会将其转化为一个等价的无状态的class组件。然后调用下组件的componentWillMount生命周期函数，之后调用组件实例的render方法获取当前元素所渲染的元素_renderedElement。有了子元素之后，就继续递归调用instantiateReactComponent初始化子元素对应的内部实例，然后调用对应的mountComponent方法，将它的返回值作为当前的方法返回出去。完成之后调用componentDidMount生命周期函数。详细流程图如下：\n\n![](/assets/react-v15/react-first-render-component-element.svg)\n\n如果是ReactDOMComponent，mountComponent过程首先是创建元素对应的DOM节点，同时将节点挂到内部实例的_hostNode属性上，然后将props中的属性更新到节点上，完了之后遍历props的children，依次初始化每个子元素对应的内部实例，然后调用其mountComponent，得到子节点列表，之后将子节点列表依次插到当前节点中，然后返回当前节点。详细流程图如下：\n\n![](/assets/react-v15/react-first-render-host-element.svg)\n\n### 2.3. 更新渲染过程\n\n当class组件实例在某些情况下调用setState时（比如demo中的App组件，在componentDidMount中3秒后调用了setState），就进入了更新流程。首先是将待更新的state添加到内部实例的_pendingStateQueue数组中，然后启动批量更新流程（如果不处在批量更新中的话），并将内部实例添加到dirtyComponents中。\n\n批量更新流程是这样子的，首先对dirtyComponents里面的组件进行排序，确保父组件比子组件先更新（减少子组件的更新次数），然后调用内部实例的updateComponent进行更新。在updateComponent里面，首先调用componentWillReceiveProps生命周期函数，再将state和_pendingStateQueue合并获得最新的状态nextState，然后调用shouldComponentUpdate（如果有的话）确定是否真的要更新。如果不需要更新，则只是简单的更新组件实例的props、state等属性。如果要更新，则再进一步判断是走更新渲染还是销毁重建。\n\n判断过程首先会先调用componentWillUpdate生命周期函数，之后更新组件实例的props、state等属性，更新完之后重新调用组件实例_instance的render方法获取新渲染的元素nextRenderedElement。比较_renderedElement和nextRenderedElement的type（**diff算法的第一个关键：只比较同层的元素，并且认为type不同的元素所渲染的元素不同，从而不需要再递归比较下去**），如果不同就进行销毁重建。销毁重建过程，首先调用所渲染元素对应的内部实例的unmountComponent销毁，然后跟首次渲染一样渲染nextRenderedElement（见2.2小节）。如果type相同，则走更新流程。详细流程图如下：\n\n![](/assets/react-v15/react-update-render-component-element.svg)\n\n在更新流程中，如果所渲染的内部实例是ReactCompositeComponent，则更新流程跟上文一样。如果是ReactDOMComponent，则首先根据新的props更新当前节点_hostNode的属性，然后递归更新子元素列表children。children的更新方式比较复杂，涉及到新增、移动和删除child元素。\n\nchildren的更新方式是，在prevChildren的基础上，通过判断type和key确定每个子元素是否可以复用（**diff算法的第二个关键，通过用户显式地指定key，确定哪些子元素可以复用**）。可以复用就保留child并更新，不能则移除掉。然后找到nextChildren中第一个同时出现在prevChildren中的child组成的最长子列表（出现的先后顺序与prevChildren一样）。详细流程图如下：\n\n![](/assets/react-v15/react-update-render-host-element.svg)\n\n举个例子。比如prevChildren是A、B、C、D，nextChildren是B、E、D、A、C，则最长子列表是B、D。因为在nextChildren第一个同时出现在prevChildren中的是B，往后找到最长的跟prevChildren先后顺序一样的子列表就是B、D了。接下来遍历nextChildren，如果child是B或者D，则不动，否则将其移动到前一个child后面。更形象的表示见下图：\n\n![](/assets/react-v15/update-children-demo.png)\n\n### 2.4. React列表更新策略的问题\n\n如果nextChildren只是将prevChildren的最后一个元素移动到第一个元素前面，按照前面children的更新方式，假设列表长度为n，则会造成n-1次移动，而实际上只需要移动一次（即将最后一个元素移动到第一个元素前面）。造成这样子的原因是因为固定不动的子列表是从nextChildren中第一个元素（同时出现在prevChildren）开始找的，因为第一个元素在prevChildren中是最后一个元素，自然不会再有更后面的元素了，所以这样找到的子列表就只包含了prevChildren中的最后一个元素。但是在这种情况下，nextChildren后面n-1个元素组成的子列表才是最长的。所以最好的方式应该是从nextChildren中找到最长的那一个子列表（出现的先后顺序跟prevChildren一致）。这个子列表可以不是从最早出现在prevChildren中的那个元素开始。如下图所示，不从第一个元素开始的话，找到的最长子元素是C、E、G、H，这样只需要移动4次就可以从S1转化为S2：\n\n![](/assets/react-v15/update-children-2-demo.png)\n\n那么是否存在这样一个可以接受的算法（时间复杂度在O(nlogn)以内），找到这个最长的子列表呢？如果找到了，是否性能就真的会更好？且听下回分解。\n\n## 参考\n\n- [React Components, Elements, and Instances](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)（本文完整的介绍了React涉及到的三个核心概念**组件**、**元素**、**组件实例**）\n- [Implementation Notes](https://reactjs.org/docs/implementation-notes.html)（本文最小实现了Rect v15的原理，代码结构跟源码类似）\n- [Reconciliation](https://reactjs.org/docs/reconciliation.html)、[React's diff algorithm](https://calendar.perfplanet.com/2013/diff/)、[React源码剖析系列——不可思议的react diff](https://zhuanlan.zhihu.com/p/20346379)（这三篇文章详细的介绍了React的更新策略）\n","slug":"react-1","published":1,"updated":"2020-11-28T14:35:48.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk0a001krnq7fgpb0jr9","content":"<!-- \n分享感受：2019年3月27日进行了React v15框架原理的分享。这次分享从19:10讲到了21:10多，共2个多小时。非常开心能有机会分享给这么多人听，而且一次分享了这么长时间。 \n-->\n\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>0. 演示demo</li>\n<li>1. React Element及其渲染过程<ul>\n<li>1.1. 首次渲染过程</li>\n<li>1.2. 更新渲染过程</li>\n<li>1.3. 如果高效地更新渲染</li>\n</ul>\n</li>\n<li>2. 从源码看渲染过程<ul>\n<li>2.1. 代码调用图</li>\n<li>2.2. 首次渲染过程</li>\n<li>2.3. 更新渲染过程</li>\n<li>2.4. React列表更新策略的问题</li>\n</ul>\n</li>\n<li>A. 参考</li>\n</ul>\n<p>笔者在工作中持续使用了一年多的React，慢慢感觉React使用起来很简单，但是要掌握各种局限条件下的最佳实战却很难。比如怎么去封装好一个通用组件？哪些东西该暴露？哪些东西又不该暴露呢？为啥React这么强大却用起来很简单？这些问题，驱使我去探索React及其配套，我想看看React的设计原理，想看看一些优秀的第三方库的设计好坏。为此，我计划边探索边把自己的所得输出出来，形成一系列文章。相信输出过程可以让自己更加深入地理解React，也希望能给读者带来一些新的理解。本文是玩转系列的第一篇，全景式的讲解React的工作原理。</p>\n<p>本文包括两部分内容。首先整体介绍React中的核心概念<strong>元素</strong>（element，也叫虚拟DOM）及React对它的渲染过程。然后从源代码角度展示这一过程。本文阅读的是React v15版本的最新源码(<a href=\"https://github.com/facebook/react/tree/15-stable\">GitHub地址</a>)，包括react模块和浏览器环境下的renderer（react-dom模块中的一部分，不包括server render）。</p>\n<h2 id=\"0-演示demo\"><a href=\"#0-演示demo\" class=\"headerlink\" title=\"0. 演示demo\"></a>0. 演示demo</h2><p>为了讲解方便，引入一个基本的demo。另外为了简化起见，也没有使用jsx语法糖，对应的jsx可以在注释中看到。这个demo的功能是展示一个消息列表，涉及React初次渲染、更新渲染（包括列表）的功能，基本上涵盖了React的各个方面。<a href=\"https://codepen.io/lhtin/pen/JqvXQr\">在线演示地址</a></p>\n<p>demo主要的代码如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">/* &lt;p style=&#123;&#123;color: this.props.color&#125;&#125;&gt;&#123;this.props.children&#125;&lt;/p&gt; */</span></span><br><span class=\"line\">      React.createElement(</span><br><span class=\"line\">        <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">        &#123;<span class=\"attr\">style</span>: &#123;<span class=\"attr\">color</span>: <span class=\"built_in\">this</span>.props.color&#125;&#125;,</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.props.children</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> List = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">/* &lt;div&gt; ... &lt;/div&gt; */</span></span><br><span class=\"line\">    React.createElement(</span><br><span class=\"line\">      <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">      <span class=\"literal\">null</span>,</span><br><span class=\"line\">      props.list.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> (</span><br><span class=\"line\">        <span class=\"comment\">/* &lt;Item key=&#123;item.key&#125; color=&#123;item.color&#125;&gt;&#123;item.content&#125;&lt;/Item&gt; */</span></span><br><span class=\"line\">        React.createElement(</span><br><span class=\"line\">          Item,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            key: item.key,</span><br><span class=\"line\">            color: item.color</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          item.content</span><br><span class=\"line\">        )</span><br><span class=\"line\">      ))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span> (<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      msgList: [&#123;</span><br><span class=\"line\">        key: <span class=\"number\">1</span>,</span><br><span class=\"line\">        color: <span class=\"string\">&#x27;#f44336&#x27;</span>, <span class=\"comment\">// red</span></span><br><span class=\"line\">        content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">        msgList: [</span><br><span class=\"line\">          ...this.state.msgList,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            key: <span class=\"number\">2</span>,</span><br><span class=\"line\">            color: <span class=\"string\">&#x27;#4caf50&#x27;</span>, <span class=\"comment\">// green</span></span><br><span class=\"line\">            content: <span class=\"string\">&#x27;in setTimeout&#x27;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">/* &lt;List list=&#123;this.state.msgList&#125; /&gt; */</span></span><br><span class=\"line\">      React.createElement(</span><br><span class=\"line\">        List,</span><br><span class=\"line\">        &#123;<span class=\"attr\">list</span>: <span class=\"built_in\">this</span>.state.msgList&#125;,</span><br><span class=\"line\">        <span class=\"literal\">null</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  <span class=\"comment\">/* &lt;App /&gt; */</span></span><br><span class=\"line\">  React.createElement(App, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;app&#x27;</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-React-Element及其渲染过程\"><a href=\"#1-React-Element及其渲染过程\" class=\"headerlink\" title=\"1. React Element及其渲染过程\"></a>1. React Element及其渲染过程</h2><p>在React中，有一种数据结构叫<strong>元素</strong>（element），通过<code>React.createElement(...)</code>或者使用JSX语法糖（最终也是编译为前者）创建。渲染过程，就是将React中的元素转换为UI界面（即<code>UI = render(element)</code>，浏览器环境下就是DOM树了）。元素是一个纯JS对象，仅包含type和props两个字段。type确定了元素的类型，props确定了渲染时的输入。根据type，可以将元素分两类，type是字符串的<strong>host元素</strong>和type是函数或class的<strong>component元素</strong>。整个渲染过程就是一步步递归渲染元素，最终结果是生成一颗纯host元素树，然后根据这个树去调用浏览器对应的API，创建DOM树。component元素的作用在于组合其他元素，<strong>渲染它相当于渲染它所渲染的元素</strong>。将host元素转换为DOM是一个繁琐的苦力活，需要处理好不同浏览器的兼容问题，本文不涉及这部分内容。</p>\n<p>对于host元素，React会先创建对应的DOM节点，然后递归渲染host元素的子元素列表（存储于<code>props.children</code>中），并将渲染后的子节点插入到当前节点中。对于component元素需要分情况看。如果component元素的type是一个函数，则将props当作参数传入执行，返回值为该元素所渲染的元素。如果type是一个class，则首先传入props初始化（如果之前没有初始化的话），然后调用实例的render方法获取所渲染的元素。host和component元素的渲染方式，在1.1和1.2小节中有详细的示例演示。</p>\n<p>React的每一次渲染，从整体来看，可以分成两个独立的过程。首先是递归渲染，消除所有的component元素，得到一个纯host的元素树。然后，将host元素树转换为浏览器对于的DOM树。</p>\n<p><img src=\"/assets/react-v15/render-pass.jpg\" alt=\"渲染过程\"></p>\n<p>示例demo的整体渲染过程（下面会具体讲解demo的每个渲染过程）：</p>\n<p><img src=\"/assets/react-v15/render-demo-pass.png\" alt=\"示例渲染过程\"></p>\n<p>因为首次渲染和再次渲染有所区别，所以可以将所有的渲染分成两类，分别是首次渲染和更新渲染。</p>\n<h3 id=\"1-1-首次渲染过程\"><a href=\"#1-1-首次渲染过程\" class=\"headerlink\" title=\"1.1. 首次渲染过程\"></a>1.1. 首次渲染过程</h3><p>首次渲染过程是从顶层元素开始的，顶层元素就是传给ReactDOM.render方法的元素。示例中的顶层元素是一个comoponent元素，type是App class，props为空，数据结构如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: App,</span><br><span class=\"line\">  props: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为App是一个class，所以先初始化App，再调用实例的render方法得到所渲染的元素（见实例的<code>render</code>渲染方法），如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: List,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: [&#123;</span><br><span class=\"line\">      key: <span class=\"number\">1</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续渲染上面的List元素，因为List是一个函数，直接将props作为参数传入调用List就得到了所渲染的元素，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      type: Item,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        key: <span class=\"number\">1</span>,</span><br><span class=\"line\">        color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时所渲染的元素是host元素，继续递归渲染其children元素，这里是type为Item class的元素，跟App元素一样的渲染方式，最终得到一颗纯host的元素树，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      type: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        key: <span class=\"number\">1</span>,</span><br><span class=\"line\">        style: &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;#f44336&#x27;</span> &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上是渲染的第一个步骤，将元素递归渲染成纯host的元素树。第二步，将这颗纯host的元素树转化为等价的DOM树，用html语法表示如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: #f44336;&quot;</span>&gt;</span>in constructor<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-更新渲染过程\"><a href=\"#1-2-更新渲染过程\" class=\"headerlink\" title=\"1.2. 更新渲染过程\"></a>1.2. 更新渲染过程</h3><p>在demo中，首次渲染App元素时会得到一个App实例，渲染完成后调用该实例的<code>componentDidMount</code>生命周期。里面设置了一个定时器，3秒之后调用<code>setState</code>来更新App实例的状态，这时会促使React进入更新渲染过程。首次渲染过程是从顶层元素开始，而更新渲染过程是从被改变的元素开始。进一步，更新渲染过程从实例状态改变后<strong>影响到的元素</strong>（也就是实例所渲染的元素）开始。具体到demo中，就是从App实例所渲染的元素开始。</p>\n<p>更新前App实例所渲染的元素如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: List,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: [&#123;</span><br><span class=\"line\">      key: <span class=\"number\">1</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更新之后，msgList数据改变了，重新调用App组件实例的render方法，获取状态变化后所渲染的元素（相比于更新前，props中的list多了一项），如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: List,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: [&#123;</span><br><span class=\"line\">      key: <span class=\"number\">1</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      key: <span class=\"number\">2</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#4caf50&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in setTimeout&#x27;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后的过程跟首次渲染过程一样，最终得到一颗纯host的元素树，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      type: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        style: &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;#f44336&#x27;</span> &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      type: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        style: &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;#4caf50&#x27;</span> &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in setTimeout&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应的DOM树如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: #f44336;&quot;</span>&gt;</span>in constructor<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: #4caf50;&quot;</span>&gt;</span>in setTimeout<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-如何高效地更新渲染\"><a href=\"#1-3-如何高效地更新渲染\" class=\"headerlink\" title=\"1.3. 如何高效地更新渲染\"></a>1.3. 如何高效地更新渲染</h3><p>在实际的应用中，更新渲染是一个极其频繁的过程，网络数据的拉取（比如拉取到用户数据后展示出来）和用户的交互（比如点击展开详情按钮）都会触发更新渲染。在应用的元素数量比较多时，需要有一个高效的方式去更新。</p>\n<p>更新方式有两个极端。一是每次都完全创建新的DOM，即使只是DOM的属性变了。二是尽可能多地复用已有的DOM，减少创建。显然第一种方式是不能接受的，每次都重新创建的成本太高。即使只是元素的颜色变了，都会导致DOM的重建。而第二种方式，要达到目标，需要花大量时间在更新前后DOM树的判断上，让尽可能多的DOM复用。n个节点的DOM树，<a href=\"https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf\">目前的算法</a>时间复杂度为O(n<sup>3</sup>)，也就是说1000个元素的树需要进行10亿次比较，显然太耗时。</p>\n<p>React综合了两种极端，实现了一种启发式算法。首先只对同层元素做比较。如果元素的type都不同，就认为是一颗全新的元素树，直接重建，不会往下递归比较子元素。如果type相同，则只更新属性，不需要重建。然后对于同type情况下的元素列表的更新，开发者可以通过指定key，来提示React带相同key的元素走更新而不是创建流程，从而进一步减少元素的更新次数：</p>\n<ul>\n<li><p>diff算法关键点1：只比较同层元素（图片来自<a href=\"https://calendar.perfplanet.com/2013/diff/\">React’s diff algorithm</a>）</p>\n<p><img src=\"/assets/react-v15/diff1.png\" alt=\"diff1\"></p>\n</li>\n<li><p>diff算法关键点2：指定key，减少元素更新次数（图片来自<a href=\"https://calendar.perfplanet.com/2013/diff/\">React’s diff algorithm</a>）</p>\n<p><img src=\"/assets/react-v15/diff2.png\" alt=\"diff2\"></p>\n</li>\n</ul>\n<h2 id=\"2-从源码看渲染过程\"><a href=\"#2-从源码看渲染过程\" class=\"headerlink\" title=\"2. 从源码看渲染过程\"></a>2. 从源码看渲染过程</h2><p>上面从整体介绍了React的渲染过程，下面我们来看看这些过程在源码中的体现。在阅读文字描述时，建议读者参照下面给出的代码调用图，同时克隆源码(<a href=\"https://github.com/facebook/react/tree/15-stable\">GitHub地址</a>)并找到对应的方法。这样可以更容易理解源码的实现逻辑。</p>\n<h3 id=\"2-1-渲染逻辑代码调用流程图\"><a href=\"#2-1-渲染逻辑代码调用流程图\" class=\"headerlink\" title=\"2.1. 渲染逻辑代码调用流程图\"></a>2.1. 渲染逻辑代码调用流程图</h3><p><img src=\"/assets/react-v15/react-render.svg\" alt=\"代码调用图\"></p>\n<!-- https://drive.google.com/file/d/1OYSEFm-i4KGKMrcDj2G09PE1SwH3kes-/view?usp=sharing -->\n\n<h3 id=\"2-2-首次渲染过程\"><a href=\"#2-2-首次渲染过程\" class=\"headerlink\" title=\"2.2. 首次渲染过程\"></a>2.2. 首次渲染过程</h3><p>首次渲染，首先调用instantiateReactComponent初始化一个内部实例internalInstance（这个内部实例的作用是记录各种信息，供更新渲染的时候使用）。内部实例类型共四种，ReactCompositeComponent、ReactDOMComponent、ReactDOMEmptyComponent和ReactDOMTextComponent，后两种比较简单，重点看下前两种的。ReactCompositeComponent用于承载type为函数和class的元素，ReactDOMComponent用于承载type为字符串的元素。</p>\n<p>根据类型初始化对应的内部实例后，调用内部实例的mountComponent方法来获取当前元素所渲染的DOM树，然后将DOM树插入指定的容器中，显示在页面上。先来看下ReactCompositeComponent的该方法，首先是初始化当前元素的type，将得到的组件实例挂到内部实例的_instance属性上。对于type是函数类型的组件，内部会将其转化为一个等价的无状态的class组件。然后调用下组件的componentWillMount生命周期函数，之后调用组件实例的render方法获取当前元素所渲染的元素_renderedElement。有了子元素之后，就继续递归调用instantiateReactComponent初始化子元素对应的内部实例，然后调用对应的mountComponent方法，将它的返回值作为当前的方法返回出去。完成之后调用componentDidMount生命周期函数。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-first-render-component-element.svg\"></p>\n<p>如果是ReactDOMComponent，mountComponent过程首先是创建元素对应的DOM节点，同时将节点挂到内部实例的_hostNode属性上，然后将props中的属性更新到节点上，完了之后遍历props的children，依次初始化每个子元素对应的内部实例，然后调用其mountComponent，得到子节点列表，之后将子节点列表依次插到当前节点中，然后返回当前节点。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-first-render-host-element.svg\"></p>\n<h3 id=\"2-3-更新渲染过程\"><a href=\"#2-3-更新渲染过程\" class=\"headerlink\" title=\"2.3. 更新渲染过程\"></a>2.3. 更新渲染过程</h3><p>当class组件实例在某些情况下调用setState时（比如demo中的App组件，在componentDidMount中3秒后调用了setState），就进入了更新流程。首先是将待更新的state添加到内部实例的_pendingStateQueue数组中，然后启动批量更新流程（如果不处在批量更新中的话），并将内部实例添加到dirtyComponents中。</p>\n<p>批量更新流程是这样子的，首先对dirtyComponents里面的组件进行排序，确保父组件比子组件先更新（减少子组件的更新次数），然后调用内部实例的updateComponent进行更新。在updateComponent里面，首先调用componentWillReceiveProps生命周期函数，再将state和_pendingStateQueue合并获得最新的状态nextState，然后调用shouldComponentUpdate（如果有的话）确定是否真的要更新。如果不需要更新，则只是简单的更新组件实例的props、state等属性。如果要更新，则再进一步判断是走更新渲染还是销毁重建。</p>\n<p>判断过程首先会先调用componentWillUpdate生命周期函数，之后更新组件实例的props、state等属性，更新完之后重新调用组件实例_instance的render方法获取新渲染的元素nextRenderedElement。比较_renderedElement和nextRenderedElement的type（<strong>diff算法的第一个关键：只比较同层的元素，并且认为type不同的元素所渲染的元素不同，从而不需要再递归比较下去</strong>），如果不同就进行销毁重建。销毁重建过程，首先调用所渲染元素对应的内部实例的unmountComponent销毁，然后跟首次渲染一样渲染nextRenderedElement（见2.2小节）。如果type相同，则走更新流程。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-update-render-component-element.svg\"></p>\n<p>在更新流程中，如果所渲染的内部实例是ReactCompositeComponent，则更新流程跟上文一样。如果是ReactDOMComponent，则首先根据新的props更新当前节点_hostNode的属性，然后递归更新子元素列表children。children的更新方式比较复杂，涉及到新增、移动和删除child元素。</p>\n<p>children的更新方式是，在prevChildren的基础上，通过判断type和key确定每个子元素是否可以复用（<strong>diff算法的第二个关键，通过用户显式地指定key，确定哪些子元素可以复用</strong>）。可以复用就保留child并更新，不能则移除掉。然后找到nextChildren中第一个同时出现在prevChildren中的child组成的最长子列表（出现的先后顺序与prevChildren一样）。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-update-render-host-element.svg\"></p>\n<p>举个例子。比如prevChildren是A、B、C、D，nextChildren是B、E、D、A、C，则最长子列表是B、D。因为在nextChildren第一个同时出现在prevChildren中的是B，往后找到最长的跟prevChildren先后顺序一样的子列表就是B、D了。接下来遍历nextChildren，如果child是B或者D，则不动，否则将其移动到前一个child后面。更形象的表示见下图：</p>\n<p><img src=\"/assets/react-v15/update-children-demo.png\"></p>\n<h3 id=\"2-4-React列表更新策略的问题\"><a href=\"#2-4-React列表更新策略的问题\" class=\"headerlink\" title=\"2.4. React列表更新策略的问题\"></a>2.4. React列表更新策略的问题</h3><p>如果nextChildren只是将prevChildren的最后一个元素移动到第一个元素前面，按照前面children的更新方式，假设列表长度为n，则会造成n-1次移动，而实际上只需要移动一次（即将最后一个元素移动到第一个元素前面）。造成这样子的原因是因为固定不动的子列表是从nextChildren中第一个元素（同时出现在prevChildren）开始找的，因为第一个元素在prevChildren中是最后一个元素，自然不会再有更后面的元素了，所以这样找到的子列表就只包含了prevChildren中的最后一个元素。但是在这种情况下，nextChildren后面n-1个元素组成的子列表才是最长的。所以最好的方式应该是从nextChildren中找到最长的那一个子列表（出现的先后顺序跟prevChildren一致）。这个子列表可以不是从最早出现在prevChildren中的那个元素开始。如下图所示，不从第一个元素开始的话，找到的最长子元素是C、E、G、H，这样只需要移动4次就可以从S1转化为S2：</p>\n<p><img src=\"/assets/react-v15/update-children-2-demo.png\"></p>\n<p>那么是否存在这样一个可以接受的算法（时间复杂度在O(nlogn)以内），找到这个最长的子列表呢？如果找到了，是否性能就真的会更好？且听下回分解。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a>（本文完整的介绍了React涉及到的三个核心概念<strong>组件</strong>、<strong>元素</strong>、<strong>组件实例</strong>）</li>\n<li><a href=\"https://reactjs.org/docs/implementation-notes.html\">Implementation Notes</a>（本文最小实现了Rect v15的原理，代码结构跟源码类似）</li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation</a>、<a href=\"https://calendar.perfplanet.com/2013/diff/\">React’s diff algorithm</a>、<a href=\"https://zhuanlan.zhihu.com/p/20346379\">React源码剖析系列——不可思议的react diff</a>（这三篇文章详细的介绍了React的更新策略）</li>\n</ul>\n","site":{"data":{}},"more":"<!-- \n分享感受：2019年3月27日进行了React v15框架原理的分享。这次分享从19:10讲到了21:10多，共2个多小时。非常开心能有机会分享给这么多人听，而且一次分享了这么长时间。 \n-->\n\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>0. 演示demo</li>\n<li>1. React Element及其渲染过程<ul>\n<li>1.1. 首次渲染过程</li>\n<li>1.2. 更新渲染过程</li>\n<li>1.3. 如果高效地更新渲染</li>\n</ul>\n</li>\n<li>2. 从源码看渲染过程<ul>\n<li>2.1. 代码调用图</li>\n<li>2.2. 首次渲染过程</li>\n<li>2.3. 更新渲染过程</li>\n<li>2.4. React列表更新策略的问题</li>\n</ul>\n</li>\n<li>A. 参考</li>\n</ul>\n<p>笔者在工作中持续使用了一年多的React，慢慢感觉React使用起来很简单，但是要掌握各种局限条件下的最佳实战却很难。比如怎么去封装好一个通用组件？哪些东西该暴露？哪些东西又不该暴露呢？为啥React这么强大却用起来很简单？这些问题，驱使我去探索React及其配套，我想看看React的设计原理，想看看一些优秀的第三方库的设计好坏。为此，我计划边探索边把自己的所得输出出来，形成一系列文章。相信输出过程可以让自己更加深入地理解React，也希望能给读者带来一些新的理解。本文是玩转系列的第一篇，全景式的讲解React的工作原理。</p>\n<p>本文包括两部分内容。首先整体介绍React中的核心概念<strong>元素</strong>（element，也叫虚拟DOM）及React对它的渲染过程。然后从源代码角度展示这一过程。本文阅读的是React v15版本的最新源码(<a href=\"https://github.com/facebook/react/tree/15-stable\">GitHub地址</a>)，包括react模块和浏览器环境下的renderer（react-dom模块中的一部分，不包括server render）。</p>\n<h2 id=\"0-演示demo\"><a href=\"#0-演示demo\" class=\"headerlink\" title=\"0. 演示demo\"></a>0. 演示demo</h2><p>为了讲解方便，引入一个基本的demo。另外为了简化起见，也没有使用jsx语法糖，对应的jsx可以在注释中看到。这个demo的功能是展示一个消息列表，涉及React初次渲染、更新渲染（包括列表）的功能，基本上涵盖了React的各个方面。<a href=\"https://codepen.io/lhtin/pen/JqvXQr\">在线演示地址</a></p>\n<p>demo主要的代码如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">/* &lt;p style=&#123;&#123;color: this.props.color&#125;&#125;&gt;&#123;this.props.children&#125;&lt;/p&gt; */</span></span><br><span class=\"line\">      React.createElement(</span><br><span class=\"line\">        <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">        &#123;<span class=\"attr\">style</span>: &#123;<span class=\"attr\">color</span>: <span class=\"built_in\">this</span>.props.color&#125;&#125;,</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.props.children</span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> List = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">/* &lt;div&gt; ... &lt;/div&gt; */</span></span><br><span class=\"line\">    React.createElement(</span><br><span class=\"line\">      <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">      <span class=\"literal\">null</span>,</span><br><span class=\"line\">      props.list.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> (</span><br><span class=\"line\">        <span class=\"comment\">/* &lt;Item key=&#123;item.key&#125; color=&#123;item.color&#125;&gt;&#123;item.content&#125;&lt;/Item&gt; */</span></span><br><span class=\"line\">        React.createElement(</span><br><span class=\"line\">          Item,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            key: item.key,</span><br><span class=\"line\">            color: item.color</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          item.content</span><br><span class=\"line\">        )</span><br><span class=\"line\">      ))</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span> (<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      msgList: [&#123;</span><br><span class=\"line\">        key: <span class=\"number\">1</span>,</span><br><span class=\"line\">        color: <span class=\"string\">&#x27;#f44336&#x27;</span>, <span class=\"comment\">// red</span></span><br><span class=\"line\">        content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">        msgList: [</span><br><span class=\"line\">          ...this.state.msgList,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            key: <span class=\"number\">2</span>,</span><br><span class=\"line\">            color: <span class=\"string\">&#x27;#4caf50&#x27;</span>, <span class=\"comment\">// green</span></span><br><span class=\"line\">            content: <span class=\"string\">&#x27;in setTimeout&#x27;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">/* &lt;List list=&#123;this.state.msgList&#125; /&gt; */</span></span><br><span class=\"line\">      React.createElement(</span><br><span class=\"line\">        List,</span><br><span class=\"line\">        &#123;<span class=\"attr\">list</span>: <span class=\"built_in\">this</span>.state.msgList&#125;,</span><br><span class=\"line\">        <span class=\"literal\">null</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  <span class=\"comment\">/* &lt;App /&gt; */</span></span><br><span class=\"line\">  React.createElement(App, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>),</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;app&#x27;</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-React-Element及其渲染过程\"><a href=\"#1-React-Element及其渲染过程\" class=\"headerlink\" title=\"1. React Element及其渲染过程\"></a>1. React Element及其渲染过程</h2><p>在React中，有一种数据结构叫<strong>元素</strong>（element），通过<code>React.createElement(...)</code>或者使用JSX语法糖（最终也是编译为前者）创建。渲染过程，就是将React中的元素转换为UI界面（即<code>UI = render(element)</code>，浏览器环境下就是DOM树了）。元素是一个纯JS对象，仅包含type和props两个字段。type确定了元素的类型，props确定了渲染时的输入。根据type，可以将元素分两类，type是字符串的<strong>host元素</strong>和type是函数或class的<strong>component元素</strong>。整个渲染过程就是一步步递归渲染元素，最终结果是生成一颗纯host元素树，然后根据这个树去调用浏览器对应的API，创建DOM树。component元素的作用在于组合其他元素，<strong>渲染它相当于渲染它所渲染的元素</strong>。将host元素转换为DOM是一个繁琐的苦力活，需要处理好不同浏览器的兼容问题，本文不涉及这部分内容。</p>\n<p>对于host元素，React会先创建对应的DOM节点，然后递归渲染host元素的子元素列表（存储于<code>props.children</code>中），并将渲染后的子节点插入到当前节点中。对于component元素需要分情况看。如果component元素的type是一个函数，则将props当作参数传入执行，返回值为该元素所渲染的元素。如果type是一个class，则首先传入props初始化（如果之前没有初始化的话），然后调用实例的render方法获取所渲染的元素。host和component元素的渲染方式，在1.1和1.2小节中有详细的示例演示。</p>\n<p>React的每一次渲染，从整体来看，可以分成两个独立的过程。首先是递归渲染，消除所有的component元素，得到一个纯host的元素树。然后，将host元素树转换为浏览器对于的DOM树。</p>\n<p><img src=\"/assets/react-v15/render-pass.jpg\" alt=\"渲染过程\"></p>\n<p>示例demo的整体渲染过程（下面会具体讲解demo的每个渲染过程）：</p>\n<p><img src=\"/assets/react-v15/render-demo-pass.png\" alt=\"示例渲染过程\"></p>\n<p>因为首次渲染和再次渲染有所区别，所以可以将所有的渲染分成两类，分别是首次渲染和更新渲染。</p>\n<h3 id=\"1-1-首次渲染过程\"><a href=\"#1-1-首次渲染过程\" class=\"headerlink\" title=\"1.1. 首次渲染过程\"></a>1.1. 首次渲染过程</h3><p>首次渲染过程是从顶层元素开始的，顶层元素就是传给ReactDOM.render方法的元素。示例中的顶层元素是一个comoponent元素，type是App class，props为空，数据结构如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: App,</span><br><span class=\"line\">  props: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为App是一个class，所以先初始化App，再调用实例的render方法得到所渲染的元素（见实例的<code>render</code>渲染方法），如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: List,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: [&#123;</span><br><span class=\"line\">      key: <span class=\"number\">1</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续渲染上面的List元素，因为List是一个函数，直接将props作为参数传入调用List就得到了所渲染的元素，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      type: Item,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        key: <span class=\"number\">1</span>,</span><br><span class=\"line\">        color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时所渲染的元素是host元素，继续递归渲染其children元素，这里是type为Item class的元素，跟App元素一样的渲染方式，最终得到一颗纯host的元素树，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      type: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        key: <span class=\"number\">1</span>,</span><br><span class=\"line\">        style: &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;#f44336&#x27;</span> &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上是渲染的第一个步骤，将元素递归渲染成纯host的元素树。第二步，将这颗纯host的元素树转化为等价的DOM树，用html语法表示如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: #f44336;&quot;</span>&gt;</span>in constructor<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-更新渲染过程\"><a href=\"#1-2-更新渲染过程\" class=\"headerlink\" title=\"1.2. 更新渲染过程\"></a>1.2. 更新渲染过程</h3><p>在demo中，首次渲染App元素时会得到一个App实例，渲染完成后调用该实例的<code>componentDidMount</code>生命周期。里面设置了一个定时器，3秒之后调用<code>setState</code>来更新App实例的状态，这时会促使React进入更新渲染过程。首次渲染过程是从顶层元素开始，而更新渲染过程是从被改变的元素开始。进一步，更新渲染过程从实例状态改变后<strong>影响到的元素</strong>（也就是实例所渲染的元素）开始。具体到demo中，就是从App实例所渲染的元素开始。</p>\n<p>更新前App实例所渲染的元素如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: List,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: [&#123;</span><br><span class=\"line\">      key: <span class=\"number\">1</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>更新之后，msgList数据改变了，重新调用App组件实例的render方法，获取状态变化后所渲染的元素（相比于更新前，props中的list多了一项），如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: List,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    list: [&#123;</span><br><span class=\"line\">      key: <span class=\"number\">1</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#f44336&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      key: <span class=\"number\">2</span>,</span><br><span class=\"line\">      color: <span class=\"string\">&#x27;#4caf50&#x27;</span>,</span><br><span class=\"line\">      content: <span class=\"string\">&#x27;in setTimeout&#x27;</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后的过程跟首次渲染过程一样，最终得到一颗纯host的元素树，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">      type: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        style: &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;#f44336&#x27;</span> &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in constructor&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      type: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        style: &#123; <span class=\"attr\">color</span>: <span class=\"string\">&#x27;#4caf50&#x27;</span> &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">&#x27;in setTimeout&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应的DOM树如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: #f44336;&quot;</span>&gt;</span>in constructor<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;color: #4caf50;&quot;</span>&gt;</span>in setTimeout<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-如何高效地更新渲染\"><a href=\"#1-3-如何高效地更新渲染\" class=\"headerlink\" title=\"1.3. 如何高效地更新渲染\"></a>1.3. 如何高效地更新渲染</h3><p>在实际的应用中，更新渲染是一个极其频繁的过程，网络数据的拉取（比如拉取到用户数据后展示出来）和用户的交互（比如点击展开详情按钮）都会触发更新渲染。在应用的元素数量比较多时，需要有一个高效的方式去更新。</p>\n<p>更新方式有两个极端。一是每次都完全创建新的DOM，即使只是DOM的属性变了。二是尽可能多地复用已有的DOM，减少创建。显然第一种方式是不能接受的，每次都重新创建的成本太高。即使只是元素的颜色变了，都会导致DOM的重建。而第二种方式，要达到目标，需要花大量时间在更新前后DOM树的判断上，让尽可能多的DOM复用。n个节点的DOM树，<a href=\"https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf\">目前的算法</a>时间复杂度为O(n<sup>3</sup>)，也就是说1000个元素的树需要进行10亿次比较，显然太耗时。</p>\n<p>React综合了两种极端，实现了一种启发式算法。首先只对同层元素做比较。如果元素的type都不同，就认为是一颗全新的元素树，直接重建，不会往下递归比较子元素。如果type相同，则只更新属性，不需要重建。然后对于同type情况下的元素列表的更新，开发者可以通过指定key，来提示React带相同key的元素走更新而不是创建流程，从而进一步减少元素的更新次数：</p>\n<ul>\n<li><p>diff算法关键点1：只比较同层元素（图片来自<a href=\"https://calendar.perfplanet.com/2013/diff/\">React’s diff algorithm</a>）</p>\n<p><img src=\"/assets/react-v15/diff1.png\" alt=\"diff1\"></p>\n</li>\n<li><p>diff算法关键点2：指定key，减少元素更新次数（图片来自<a href=\"https://calendar.perfplanet.com/2013/diff/\">React’s diff algorithm</a>）</p>\n<p><img src=\"/assets/react-v15/diff2.png\" alt=\"diff2\"></p>\n</li>\n</ul>\n<h2 id=\"2-从源码看渲染过程\"><a href=\"#2-从源码看渲染过程\" class=\"headerlink\" title=\"2. 从源码看渲染过程\"></a>2. 从源码看渲染过程</h2><p>上面从整体介绍了React的渲染过程，下面我们来看看这些过程在源码中的体现。在阅读文字描述时，建议读者参照下面给出的代码调用图，同时克隆源码(<a href=\"https://github.com/facebook/react/tree/15-stable\">GitHub地址</a>)并找到对应的方法。这样可以更容易理解源码的实现逻辑。</p>\n<h3 id=\"2-1-渲染逻辑代码调用流程图\"><a href=\"#2-1-渲染逻辑代码调用流程图\" class=\"headerlink\" title=\"2.1. 渲染逻辑代码调用流程图\"></a>2.1. 渲染逻辑代码调用流程图</h3><p><img src=\"/assets/react-v15/react-render.svg\" alt=\"代码调用图\"></p>\n<!-- https://drive.google.com/file/d/1OYSEFm-i4KGKMrcDj2G09PE1SwH3kes-/view?usp=sharing -->\n\n<h3 id=\"2-2-首次渲染过程\"><a href=\"#2-2-首次渲染过程\" class=\"headerlink\" title=\"2.2. 首次渲染过程\"></a>2.2. 首次渲染过程</h3><p>首次渲染，首先调用instantiateReactComponent初始化一个内部实例internalInstance（这个内部实例的作用是记录各种信息，供更新渲染的时候使用）。内部实例类型共四种，ReactCompositeComponent、ReactDOMComponent、ReactDOMEmptyComponent和ReactDOMTextComponent，后两种比较简单，重点看下前两种的。ReactCompositeComponent用于承载type为函数和class的元素，ReactDOMComponent用于承载type为字符串的元素。</p>\n<p>根据类型初始化对应的内部实例后，调用内部实例的mountComponent方法来获取当前元素所渲染的DOM树，然后将DOM树插入指定的容器中，显示在页面上。先来看下ReactCompositeComponent的该方法，首先是初始化当前元素的type，将得到的组件实例挂到内部实例的_instance属性上。对于type是函数类型的组件，内部会将其转化为一个等价的无状态的class组件。然后调用下组件的componentWillMount生命周期函数，之后调用组件实例的render方法获取当前元素所渲染的元素_renderedElement。有了子元素之后，就继续递归调用instantiateReactComponent初始化子元素对应的内部实例，然后调用对应的mountComponent方法，将它的返回值作为当前的方法返回出去。完成之后调用componentDidMount生命周期函数。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-first-render-component-element.svg\"></p>\n<p>如果是ReactDOMComponent，mountComponent过程首先是创建元素对应的DOM节点，同时将节点挂到内部实例的_hostNode属性上，然后将props中的属性更新到节点上，完了之后遍历props的children，依次初始化每个子元素对应的内部实例，然后调用其mountComponent，得到子节点列表，之后将子节点列表依次插到当前节点中，然后返回当前节点。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-first-render-host-element.svg\"></p>\n<h3 id=\"2-3-更新渲染过程\"><a href=\"#2-3-更新渲染过程\" class=\"headerlink\" title=\"2.3. 更新渲染过程\"></a>2.3. 更新渲染过程</h3><p>当class组件实例在某些情况下调用setState时（比如demo中的App组件，在componentDidMount中3秒后调用了setState），就进入了更新流程。首先是将待更新的state添加到内部实例的_pendingStateQueue数组中，然后启动批量更新流程（如果不处在批量更新中的话），并将内部实例添加到dirtyComponents中。</p>\n<p>批量更新流程是这样子的，首先对dirtyComponents里面的组件进行排序，确保父组件比子组件先更新（减少子组件的更新次数），然后调用内部实例的updateComponent进行更新。在updateComponent里面，首先调用componentWillReceiveProps生命周期函数，再将state和_pendingStateQueue合并获得最新的状态nextState，然后调用shouldComponentUpdate（如果有的话）确定是否真的要更新。如果不需要更新，则只是简单的更新组件实例的props、state等属性。如果要更新，则再进一步判断是走更新渲染还是销毁重建。</p>\n<p>判断过程首先会先调用componentWillUpdate生命周期函数，之后更新组件实例的props、state等属性，更新完之后重新调用组件实例_instance的render方法获取新渲染的元素nextRenderedElement。比较_renderedElement和nextRenderedElement的type（<strong>diff算法的第一个关键：只比较同层的元素，并且认为type不同的元素所渲染的元素不同，从而不需要再递归比较下去</strong>），如果不同就进行销毁重建。销毁重建过程，首先调用所渲染元素对应的内部实例的unmountComponent销毁，然后跟首次渲染一样渲染nextRenderedElement（见2.2小节）。如果type相同，则走更新流程。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-update-render-component-element.svg\"></p>\n<p>在更新流程中，如果所渲染的内部实例是ReactCompositeComponent，则更新流程跟上文一样。如果是ReactDOMComponent，则首先根据新的props更新当前节点_hostNode的属性，然后递归更新子元素列表children。children的更新方式比较复杂，涉及到新增、移动和删除child元素。</p>\n<p>children的更新方式是，在prevChildren的基础上，通过判断type和key确定每个子元素是否可以复用（<strong>diff算法的第二个关键，通过用户显式地指定key，确定哪些子元素可以复用</strong>）。可以复用就保留child并更新，不能则移除掉。然后找到nextChildren中第一个同时出现在prevChildren中的child组成的最长子列表（出现的先后顺序与prevChildren一样）。详细流程图如下：</p>\n<p><img src=\"/assets/react-v15/react-update-render-host-element.svg\"></p>\n<p>举个例子。比如prevChildren是A、B、C、D，nextChildren是B、E、D、A、C，则最长子列表是B、D。因为在nextChildren第一个同时出现在prevChildren中的是B，往后找到最长的跟prevChildren先后顺序一样的子列表就是B、D了。接下来遍历nextChildren，如果child是B或者D，则不动，否则将其移动到前一个child后面。更形象的表示见下图：</p>\n<p><img src=\"/assets/react-v15/update-children-demo.png\"></p>\n<h3 id=\"2-4-React列表更新策略的问题\"><a href=\"#2-4-React列表更新策略的问题\" class=\"headerlink\" title=\"2.4. React列表更新策略的问题\"></a>2.4. React列表更新策略的问题</h3><p>如果nextChildren只是将prevChildren的最后一个元素移动到第一个元素前面，按照前面children的更新方式，假设列表长度为n，则会造成n-1次移动，而实际上只需要移动一次（即将最后一个元素移动到第一个元素前面）。造成这样子的原因是因为固定不动的子列表是从nextChildren中第一个元素（同时出现在prevChildren）开始找的，因为第一个元素在prevChildren中是最后一个元素，自然不会再有更后面的元素了，所以这样找到的子列表就只包含了prevChildren中的最后一个元素。但是在这种情况下，nextChildren后面n-1个元素组成的子列表才是最长的。所以最好的方式应该是从nextChildren中找到最长的那一个子列表（出现的先后顺序跟prevChildren一致）。这个子列表可以不是从最早出现在prevChildren中的那个元素开始。如下图所示，不从第一个元素开始的话，找到的最长子元素是C、E、G、H，这样只需要移动4次就可以从S1转化为S2：</p>\n<p><img src=\"/assets/react-v15/update-children-2-demo.png\"></p>\n<p>那么是否存在这样一个可以接受的算法（时间复杂度在O(nlogn)以内），找到这个最长的子列表呢？如果找到了，是否性能就真的会更好？且听下回分解。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">React Components, Elements, and Instances</a>（本文完整的介绍了React涉及到的三个核心概念<strong>组件</strong>、<strong>元素</strong>、<strong>组件实例</strong>）</li>\n<li><a href=\"https://reactjs.org/docs/implementation-notes.html\">Implementation Notes</a>（本文最小实现了Rect v15的原理，代码结构跟源码类似）</li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation</a>、<a href=\"https://calendar.perfplanet.com/2013/diff/\">React’s diff algorithm</a>、<a href=\"https://zhuanlan.zhihu.com/p/20346379\">React源码剖析系列——不可思议的react diff</a>（这三篇文章详细的介绍了React的更新策略）</li>\n</ul>\n"},{"title":"The Scheme Programming Language 摘抄笔记及习题答案","date":"2017-02-03T16:00:00.000Z","excerpt":"本文为我阅读TSPL4的笔记和习题答案记录","_content":"\n## Preface\n\nScheme 由 Gerald J. Sussman 和 Guy L. Steele Jr. 发明，支持 lexical scoping、first-class procedures 和 continuations。\n\n本书的目标是提供关于 Scheme 编程语言（R6RS 标准）的介绍。\n\n## 1. Introduction\n\n> Scheme is a call-by-value language, but for at least mutable (objects that can be modified), the values are pointers to the actual storage.\n\n> At the heart of the Scheme language is a small core of syntactic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language.\n\n> To support lexical scoping, a procedure carries the lexical context (environment) along with its code.\n\n### 1.1. Scheme Syntax\n\n> Scheme programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.\n\n> Keywords, variables, and symbols are collectively called identifiers. Identifiers may be formed from letters, digits, and certain special characters, including ?, !, ., +, -, *, /, <, =, >, :, $, %, ^, &, _, ~, and @, as well as a set of additional Unicode characters.\n\n> A good rule is to use short identifiers when the scope of the identifier is small and longer identifiers when the scope is larger.\n\n> Structured forms and list constants are enclosed within parentheses, e.g., (a b c) or (* (- x 2) y).\n\n> Strings are enclosed in double quotation marks, e.g., \"I am a string\". Characters are preceded by #\\, e.g., #\\a.\n\ncomments: `; single line`, `#| block |#`, `#;(datum commnet)`\n\n### 1.2. Scheme Naming Conventions\n\n### 1.3. Typographical and Notational Conventions\n\n\n## 2. Getting Started\n\n### 2.1. Interacting with Scheme\n\n### 2.2. Simple Expressions\n\n> The `quote` (`'`) forces the list to be treated as data.\n\n> Symbols and variables in Scheme are similar to symbols and variables in mathematical expressions and equations. When we evaluate the mathematical expression 1 - _x_ for some value of _x_, we think of _x_ as a variable. On the other hand, when we consider the algebraic equation _x_^2 - 1 = (_x_ - 1)(_x_ + 1), we think of _x_ as a symbol (in fact, we think of the whole equation symbolically). Just as quoting a list tells Scheme to treat a parenthesized form as a list rather than as a procedure application, **quoting an identifier tells Scheme to treat the identifier as a symbol rather than as a variable**.\n\n> Numbers and strings may be quoted, too. Numbers and strings are treated as constants in any case, however, so quoting them is unnecessary.\n\n### 2.3. Evaluating Scheme Expressions\n\n> Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms provided by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme programmer; these are referred to as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms.\n\n### 2.4. Variables and Let Expressions\n\n每一个 variable 都有它的 scope，同名的 variable，更里面的 variable 会 shadow 外层的 variable。这种 scope 叫做 lexical scoping。\n\n```scheme\n(let ((var expr) ...) body1 body2 ...)\n```\n\n### 2.5. Lambda Expressions\n\n```scheme\n(lambda (var ...) body1 body2 ...)\n(lambda var body1 body2 ...)\n(lambda (var ... var . var) body1 body2 ...)\n```\n\n### 2.6. Top-Level Definitions\n\n### 2.7. Conditional Expressions\n\n> A predicate is a procedure that answers a specific question about its arguments and returns one of the two values #t or #f.\n\n### 2.8. Simple Recursion\n\n> Recursion is a simple concept: the application of a procedure from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive power far beyond ordinary looping constructs.\n\n**mapping**: 映射\n\n### 2.9. Assignment\n\n> Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings. Assignments are performed with set!.\n\n## 3. Going Further\n\n### 3.1. Syntactic Extension\n\n> The core syntactic forms include top-level `define` forms, constants, variables, procedure applications, `quote` expressions, `lambda` expressions, `if` expressions, and `set!` expressions.\n\ncore grammar:\n\n```\n<program> -> <form>*\n<form> -> <definition> | <expression>\n<definition> -> <variable definition> | (begin <definition>*)\n<variable definition> -> (define <variable> <expression>)\n<expression> -> <constant>\n             |  <variable>\n             |  (quote <datum>)\n             |  (lambda <formals> <expression> <expression>*)\n             |  (if <expression> <expression> <expression>)\n             |  (set! <variable> <expression>)\n             |  <application>\n<constant> -> <boolean> | <number> | <character> | <string>\n<formals> -> <variable>\n          |  (<variable>*)\n          |  (<variable> <variable>* . <variable>)\n<application> -> (<expression> <expression>*)\n\n<variable> is any Scheme identifier\n<datum> is any Scheme object, such as a number, list, symbol, or vector\n<boolean> is either #t or #f\n<number> is any number\n<character> is any character\n<string> is any string\n```\n\n### 3.2. More Recursion\n\n> In a `letrec` expression, `expr ...` are most often `lambda` expressions, though this need not be the case. One restriction on the expressions must be obeyed, however. It must be possible to evaluate each `expr` without evaluating any of the variables `var ...`.\n\n### 3.3. Continuations\n\n> During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. We call \"what to do with the value\" the continuation of a computation.\n\n对 continuation 的记录，意味着下次使用该 continuation 时会回到之前计算的某个点，再往下走。也就是说可以回到过去。\n\n\n### 3.4. Continuation Passing Style\n\n使函数调用的隐式 continuation 通过 CPS 转换变为显式。\n\n使用场景：\n\n1. 是函数调用可以返回多个值\n2. 可以传入多个 continuation\n\n### 3.5. Internal Definitions\n\n> Definitions may also appear at the front of a lambda, let, or letrec body, in which case the bindings they create are local to the body.\n\n### 3.6. Libraries\n\n用于模块化，只暴露必要的内容给使用者。\n\n```scheme\n(library (lib-name)\n  (export x1 x2 ...)\n  (import (rnrs))\n  ...)\n```\n\n## 4. Procedures and Variable Bindings\n\n### 4.1. Variable References\n\n> Since the scope of the definitions in a `library`, top-level program, `lambda`, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed.\n\n### 4.2. Lambda\n\n`(lambda formals body1 body2 ...)`\n\n### 4.3. Case-Lambda\n\n> The `case-lambda` syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments.\n\n`(case-lambda clause ...)`\n\n`clause`:\n`[formals body1 body2 ...]`\n\n### 4.4. Local Binding\n\n`let`, `let*`, `letrec`, `letrec*`\n\n### 4.5. Multiple Values\n\n`let-values`, `let*-values`\n\n### 4.6. Variable Definitions\n\n`define`\n\n> A set of definitions may be grouped by enclosing them in a `begin` form. Definitions grouped in this manner may appear wherever ordinary variable and syntax definitions may appear. They are treated as if written separately, i.e., without the enclosing `begin` form.\n\n### 4.7. Assignment\n\n`set!`\n\n## 5. Control Operations\n\n### 5.1. Procedure Application\n\n> Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application.\n\n`(apply procedure obj ... list)`\n\n> `apply` is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.\n\n### 5.2. Sequencing\n\n`(begin expr1 expr2 ...)`\n\n> The bodies of many syntactic forms, including `lambda`, `case-lambda`, `let`, `let*`, `letrec`, and `letrec*`, as well as the result clauses of `cond`, `case`, and `do`, are treated as if they were inside an implicit `begin`; i.e., the expressions making up the body or result clause are executed in sequence, with the values of the last expression being returned.\n\n### 5.3. Conditionals\n\n`if`, `not`, `and`, `or`, `cond`, `when`, `unless`, `case`\n\n### 5.4. Recursion and Iteration\n\n`(let name ((var expr) ...) body1 body2 ...)`\n\n`(do ((var init update) ...) (test result ...) expr ...)`\n\n### 5.5. Mapping and Folding\n\n`(map procedure list1 list2 ...)`\n`(for-each procedure list1 list2 ...)`\n\n> `for-each` is similar to `map` except that `for-each` does not create and return a list of the resulting values, and `for-each` guarantees to perform the applications in sequence over the elements from left to right.\n\n`(exists procedure list1 list2 ...)`\n`(for-all procedure list1 list2 ...)`\n\n`exists` 和 `for-all` 的区别在于前者是在调用函数返回 `#t` 是结束，后者是在返回 `#f` 是结束。\n\n`(fold-left procedure obj list1 list2 ...)`\n`(fold-right procedure obj list1 list2 ...)`\n\n### 5.6. Continuations\n\n用一句比较玄的话来讲就是：它（Continuation）可以去到未来，也可以回到过去。\n\n`(call/cc procedure)`\n`(dynamic-wind in body out)`\n\n`dynamic-wind` 还需要再思考清楚。\n\n### 5.7. Delayed Evaluation\n\n> The benefit of using `delay` and `force` is that some amount of computation might be avoided altogether if it is delayed until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or streams.\n\n### 5.8. Multiple Values\n\n`(call-with-values producer consumer)`\n\n### 5.9. Eval\n\n> Scheme's `eval` procedure allows programmers to write programs that construct and evaluate other programs. This ability to do run-time meta programming should not be overused but is handy when needed.\n\n`(eval obj environment)`\n`(environment import-spec ...)`\n\n\n## 6. Operations on objects\n\n> This chapter describes the operations on objects, including lists, numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations.\n\n### 6.1. Constants and Quotation\n\n`quote`, `quasiquote`, `unquote`, `unquote-splicing`\n\n### 6.2. Generic Equivalence and Type Predicates\n\n> `eq?` is most often used to compare symbols or to check for pointer equivalence of allocated objects\n\n`eq?`, `eqv?`, `equal?` 三者的区别在于后者比前者能判断的更加广泛。\n\n### 6.3. Lists and Pairs\n\n`(list '+)` 与 `(list +)` 的区别在于，第一个 list 包含的是符号 symbol +，而第二个 list 包含的是程序 procedure +。\n\n也就是说， list 的内容可以包含任意类型的值，包括 procedure。\n\n注意 `'(a b c)` 表示含有 symbol `a` 、 `b` 和 `c` 的 list，而不是一个叫 `(a b c)` 的 symbol。\n\n### 6.4. Numbers\n\n> Scheme numbers may be classified as integers, rational numbers, real numbers, or complex numbers. This classification is hierarchical, in that all integers are rational, all rational numbers are real, and all real numbers are complex.\n\n> A Scheme number may also be classified as exact or inexact, depending upon the quality of operations used to derive the number and the inputs to these operations.\n\n### 6.5. Fixnums\n\nfixnum 指固定范围内的整数。\n\n### 6.6. Flonums\n\n### 6.7. Characters\n\n### 6.8. Strings\n\n### 6.9. Vectors\n\n> Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time.\n\n### 6.10. Bytevectors\n\n> Bytevectors are vectors of raw binary data.\n\n### 6.11. Symbols\n\n> The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as identifiers in the representation of programs, allowing fast comparison of identifiers.\n\n### 6.12. Booleans\n\n### 6.13. Hashtables\n\n> Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose as association lists but are typically much faster when large numbers of associations are involved.\n\n### 6.14. Enumerations\n\n## 7. Input and Output\n\n> All input and output operations are performed through ports.\n\n> Ports are first-class objects, like any other object in Scheme.\n\n### 7.1. Transcoders\n\n### 7.2. Opening Files\n\n> It is perhaps easier to imagine that the default file options are the imaginary option symbols `create`, `fail-if-exists`, and `truncate`; `no-create` removes `create`, `no-fail` removes `fail-if-exists`, and `no-truncate` removes `truncate`.\n\n### 7.3. Standard Ports\n\n### 7.4. String and Bytevector Ports\n\n### 7.5. Opening Custom Ports\n\n### 7.6. Port Operations\n\n### 7.7. Input Operations\n\n### 7.8. Output Operations\n\n### 7.9. Convenience I/O\n\n### 7.10. Filesystem Operations\n\n### 7.11. Bytevector/String Conversions\n\n## 8. Syntactic Extension\n\n> Syntactic extensions, or macros, are used to simplify and regularize repeated patterns in a program, to introduce syntactic forms with new evaluation rules, and to perform transformations that help make programs more efficient.\n\n> Syntactic extensions are expanded into core forms at the start of evaluation (before compilation or interpretation) by a syntax expander.\n\n### 8.1. Keyword Bindings\n\n```scheme\n(define keyword expr)\n(let-syntax ((keyword expr) ...) form1 form2 ...)\n(letrec-syntax ((keyword expr) ...) form1 form2 ...)\n```\n\n### 8.2. Syntax-Rules Transformers\n\n> P is of the form (P1 ... Pn) and F is a list of n elements that match P1 through Pn\n\n上面一句话的意思如果模式 P 是 `(p1 p2 p3 p4)` 这样子的格式的话，则 F 也必须是包含 4 个元素的列表。这里的 `...` 表示的是确定的指定了 n 个子模式。而不是在模式出现 `...` 这个标识符。表示模式中出现 `...` 标识符是通过下面中提到的标识符 `ellipsis` 来指代的。注意这里容易造成混淆。\n\n```scheme\n(let ([if #f])\n  (let ([t 'okay])\n    (or if t)))\n```\n\n扩展为：\n\n```scheme\n((lambda (if1)\n   ((lambda (t1)\n      ((lambda (t2)\n         (if t2 t2 t1))\n       if1))\n    'okay))\n #f)\n```\n\n### 8.3. Syntax-Case Transformers\n\n> With this mechanism (`syntax-case`), transformers are procedures of one argument. The argument is a syntax object representing the form to be processed. The return value is a syntax object representing the output form. A syntax object may be any of the following.\n\n> `#'template` is equivalent to `(syntax template)`. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.\n\n> Syntactic extensions ordinarily take the form `(keyword subform ...)`, but the `syntax-case` system permits them to take the form of singleton identifiers as well.\n\n\n`(with-syntax ((pattern expr) ...) body1 body2 ...)`\n\n理解：这里理解的重点是 `pattern`，其实和 `syntax-case` 中的 `pattern` 一致。用于解构 `expr` 的值。且看下面的示例：\n\n```scheme\n(define-syntax lab\n  (lambda (x)\n    (syntax-case x ()\n      [(_ e1 e2)\n       (with-syntax ([(_ x1 x2) #'e1]\n                     [(_ y1 y2) #'e2])\n         #'(+ x1 x2 y1 y2))])))\n```\n\n> `quasisyntax` can be used in place of `with-syntax` in many cases.\n\n值得思考 `(datum->syntax template-identifier obj)` 的作用。\n\n关于本章的语法扩展问题，需要多思考作用域相关的问题。\n\n\n## 9. Records\n\n### 9.1. Defining Records\n\n注意每次定义 record type ，即使名字一样，也是不同的。\n\n### 9.2. Procedural Interface\n\n\n## 10. Libraries and Top-Level Programs\n\n学习 Scheme 库的建立。\n\n### 10.1. Standard Libraries\n\n### 10.2. Defining New Libraries\n\n### 10.3. Top-Level Programs\n\n> Top-level programs can be thought of as `library` forms without the library wrapper, library name, and export form.\n\n\n## 11. Exceptions and Conditions\n\n> Exceptions and conditions provide the means for system and user code to signal, detect, and recover from errors that occur when a program is run.\n\n### 11.1. Raising and Handling Exceptions\n\n### 11.2. Defining Condition Types\n\n### 11.3. Standard Condition Types\n\n## 12. Extended Examples\n\n### 12.1. Matrix and Vector Multiplication\n\n### 12.2. Sorting\n\n### 12.3. A Set Constructor\n\n### 12.4. Word Frequency Counting\n\n### 12.5. Scheme Printer\n\n### 12.6. Formatted Output\n\n## 总结\n\n重点是前三章的内容，值得多读几遍。另外第十二章的示例还差几个没有看完。其余章节都浏览了一遍。之后需要查阅相关的内容时，请在索引页面搜索。\n\n\n## Exercise\n\n2.2.1\n\na. (+ (* 1.2 (- 2 1/3) -8.7))\nb. (/ (+ 2/3 4/9) (- 5/11 -4/3))\nc. (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 1/2)))))\nd. (* 1 -2 3 -4 5 -6 7)\n\n2.2.2\n\ncomplex numbers\nreal numbers\nrational numbers\nintegers\n\n2.2.3\n\n```\na. (car cdr)\nb. (this ((is silly)))\nc. (is this silly?)\nd. (+ 2 3)\ne. (+ 2 3)\nf. +\ng. (2 3)\nh. #<procedure cons>\ni. cons\nj. (quote cons)\nk. quote\nl. 5\nm. 5\nn. 5\no. 5\n```\n\n2.2.4\n\n```\n(car (car '((a b) (c d)))) => a\n(car (cdr (car '((a b) (c d))))) => b\n(car (car (cdr '((a b) (c d))))) => c\n(car (cdr (car (cdr '((a b) (c d)))))) => d\n```\n\n2.2.5\n\n```\n'((a . b) ((c) d) ())\n```\n\n2.2.6\n\n```\n(1 (2 (3)) (()) 4 . 5)\n```\n\n2.2.8\n\n试着解释 Scheme 表达式是如何求值。\n\n答：先递归求值每个操作数，然后将得到的值应用到操作符上。\n\n2.3.1\n\n```\n(cdr (list + - * /)) => (list - * /)\n(car (list - * /)) => -\n(- 17 5) => 12\n```\n\n2.4.1\n\na.\n```scheme\n(let ([x (* 3 a)])\n  (let ([y1 (- x b)]\n        [y2 (+ x b)])\n    (+ y1 y2)))\n```\n\nb.\n```scheme\n(let ([ls (list a b c)])\n  (let ([x1 (car ls)]\n        [x2 (cdr ls)])\n    (cons x1 x2)))\n```\n\n2.4.3\n\na.\n\n```scheme\n(let ([x1 'a] [y1 'b])\n  (list (let ([x2 'c]) (cons x2 y1))\n        (let ([y2 'd]) (cons x1 y2))))\n```\n\nb.\n```scheme\n(let ([x1 '((a b) c)])\n  (cons (let ([x2 (cdr x1)])\n          (car x2))\n        (let ([x3 (car x1)])\n          (cons (let ([x4 (cdr x3)])\n                  (car x4))\n                (cons (let ([x5 (car x3)])\n                        x5)\n                      (cdr x3))))))\n```\n\n2.5.1\n\na. 'a\nb. '(a)\nc. 'a\nd. '()\n\n2.5.2\n\n```scheme\n(define list\n  (lambda ls ls))\n```\n\n2.5.3\n\na. empty\nb. +\nc. f\nd. f, y\ne. y\n\n2.6.2\n\n```scheme\n(define compose\n  (lambda (p1 p2)\n    (lambda (x)\n      (p1 (p2 x)))))\n\n(define cadr (compose car cdr))\n(define cddr (compose cdr cdr))\n```\n\n2.6.3\n\n```scheme\n(define caar (compose car car))\n(define cdar (compose cdr car))\n\n(define caaar (compose caar car))\n(define caadr (compose caar cdr))\n(define cadar (compose cadr car))\n(define cdaar (compose cdar car))\n\n(define cdddr (compose cddr cdr))\n(define cddar (compose cddr car))\n(define cdadr (compose cdar cdr))\n(define caddr (compose cadr cdr))\n\n(define caaaar (compose caaar car))\n(define caaadr (compose caaar cdr))\n(define caadar (compose caadr car))\n(define cadaar (compose cadar car))\n(define cdaaar (compose cdaar car))\n\n(define caaddr (compose caadr cdr))\n(define cadadr (compose cadar cdr))\n(define cdaadr (compose cdaar cdr))\n(define caddar (compose caddr car))\n(define cdadar (compose cdadr car))\n(define cddaar (compose cddar car))\n\n(define cddddr (compose cdddr cdr))\n(define cdddar (compose cdddr car))\n(define cddadr (compose cddar cdr))\n(define cdaddr (compose cdadr cdr))\n(define cadddr (compose caddr cdr))\n```\n\n2.7.1\n\n```scheme\n(define atom?\n  (lambda (x)\n    (not (pair? x))))\n```\n\n2.7.2\n\n```scheme\n(define shorter\n  (lambda (ls1 ls2)\n    (if (> (length ls2) (length ls1))\n        ls2\n        ls1)))\n```\n\n2.8.1\n\n交换 cons 的参数顺序将会导致复制的 tree 的每一个节点的子节点被调换。\n\n2.8.3\n\n```scheme\n(define make-list\n  (lambda (n obj)\n    (if (= n 0)\n        '()\n        (cons obj (make-list (- n 1) obj)))))\n```\n\n2.8.4\n\n```scheme\n(define list-ref\n  (lambda (ls idx)\n    (if (= idx 0)\n        (car ls)\n        (list-ref (cdr ls) (- idx 1)))))\n(define list-tail\n  (lambda (ls idx)\n    (if (= idx 0)\n        ls\n        (list-ref (cdr ls) (- idx 1)))))\n```\n\n2.8.5\n\n```scheme\n(define shorter?\n  (lambda (ls1 ls2)\n    (cond\n      [(null? ls1) #t]\n      [(null? ls2) #f]\n      [else (shorter? (cdr ls1) (cdr ls2))])))\n(define shorter\n  (lambda (ls1 ls2)\n    (if (shorter? ls1 ls2)\n        ls1\n        ls2)))\n```\n\n2.8.6\n\n```scheme\n(define odd?\n  (lambda (n)\n    (if (= n 0)\n        #f\n        (even? (- n 1)))))\n(define even?\n  (lambda (n)\n    (if (= n 0)\n        #t\n        (odd? (- n 1)))))\n```\n\n2.8.7\n\n```scheme\n(define transpose\n  (lambda (ls)\n    (let ([left (map car ls)]\n          [right (map cdr ls)])\n      (cons left right))))\n```\n\n2.9.1\n\n```scheme\n(define make-counter\n  (lambda (init step)\n    (let ([init init])\n      (lambda ()\n        (set! init (+ init step))\n        init))))\n```\n\n2.9.2\n\n```scheme\n(define make-stack\n  (lambda ()\n    (let ([ls '()])\n      (lambda (msg . args)\n        (case msg\n          [(empty?) (null? ls)]\n          [(push!) (set! ls (cons (car args) ls))]\n          [(top) (car ls)]\n          [(pop!) (set! ls (cdr ls))]\n          [else \"oops\"])))))\n```\n\n2.9.3\n\n```scheme\n(define make-stack\n  (lambda ()\n    (let ([ls '()])\n      (lambda (msg . args)\n        (case msg\n          [(empty?) (null? ls)]\n          [(push!) (set! ls (cons (car args) ls))]\n          [(top) (car ls)]\n          [(pop!) (set! ls (cdr ls))]\n          [(ref) (list-ref ls (car args))]\n          [(set!) (set-car! (list-tail ls (car args))\n                            (cadr args))]\n          [else \"oops\"])))))\n```\n\n2.9.4\n\n```scheme\n(define make-stack\n  (lambda (n)\n    (let ([vector (make-vector n)]\n          [at 0])\n      (lambda (msg . args)\n        (case msg\n          [(empty?) (= at 0)]\n          [(push!) (begin\n                     (vector-set! vector at (car args))\n                     (set! at (+ at 1)))]\n          [(top) (vector-ref vector (- at 1))]\n          [(pop!) (set! at (- at 1))]\n          [(ref)\n           (let ([idx (- at 1 (car args))])\n             (if (< idx 0)\n                 (assertion-violation 'make-stack \"out of range.\" idx)\n                 (vector-ref vector idx)))]\n          [(set!)\n           (let ([idx (- at 1 (car args))])\n             (if (< idx 0)\n                 (assertion-violation 'make-stack \"out of range.\" idx)\n                 (vector-set! vector idx (cadr args))))]\n          [else \"oops\"])))))\n```\n\n2.9.5\n\n```scheme\n(define make-queue\n  (lambda ()\n    (let ([end (cons 'ignored '())])\n      (cons end end))))\n\n(define emptyq?\n  (lambda (q)\n    (eq? (car q) (cdr q))))\n\n(define putq!\n  (lambda (q v)\n    (let ([end (cons 'ignored '())])\n      (set-car! (cdr q) v)\n      (set-cdr! (cdr q) end)\n      (set-cdr! q end))))\n\n(define getq\n  (lambda (q)\n    (if (emptyq? q)\n        (assertion-violation 'getq \"queue is empty\" q)\n        (car (car q)))))\n\n(define delq!\n  (lambda (q)\n    (if (emptyq? q)\n        (assertion-violation delq \"queue is empty\" q)\n        (set-car! q (cdr (car q))))))\n```\n\n2.9.6\n\n```scheme\n(define make-queue\n  (lambda ()\n    (let ([end '()])\n      (cons end end))))\n\n(define emptyq?\n  (lambda (q)\n    (and (null? (car q))\n         (null? (cdr q)))))\n\n(define putq!\n  (lambda (q v)\n    (let ([tail (cdr q)])\n      (if (null? tail)\n          (let ([body (cons v '())])\n            (set-car! q body)\n            (set-cdr! q body))\n          (begin\n            (set-cdr! tail (cons v '()))\n            (set-cdr! q (cdr tail)))))))\n\n(define getq\n  (lambda (q)\n    (if (emptyq? q)\n        (assertion-violation 'getq \"queue is empty\" q)\n        (car (car q)))))\n\n(define delq!\n  (lambda (q)\n    (cond\n      [(emptyq? q)\n       (assertion-violation delq \"queue is empty\" q)]\n      [(eq? (car q) (cdr q))\n       (let ([empty '()])\n         (set-car! q empty)\n         (set-cdr! q empty))]\n      [else\n       (set-car! q (cdr (car q)))])))\n```\n\n2.9.8\n\n```scheme\n(define list?\n  (lambda (x)\n    (cond\n      [(null? x) #t]\n      [(and (pair? x)\n            (have-cyclic? x x)) #f]\n      [(pair? x) (list-help (cdr x))]\n      [else #f])))\n\n(define list-help\n  (lambda (x)\n    (cond\n      [(null? x) #t]\n      [(pair? x) (list-help (cdr x))]\n      [else #f])))\n\n(define have-cyclic?\n  (lambda (hare tortoise)\n    (cond\n      [(not (pair? (cdr hare))) #f]\n      [(not (pair? (cddr hare))) #f]\n      [(eq? (cddr hare) (cdr tortoise)) #t]\n      [else (have-cyclic? (cdr (cdr hare)) (cdr tortoise))])))\n```\n\n3.1.1\n\n```scheme\n(let ([x (memv 'a ls)])\n  (and x (memv 'b x)))\n;; =>\n((lambda (x)\n   (if x (and (memv 'b x)) #f))\n (memv 'a ls))\n;; =>\n((lambda (x)\n   (if x (memv 'b x) #f))\n (memv 'a ls))\n```\n\n3.1.2\n\n```scheme\n(or (memv x '(a b c)) (list x))\n;; =>\n(if (memv x '(a b c))\n    (memv x '(a b c))\n    (or (list x)))\n;; =>\n(if (memv x '(a b c))\n    (memv x '(a b c))\n    (list x))\n```\n\n3.1.3\n\n```scheme\n(define-syntax let*\n  (syntax-rules ()\n    [(_ () b1 b2 ...)\n     (let () b1 b2 ...)]\n    [(_ ([x e]) b1 b2 ...)\n     (let ([x e]) b1 b2 ...)]\n    [(_ ([x1 e1] [x2 e2] ...) b1 b2 ...)\n     (let ([x1 e1])\n       (let* ([x2 e2] ...) b1 b2 ...))]))\n```\n\n3.1.4\n\n```scheme\n(define-syntax when ;; 如果对\n  (syntax-rules ()\n    [(_ test e1 e2 ...)\n     (if test\n         (begin e1 e2 ...)\n         #f)]))\n(define-syntax unless ;; 如果不对\n  (syntax-rules ()\n    [(_ test e1 e2 ...)\n     (when (not test) e1 e2 ...)]))\n```\n\n3.2.2\n\nthe named `let`, beacuse it's more simple.\n\n3.2.3\n\n```scheme\n(let xxx ([t 'even?] [x 20])\n  (cond\n    [(eq? t 'even?)\n     (or (= x 0)\n         (xxx 'odd? (- x 1)))]\n    [(eq? t 'odd?)\n     (and (not (= x 0))\n          (xxx 'even? (- x 1)))]))\n```\n\n3.2.4\n\n```scheme\n(fibonacci 40)\n```\n\n1: 331160280次\n2: 39次\n\n3.2.5\n\n```scheme\n;; use set!\n(define-syntax let\n  (syntax-rules ()\n    [(_ ((x e) ...) b1 b2 ...)\n     ((lambda (x ...) b1 b2 ...) e ...)]\n    [(_ name ((x e) ...) b1 b2 ...)\n     (let ([name #f])\n       (set! name (lambda (x ...) b1 b2 ...))\n       (name e ...))]))\n```\n\n3.2.6\n\n```scheme\n(define even? ; incorrect!\n  (lambda (x)\n    (let ([a (= x 0)])\n      (if a\n          a\n          (let ([b (odd? (- x 1))])\n            (if b b #f))))))\n(define even? ; correct!\n  (lambda (x)\n    (let ([a (= x 0)])\n      (if a\n          a\n          (odd? (-x 1))))))\n```\n\n注意它们的区别：每次调用 `even?` 就多了一层 `let` 和 `if`\n\n3.2.7\n\n```scheme\n(define factor\n  (lambda (n)\n    (let f ([n n] [i 3])\n      (let-values ([(s r) (exact-integer-sqrt n)])\n        (cond\n          [(>= i s) (list n)]\n          [(integer? (/ n 2))\n           (cons 2 (f (/ n 2) i))]\n          [(integer? (/ n i))\n           (cons i (f (/ n i) i))]\n          [else (f n (+ i 1))])))))\n```\n\nFirst is the most important problem to solve.\n\n3.3.1\n\n3.3.2\n\n```scheme\n(define product\n  (lambda (ls)\n    (let f ([ls ls] [c (lambda () 1)])\n      (cond\n        [(null? ls) (c)]\n        [(= (car ls) 0) 0]\n        [else (f (cdr ls) (lambda ()\n                            (* (car ls) (c))))]))))\n```\n\n通过回调的形式返回。\n\n3.3.3\n\n```scheme\n(define exit (call/cc (lambda (k) k)))\n(define quit\n  (lambda ()\n    (if (null? lwp-list)\n        (exit #f)\n        (start))))\n```\n\n关键是定义一个退出的 continuation。\n\n3.3.4\n\n```scheme\n(define lwp-list (make-queue))\n(define lwp\n  (lambda (thunk)\n    (putq! lwp-list thunk)))\n(define start\n  (lambda ()\n    (let ([p (getq lwp-list)])\n      (delq! lwp-list)\n      (p))))\n```\n\n3.3.5\n\n3.4.1\n\n```scheme\n(define reciprocal\n  (lambda (n success failure)\n    (if (= n 0)\n        (failure)\n        (success (/ 1 n)))))\n```\n\n3.4.2\n\n```scheme\n(define retry #f)\n(define factorial\n  (lambda (x k)\n    (if (= x 0)\n        (begin\n          (set! retry k)\n          (k 1))\n        (factorial (- x 1)\n                   (lambda (n)\n                     (k (* n x)))))))\n```\n\n3.4.3\n\n```scheme\n(define reciprocals\n  (lambda (ls success failure)\n    (let map1 [(ls ls) (ls2 '())]\n      (cond\n        [(null? ls)\n         (success (reverse ls2))]\n        [(= (car ls) 0)\n         (failure \"zero found\")]\n        [else (map1 (cdr ls) (cons (car ls) ls2))]))))\n```\n\n3.5.1\n\n```scheme\n(define-syntax complain\n  (syntax-rules ()\n    [(_ ek msg expr)\n     (ek (list msg expr))]))\n```\n\n3.5.2\n\n```scheme\n(define calc\n  (lambda (expr)\n    ; grab an error continuation ek\n    (call/cc\n     (lambda (ek)\n       (define do-calc\n         (lambda (ek expr)\n           (cond\n             [(number? expr) expr]\n             [(and (list? expr) (= (length expr) 3))\n              (let ([op (car expr)] [args (cdr expr)])\n                (case op\n                  [(add) (apply-op ek + args)]\n                  [(sub) (apply-op ek - args)]\n                  [(mul) (apply-op ek * args)]\n                  [(div) (apply-op ek / args)]\n                  [else (complain ek \"invalid operator\" op)]))]\n             [else (complain ek \"invalid expression\" expr)])))\n       (define apply-op\n         (lambda (ek op args)\n           (op (do-calc ek (car args)) (do-calc ek (cadr args)))))\n       (define complain\n         (lambda (ek msg expr)\n           (ek (list msg expr))))\n       (do-calc ek expr)))))\n```\n\n3.5.3\n\n```scheme\n(define calc #f)\n(let ()\n  (define do-calc\n    (lambda (expr)\n      (cond\n        [(number? expr) expr]\n        [(and (list? expr) (= (length expr) 3))\n         (let ([op (car expr)] [args (cdr expr)])\n           (case op\n             [(add) (apply-op + args)]\n             [(sub) (apply-op - args)]\n             [(mul) (apply-op * args)]\n             [(div) (apply-op / args)]\n             [else (assertion-violation 'do-calc \"invalid operator\" op)]))]\n        [else (assertion-violation 'do-calc \"invalid expression\" expr)])))\n  (define apply-op\n    (lambda (op args)\n      (op (do-calc (car args)) (do-calc (cadr args)))))\n  (set! calc do-calc))\n```\n\n3.5.4\n\n```scheme\n...\n       [(and (list? expr) (= (length expr) 2))\n         (let ([op (car expr)] [arg (cadr expr)])\n           (case op\n             [(minus) (- (do-calc arg))]))]\n...\n```\n\n3.6.1\n\n```scheme\n  (define-syntax gpa\n    (syntax-rules ()\n      [(_ g1 g2 ...)\n       (let ([ls (map letter->number\n                      (filter (lambda (g) (not (eq? g 'x)))\n                            '(g1 g2 ...)))])\n         (/ (apply + ls) (length ls)))]))\n```\n\n3.6.2\n\n```scheme\n...\n  define count\n    (lambda (g0 ls)\n      (length (filter (lambda (g) (eq? g g0))\n                      ls))))\n  (define gs '(a b c d f))\n\n  (define-syntax distribution\n    (syntax-rules ()\n      [(_ g1 g2 ...)\n       (let ([ls '(g1 g2 ...)])\n         (map list (map (lambda (g0) (count g0 ls))\n                        gs)\n              gs))]))\n...\n```\n\n3.6.3\n\n```scheme\n...\n  (define print-one\n    (lambda (gn)\n      (string-append\n       \"  \"\n       (symbol->string (cadr gn))\n       \": \"\n       (make-string (car gn) #\\*)\n       \"\\n\")))\n\n  (define print\n    (lambda (dist)\n      (if (null? dist)\n          \"\"\n          (string-append (print-one (car dist))\n                         (print (cdr dist))))))\n\n  (define histogram\n    (lambda (port dist)\n      (put-string port \"prints:\\n\")\n      (put-string port\n                  (print dist))))\n...\n```\n\n12.2.1\n\n使用 `(list (car ls))` 的原因是因为虽然此时 `n` 是 1，但是 `ls` 可能含有超过不只一个元素。如果直接返回 `ls`，就会导致结果不正确。\n\n如果替换成 `(if (null? (cdr ls)) ls (list (car ls)))`，可以省去 `ls` 的初始长度那么多的空间。\n\n12.2.2\n\n假设有 `n` 个数字排列，则可以省略 `n` 个空间。\n","source":"_posts/tspl4.md","raw":"---\ntitle: The Scheme Programming Language 摘抄笔记及习题答案\ndate: 2017/02/04\ntag:\n- scheme\ncategory:\n- note\nexcerpt: 本文为我阅读TSPL4的笔记和习题答案记录\n---\n\n## Preface\n\nScheme 由 Gerald J. Sussman 和 Guy L. Steele Jr. 发明，支持 lexical scoping、first-class procedures 和 continuations。\n\n本书的目标是提供关于 Scheme 编程语言（R6RS 标准）的介绍。\n\n## 1. Introduction\n\n> Scheme is a call-by-value language, but for at least mutable (objects that can be modified), the values are pointers to the actual storage.\n\n> At the heart of the Scheme language is a small core of syntactic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language.\n\n> To support lexical scoping, a procedure carries the lexical context (environment) along with its code.\n\n### 1.1. Scheme Syntax\n\n> Scheme programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.\n\n> Keywords, variables, and symbols are collectively called identifiers. Identifiers may be formed from letters, digits, and certain special characters, including ?, !, ., +, -, *, /, <, =, >, :, $, %, ^, &, _, ~, and @, as well as a set of additional Unicode characters.\n\n> A good rule is to use short identifiers when the scope of the identifier is small and longer identifiers when the scope is larger.\n\n> Structured forms and list constants are enclosed within parentheses, e.g., (a b c) or (* (- x 2) y).\n\n> Strings are enclosed in double quotation marks, e.g., \"I am a string\". Characters are preceded by #\\, e.g., #\\a.\n\ncomments: `; single line`, `#| block |#`, `#;(datum commnet)`\n\n### 1.2. Scheme Naming Conventions\n\n### 1.3. Typographical and Notational Conventions\n\n\n## 2. Getting Started\n\n### 2.1. Interacting with Scheme\n\n### 2.2. Simple Expressions\n\n> The `quote` (`'`) forces the list to be treated as data.\n\n> Symbols and variables in Scheme are similar to symbols and variables in mathematical expressions and equations. When we evaluate the mathematical expression 1 - _x_ for some value of _x_, we think of _x_ as a variable. On the other hand, when we consider the algebraic equation _x_^2 - 1 = (_x_ - 1)(_x_ + 1), we think of _x_ as a symbol (in fact, we think of the whole equation symbolically). Just as quoting a list tells Scheme to treat a parenthesized form as a list rather than as a procedure application, **quoting an identifier tells Scheme to treat the identifier as a symbol rather than as a variable**.\n\n> Numbers and strings may be quoted, too. Numbers and strings are treated as constants in any case, however, so quoting them is unnecessary.\n\n### 2.3. Evaluating Scheme Expressions\n\n> Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms provided by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme programmer; these are referred to as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms.\n\n### 2.4. Variables and Let Expressions\n\n每一个 variable 都有它的 scope，同名的 variable，更里面的 variable 会 shadow 外层的 variable。这种 scope 叫做 lexical scoping。\n\n```scheme\n(let ((var expr) ...) body1 body2 ...)\n```\n\n### 2.5. Lambda Expressions\n\n```scheme\n(lambda (var ...) body1 body2 ...)\n(lambda var body1 body2 ...)\n(lambda (var ... var . var) body1 body2 ...)\n```\n\n### 2.6. Top-Level Definitions\n\n### 2.7. Conditional Expressions\n\n> A predicate is a procedure that answers a specific question about its arguments and returns one of the two values #t or #f.\n\n### 2.8. Simple Recursion\n\n> Recursion is a simple concept: the application of a procedure from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive power far beyond ordinary looping constructs.\n\n**mapping**: 映射\n\n### 2.9. Assignment\n\n> Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings. Assignments are performed with set!.\n\n## 3. Going Further\n\n### 3.1. Syntactic Extension\n\n> The core syntactic forms include top-level `define` forms, constants, variables, procedure applications, `quote` expressions, `lambda` expressions, `if` expressions, and `set!` expressions.\n\ncore grammar:\n\n```\n<program> -> <form>*\n<form> -> <definition> | <expression>\n<definition> -> <variable definition> | (begin <definition>*)\n<variable definition> -> (define <variable> <expression>)\n<expression> -> <constant>\n             |  <variable>\n             |  (quote <datum>)\n             |  (lambda <formals> <expression> <expression>*)\n             |  (if <expression> <expression> <expression>)\n             |  (set! <variable> <expression>)\n             |  <application>\n<constant> -> <boolean> | <number> | <character> | <string>\n<formals> -> <variable>\n          |  (<variable>*)\n          |  (<variable> <variable>* . <variable>)\n<application> -> (<expression> <expression>*)\n\n<variable> is any Scheme identifier\n<datum> is any Scheme object, such as a number, list, symbol, or vector\n<boolean> is either #t or #f\n<number> is any number\n<character> is any character\n<string> is any string\n```\n\n### 3.2. More Recursion\n\n> In a `letrec` expression, `expr ...` are most often `lambda` expressions, though this need not be the case. One restriction on the expressions must be obeyed, however. It must be possible to evaluate each `expr` without evaluating any of the variables `var ...`.\n\n### 3.3. Continuations\n\n> During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. We call \"what to do with the value\" the continuation of a computation.\n\n对 continuation 的记录，意味着下次使用该 continuation 时会回到之前计算的某个点，再往下走。也就是说可以回到过去。\n\n\n### 3.4. Continuation Passing Style\n\n使函数调用的隐式 continuation 通过 CPS 转换变为显式。\n\n使用场景：\n\n1. 是函数调用可以返回多个值\n2. 可以传入多个 continuation\n\n### 3.5. Internal Definitions\n\n> Definitions may also appear at the front of a lambda, let, or letrec body, in which case the bindings they create are local to the body.\n\n### 3.6. Libraries\n\n用于模块化，只暴露必要的内容给使用者。\n\n```scheme\n(library (lib-name)\n  (export x1 x2 ...)\n  (import (rnrs))\n  ...)\n```\n\n## 4. Procedures and Variable Bindings\n\n### 4.1. Variable References\n\n> Since the scope of the definitions in a `library`, top-level program, `lambda`, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed.\n\n### 4.2. Lambda\n\n`(lambda formals body1 body2 ...)`\n\n### 4.3. Case-Lambda\n\n> The `case-lambda` syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments.\n\n`(case-lambda clause ...)`\n\n`clause`:\n`[formals body1 body2 ...]`\n\n### 4.4. Local Binding\n\n`let`, `let*`, `letrec`, `letrec*`\n\n### 4.5. Multiple Values\n\n`let-values`, `let*-values`\n\n### 4.6. Variable Definitions\n\n`define`\n\n> A set of definitions may be grouped by enclosing them in a `begin` form. Definitions grouped in this manner may appear wherever ordinary variable and syntax definitions may appear. They are treated as if written separately, i.e., without the enclosing `begin` form.\n\n### 4.7. Assignment\n\n`set!`\n\n## 5. Control Operations\n\n### 5.1. Procedure Application\n\n> Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application.\n\n`(apply procedure obj ... list)`\n\n> `apply` is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.\n\n### 5.2. Sequencing\n\n`(begin expr1 expr2 ...)`\n\n> The bodies of many syntactic forms, including `lambda`, `case-lambda`, `let`, `let*`, `letrec`, and `letrec*`, as well as the result clauses of `cond`, `case`, and `do`, are treated as if they were inside an implicit `begin`; i.e., the expressions making up the body or result clause are executed in sequence, with the values of the last expression being returned.\n\n### 5.3. Conditionals\n\n`if`, `not`, `and`, `or`, `cond`, `when`, `unless`, `case`\n\n### 5.4. Recursion and Iteration\n\n`(let name ((var expr) ...) body1 body2 ...)`\n\n`(do ((var init update) ...) (test result ...) expr ...)`\n\n### 5.5. Mapping and Folding\n\n`(map procedure list1 list2 ...)`\n`(for-each procedure list1 list2 ...)`\n\n> `for-each` is similar to `map` except that `for-each` does not create and return a list of the resulting values, and `for-each` guarantees to perform the applications in sequence over the elements from left to right.\n\n`(exists procedure list1 list2 ...)`\n`(for-all procedure list1 list2 ...)`\n\n`exists` 和 `for-all` 的区别在于前者是在调用函数返回 `#t` 是结束，后者是在返回 `#f` 是结束。\n\n`(fold-left procedure obj list1 list2 ...)`\n`(fold-right procedure obj list1 list2 ...)`\n\n### 5.6. Continuations\n\n用一句比较玄的话来讲就是：它（Continuation）可以去到未来，也可以回到过去。\n\n`(call/cc procedure)`\n`(dynamic-wind in body out)`\n\n`dynamic-wind` 还需要再思考清楚。\n\n### 5.7. Delayed Evaluation\n\n> The benefit of using `delay` and `force` is that some amount of computation might be avoided altogether if it is delayed until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or streams.\n\n### 5.8. Multiple Values\n\n`(call-with-values producer consumer)`\n\n### 5.9. Eval\n\n> Scheme's `eval` procedure allows programmers to write programs that construct and evaluate other programs. This ability to do run-time meta programming should not be overused but is handy when needed.\n\n`(eval obj environment)`\n`(environment import-spec ...)`\n\n\n## 6. Operations on objects\n\n> This chapter describes the operations on objects, including lists, numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations.\n\n### 6.1. Constants and Quotation\n\n`quote`, `quasiquote`, `unquote`, `unquote-splicing`\n\n### 6.2. Generic Equivalence and Type Predicates\n\n> `eq?` is most often used to compare symbols or to check for pointer equivalence of allocated objects\n\n`eq?`, `eqv?`, `equal?` 三者的区别在于后者比前者能判断的更加广泛。\n\n### 6.3. Lists and Pairs\n\n`(list '+)` 与 `(list +)` 的区别在于，第一个 list 包含的是符号 symbol +，而第二个 list 包含的是程序 procedure +。\n\n也就是说， list 的内容可以包含任意类型的值，包括 procedure。\n\n注意 `'(a b c)` 表示含有 symbol `a` 、 `b` 和 `c` 的 list，而不是一个叫 `(a b c)` 的 symbol。\n\n### 6.4. Numbers\n\n> Scheme numbers may be classified as integers, rational numbers, real numbers, or complex numbers. This classification is hierarchical, in that all integers are rational, all rational numbers are real, and all real numbers are complex.\n\n> A Scheme number may also be classified as exact or inexact, depending upon the quality of operations used to derive the number and the inputs to these operations.\n\n### 6.5. Fixnums\n\nfixnum 指固定范围内的整数。\n\n### 6.6. Flonums\n\n### 6.7. Characters\n\n### 6.8. Strings\n\n### 6.9. Vectors\n\n> Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time.\n\n### 6.10. Bytevectors\n\n> Bytevectors are vectors of raw binary data.\n\n### 6.11. Symbols\n\n> The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as identifiers in the representation of programs, allowing fast comparison of identifiers.\n\n### 6.12. Booleans\n\n### 6.13. Hashtables\n\n> Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose as association lists but are typically much faster when large numbers of associations are involved.\n\n### 6.14. Enumerations\n\n## 7. Input and Output\n\n> All input and output operations are performed through ports.\n\n> Ports are first-class objects, like any other object in Scheme.\n\n### 7.1. Transcoders\n\n### 7.2. Opening Files\n\n> It is perhaps easier to imagine that the default file options are the imaginary option symbols `create`, `fail-if-exists`, and `truncate`; `no-create` removes `create`, `no-fail` removes `fail-if-exists`, and `no-truncate` removes `truncate`.\n\n### 7.3. Standard Ports\n\n### 7.4. String and Bytevector Ports\n\n### 7.5. Opening Custom Ports\n\n### 7.6. Port Operations\n\n### 7.7. Input Operations\n\n### 7.8. Output Operations\n\n### 7.9. Convenience I/O\n\n### 7.10. Filesystem Operations\n\n### 7.11. Bytevector/String Conversions\n\n## 8. Syntactic Extension\n\n> Syntactic extensions, or macros, are used to simplify and regularize repeated patterns in a program, to introduce syntactic forms with new evaluation rules, and to perform transformations that help make programs more efficient.\n\n> Syntactic extensions are expanded into core forms at the start of evaluation (before compilation or interpretation) by a syntax expander.\n\n### 8.1. Keyword Bindings\n\n```scheme\n(define keyword expr)\n(let-syntax ((keyword expr) ...) form1 form2 ...)\n(letrec-syntax ((keyword expr) ...) form1 form2 ...)\n```\n\n### 8.2. Syntax-Rules Transformers\n\n> P is of the form (P1 ... Pn) and F is a list of n elements that match P1 through Pn\n\n上面一句话的意思如果模式 P 是 `(p1 p2 p3 p4)` 这样子的格式的话，则 F 也必须是包含 4 个元素的列表。这里的 `...` 表示的是确定的指定了 n 个子模式。而不是在模式出现 `...` 这个标识符。表示模式中出现 `...` 标识符是通过下面中提到的标识符 `ellipsis` 来指代的。注意这里容易造成混淆。\n\n```scheme\n(let ([if #f])\n  (let ([t 'okay])\n    (or if t)))\n```\n\n扩展为：\n\n```scheme\n((lambda (if1)\n   ((lambda (t1)\n      ((lambda (t2)\n         (if t2 t2 t1))\n       if1))\n    'okay))\n #f)\n```\n\n### 8.3. Syntax-Case Transformers\n\n> With this mechanism (`syntax-case`), transformers are procedures of one argument. The argument is a syntax object representing the form to be processed. The return value is a syntax object representing the output form. A syntax object may be any of the following.\n\n> `#'template` is equivalent to `(syntax template)`. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.\n\n> Syntactic extensions ordinarily take the form `(keyword subform ...)`, but the `syntax-case` system permits them to take the form of singleton identifiers as well.\n\n\n`(with-syntax ((pattern expr) ...) body1 body2 ...)`\n\n理解：这里理解的重点是 `pattern`，其实和 `syntax-case` 中的 `pattern` 一致。用于解构 `expr` 的值。且看下面的示例：\n\n```scheme\n(define-syntax lab\n  (lambda (x)\n    (syntax-case x ()\n      [(_ e1 e2)\n       (with-syntax ([(_ x1 x2) #'e1]\n                     [(_ y1 y2) #'e2])\n         #'(+ x1 x2 y1 y2))])))\n```\n\n> `quasisyntax` can be used in place of `with-syntax` in many cases.\n\n值得思考 `(datum->syntax template-identifier obj)` 的作用。\n\n关于本章的语法扩展问题，需要多思考作用域相关的问题。\n\n\n## 9. Records\n\n### 9.1. Defining Records\n\n注意每次定义 record type ，即使名字一样，也是不同的。\n\n### 9.2. Procedural Interface\n\n\n## 10. Libraries and Top-Level Programs\n\n学习 Scheme 库的建立。\n\n### 10.1. Standard Libraries\n\n### 10.2. Defining New Libraries\n\n### 10.3. Top-Level Programs\n\n> Top-level programs can be thought of as `library` forms without the library wrapper, library name, and export form.\n\n\n## 11. Exceptions and Conditions\n\n> Exceptions and conditions provide the means for system and user code to signal, detect, and recover from errors that occur when a program is run.\n\n### 11.1. Raising and Handling Exceptions\n\n### 11.2. Defining Condition Types\n\n### 11.3. Standard Condition Types\n\n## 12. Extended Examples\n\n### 12.1. Matrix and Vector Multiplication\n\n### 12.2. Sorting\n\n### 12.3. A Set Constructor\n\n### 12.4. Word Frequency Counting\n\n### 12.5. Scheme Printer\n\n### 12.6. Formatted Output\n\n## 总结\n\n重点是前三章的内容，值得多读几遍。另外第十二章的示例还差几个没有看完。其余章节都浏览了一遍。之后需要查阅相关的内容时，请在索引页面搜索。\n\n\n## Exercise\n\n2.2.1\n\na. (+ (* 1.2 (- 2 1/3) -8.7))\nb. (/ (+ 2/3 4/9) (- 5/11 -4/3))\nc. (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 1/2)))))\nd. (* 1 -2 3 -4 5 -6 7)\n\n2.2.2\n\ncomplex numbers\nreal numbers\nrational numbers\nintegers\n\n2.2.3\n\n```\na. (car cdr)\nb. (this ((is silly)))\nc. (is this silly?)\nd. (+ 2 3)\ne. (+ 2 3)\nf. +\ng. (2 3)\nh. #<procedure cons>\ni. cons\nj. (quote cons)\nk. quote\nl. 5\nm. 5\nn. 5\no. 5\n```\n\n2.2.4\n\n```\n(car (car '((a b) (c d)))) => a\n(car (cdr (car '((a b) (c d))))) => b\n(car (car (cdr '((a b) (c d))))) => c\n(car (cdr (car (cdr '((a b) (c d)))))) => d\n```\n\n2.2.5\n\n```\n'((a . b) ((c) d) ())\n```\n\n2.2.6\n\n```\n(1 (2 (3)) (()) 4 . 5)\n```\n\n2.2.8\n\n试着解释 Scheme 表达式是如何求值。\n\n答：先递归求值每个操作数，然后将得到的值应用到操作符上。\n\n2.3.1\n\n```\n(cdr (list + - * /)) => (list - * /)\n(car (list - * /)) => -\n(- 17 5) => 12\n```\n\n2.4.1\n\na.\n```scheme\n(let ([x (* 3 a)])\n  (let ([y1 (- x b)]\n        [y2 (+ x b)])\n    (+ y1 y2)))\n```\n\nb.\n```scheme\n(let ([ls (list a b c)])\n  (let ([x1 (car ls)]\n        [x2 (cdr ls)])\n    (cons x1 x2)))\n```\n\n2.4.3\n\na.\n\n```scheme\n(let ([x1 'a] [y1 'b])\n  (list (let ([x2 'c]) (cons x2 y1))\n        (let ([y2 'd]) (cons x1 y2))))\n```\n\nb.\n```scheme\n(let ([x1 '((a b) c)])\n  (cons (let ([x2 (cdr x1)])\n          (car x2))\n        (let ([x3 (car x1)])\n          (cons (let ([x4 (cdr x3)])\n                  (car x4))\n                (cons (let ([x5 (car x3)])\n                        x5)\n                      (cdr x3))))))\n```\n\n2.5.1\n\na. 'a\nb. '(a)\nc. 'a\nd. '()\n\n2.5.2\n\n```scheme\n(define list\n  (lambda ls ls))\n```\n\n2.5.3\n\na. empty\nb. +\nc. f\nd. f, y\ne. y\n\n2.6.2\n\n```scheme\n(define compose\n  (lambda (p1 p2)\n    (lambda (x)\n      (p1 (p2 x)))))\n\n(define cadr (compose car cdr))\n(define cddr (compose cdr cdr))\n```\n\n2.6.3\n\n```scheme\n(define caar (compose car car))\n(define cdar (compose cdr car))\n\n(define caaar (compose caar car))\n(define caadr (compose caar cdr))\n(define cadar (compose cadr car))\n(define cdaar (compose cdar car))\n\n(define cdddr (compose cddr cdr))\n(define cddar (compose cddr car))\n(define cdadr (compose cdar cdr))\n(define caddr (compose cadr cdr))\n\n(define caaaar (compose caaar car))\n(define caaadr (compose caaar cdr))\n(define caadar (compose caadr car))\n(define cadaar (compose cadar car))\n(define cdaaar (compose cdaar car))\n\n(define caaddr (compose caadr cdr))\n(define cadadr (compose cadar cdr))\n(define cdaadr (compose cdaar cdr))\n(define caddar (compose caddr car))\n(define cdadar (compose cdadr car))\n(define cddaar (compose cddar car))\n\n(define cddddr (compose cdddr cdr))\n(define cdddar (compose cdddr car))\n(define cddadr (compose cddar cdr))\n(define cdaddr (compose cdadr cdr))\n(define cadddr (compose caddr cdr))\n```\n\n2.7.1\n\n```scheme\n(define atom?\n  (lambda (x)\n    (not (pair? x))))\n```\n\n2.7.2\n\n```scheme\n(define shorter\n  (lambda (ls1 ls2)\n    (if (> (length ls2) (length ls1))\n        ls2\n        ls1)))\n```\n\n2.8.1\n\n交换 cons 的参数顺序将会导致复制的 tree 的每一个节点的子节点被调换。\n\n2.8.3\n\n```scheme\n(define make-list\n  (lambda (n obj)\n    (if (= n 0)\n        '()\n        (cons obj (make-list (- n 1) obj)))))\n```\n\n2.8.4\n\n```scheme\n(define list-ref\n  (lambda (ls idx)\n    (if (= idx 0)\n        (car ls)\n        (list-ref (cdr ls) (- idx 1)))))\n(define list-tail\n  (lambda (ls idx)\n    (if (= idx 0)\n        ls\n        (list-ref (cdr ls) (- idx 1)))))\n```\n\n2.8.5\n\n```scheme\n(define shorter?\n  (lambda (ls1 ls2)\n    (cond\n      [(null? ls1) #t]\n      [(null? ls2) #f]\n      [else (shorter? (cdr ls1) (cdr ls2))])))\n(define shorter\n  (lambda (ls1 ls2)\n    (if (shorter? ls1 ls2)\n        ls1\n        ls2)))\n```\n\n2.8.6\n\n```scheme\n(define odd?\n  (lambda (n)\n    (if (= n 0)\n        #f\n        (even? (- n 1)))))\n(define even?\n  (lambda (n)\n    (if (= n 0)\n        #t\n        (odd? (- n 1)))))\n```\n\n2.8.7\n\n```scheme\n(define transpose\n  (lambda (ls)\n    (let ([left (map car ls)]\n          [right (map cdr ls)])\n      (cons left right))))\n```\n\n2.9.1\n\n```scheme\n(define make-counter\n  (lambda (init step)\n    (let ([init init])\n      (lambda ()\n        (set! init (+ init step))\n        init))))\n```\n\n2.9.2\n\n```scheme\n(define make-stack\n  (lambda ()\n    (let ([ls '()])\n      (lambda (msg . args)\n        (case msg\n          [(empty?) (null? ls)]\n          [(push!) (set! ls (cons (car args) ls))]\n          [(top) (car ls)]\n          [(pop!) (set! ls (cdr ls))]\n          [else \"oops\"])))))\n```\n\n2.9.3\n\n```scheme\n(define make-stack\n  (lambda ()\n    (let ([ls '()])\n      (lambda (msg . args)\n        (case msg\n          [(empty?) (null? ls)]\n          [(push!) (set! ls (cons (car args) ls))]\n          [(top) (car ls)]\n          [(pop!) (set! ls (cdr ls))]\n          [(ref) (list-ref ls (car args))]\n          [(set!) (set-car! (list-tail ls (car args))\n                            (cadr args))]\n          [else \"oops\"])))))\n```\n\n2.9.4\n\n```scheme\n(define make-stack\n  (lambda (n)\n    (let ([vector (make-vector n)]\n          [at 0])\n      (lambda (msg . args)\n        (case msg\n          [(empty?) (= at 0)]\n          [(push!) (begin\n                     (vector-set! vector at (car args))\n                     (set! at (+ at 1)))]\n          [(top) (vector-ref vector (- at 1))]\n          [(pop!) (set! at (- at 1))]\n          [(ref)\n           (let ([idx (- at 1 (car args))])\n             (if (< idx 0)\n                 (assertion-violation 'make-stack \"out of range.\" idx)\n                 (vector-ref vector idx)))]\n          [(set!)\n           (let ([idx (- at 1 (car args))])\n             (if (< idx 0)\n                 (assertion-violation 'make-stack \"out of range.\" idx)\n                 (vector-set! vector idx (cadr args))))]\n          [else \"oops\"])))))\n```\n\n2.9.5\n\n```scheme\n(define make-queue\n  (lambda ()\n    (let ([end (cons 'ignored '())])\n      (cons end end))))\n\n(define emptyq?\n  (lambda (q)\n    (eq? (car q) (cdr q))))\n\n(define putq!\n  (lambda (q v)\n    (let ([end (cons 'ignored '())])\n      (set-car! (cdr q) v)\n      (set-cdr! (cdr q) end)\n      (set-cdr! q end))))\n\n(define getq\n  (lambda (q)\n    (if (emptyq? q)\n        (assertion-violation 'getq \"queue is empty\" q)\n        (car (car q)))))\n\n(define delq!\n  (lambda (q)\n    (if (emptyq? q)\n        (assertion-violation delq \"queue is empty\" q)\n        (set-car! q (cdr (car q))))))\n```\n\n2.9.6\n\n```scheme\n(define make-queue\n  (lambda ()\n    (let ([end '()])\n      (cons end end))))\n\n(define emptyq?\n  (lambda (q)\n    (and (null? (car q))\n         (null? (cdr q)))))\n\n(define putq!\n  (lambda (q v)\n    (let ([tail (cdr q)])\n      (if (null? tail)\n          (let ([body (cons v '())])\n            (set-car! q body)\n            (set-cdr! q body))\n          (begin\n            (set-cdr! tail (cons v '()))\n            (set-cdr! q (cdr tail)))))))\n\n(define getq\n  (lambda (q)\n    (if (emptyq? q)\n        (assertion-violation 'getq \"queue is empty\" q)\n        (car (car q)))))\n\n(define delq!\n  (lambda (q)\n    (cond\n      [(emptyq? q)\n       (assertion-violation delq \"queue is empty\" q)]\n      [(eq? (car q) (cdr q))\n       (let ([empty '()])\n         (set-car! q empty)\n         (set-cdr! q empty))]\n      [else\n       (set-car! q (cdr (car q)))])))\n```\n\n2.9.8\n\n```scheme\n(define list?\n  (lambda (x)\n    (cond\n      [(null? x) #t]\n      [(and (pair? x)\n            (have-cyclic? x x)) #f]\n      [(pair? x) (list-help (cdr x))]\n      [else #f])))\n\n(define list-help\n  (lambda (x)\n    (cond\n      [(null? x) #t]\n      [(pair? x) (list-help (cdr x))]\n      [else #f])))\n\n(define have-cyclic?\n  (lambda (hare tortoise)\n    (cond\n      [(not (pair? (cdr hare))) #f]\n      [(not (pair? (cddr hare))) #f]\n      [(eq? (cddr hare) (cdr tortoise)) #t]\n      [else (have-cyclic? (cdr (cdr hare)) (cdr tortoise))])))\n```\n\n3.1.1\n\n```scheme\n(let ([x (memv 'a ls)])\n  (and x (memv 'b x)))\n;; =>\n((lambda (x)\n   (if x (and (memv 'b x)) #f))\n (memv 'a ls))\n;; =>\n((lambda (x)\n   (if x (memv 'b x) #f))\n (memv 'a ls))\n```\n\n3.1.2\n\n```scheme\n(or (memv x '(a b c)) (list x))\n;; =>\n(if (memv x '(a b c))\n    (memv x '(a b c))\n    (or (list x)))\n;; =>\n(if (memv x '(a b c))\n    (memv x '(a b c))\n    (list x))\n```\n\n3.1.3\n\n```scheme\n(define-syntax let*\n  (syntax-rules ()\n    [(_ () b1 b2 ...)\n     (let () b1 b2 ...)]\n    [(_ ([x e]) b1 b2 ...)\n     (let ([x e]) b1 b2 ...)]\n    [(_ ([x1 e1] [x2 e2] ...) b1 b2 ...)\n     (let ([x1 e1])\n       (let* ([x2 e2] ...) b1 b2 ...))]))\n```\n\n3.1.4\n\n```scheme\n(define-syntax when ;; 如果对\n  (syntax-rules ()\n    [(_ test e1 e2 ...)\n     (if test\n         (begin e1 e2 ...)\n         #f)]))\n(define-syntax unless ;; 如果不对\n  (syntax-rules ()\n    [(_ test e1 e2 ...)\n     (when (not test) e1 e2 ...)]))\n```\n\n3.2.2\n\nthe named `let`, beacuse it's more simple.\n\n3.2.3\n\n```scheme\n(let xxx ([t 'even?] [x 20])\n  (cond\n    [(eq? t 'even?)\n     (or (= x 0)\n         (xxx 'odd? (- x 1)))]\n    [(eq? t 'odd?)\n     (and (not (= x 0))\n          (xxx 'even? (- x 1)))]))\n```\n\n3.2.4\n\n```scheme\n(fibonacci 40)\n```\n\n1: 331160280次\n2: 39次\n\n3.2.5\n\n```scheme\n;; use set!\n(define-syntax let\n  (syntax-rules ()\n    [(_ ((x e) ...) b1 b2 ...)\n     ((lambda (x ...) b1 b2 ...) e ...)]\n    [(_ name ((x e) ...) b1 b2 ...)\n     (let ([name #f])\n       (set! name (lambda (x ...) b1 b2 ...))\n       (name e ...))]))\n```\n\n3.2.6\n\n```scheme\n(define even? ; incorrect!\n  (lambda (x)\n    (let ([a (= x 0)])\n      (if a\n          a\n          (let ([b (odd? (- x 1))])\n            (if b b #f))))))\n(define even? ; correct!\n  (lambda (x)\n    (let ([a (= x 0)])\n      (if a\n          a\n          (odd? (-x 1))))))\n```\n\n注意它们的区别：每次调用 `even?` 就多了一层 `let` 和 `if`\n\n3.2.7\n\n```scheme\n(define factor\n  (lambda (n)\n    (let f ([n n] [i 3])\n      (let-values ([(s r) (exact-integer-sqrt n)])\n        (cond\n          [(>= i s) (list n)]\n          [(integer? (/ n 2))\n           (cons 2 (f (/ n 2) i))]\n          [(integer? (/ n i))\n           (cons i (f (/ n i) i))]\n          [else (f n (+ i 1))])))))\n```\n\nFirst is the most important problem to solve.\n\n3.3.1\n\n3.3.2\n\n```scheme\n(define product\n  (lambda (ls)\n    (let f ([ls ls] [c (lambda () 1)])\n      (cond\n        [(null? ls) (c)]\n        [(= (car ls) 0) 0]\n        [else (f (cdr ls) (lambda ()\n                            (* (car ls) (c))))]))))\n```\n\n通过回调的形式返回。\n\n3.3.3\n\n```scheme\n(define exit (call/cc (lambda (k) k)))\n(define quit\n  (lambda ()\n    (if (null? lwp-list)\n        (exit #f)\n        (start))))\n```\n\n关键是定义一个退出的 continuation。\n\n3.3.4\n\n```scheme\n(define lwp-list (make-queue))\n(define lwp\n  (lambda (thunk)\n    (putq! lwp-list thunk)))\n(define start\n  (lambda ()\n    (let ([p (getq lwp-list)])\n      (delq! lwp-list)\n      (p))))\n```\n\n3.3.5\n\n3.4.1\n\n```scheme\n(define reciprocal\n  (lambda (n success failure)\n    (if (= n 0)\n        (failure)\n        (success (/ 1 n)))))\n```\n\n3.4.2\n\n```scheme\n(define retry #f)\n(define factorial\n  (lambda (x k)\n    (if (= x 0)\n        (begin\n          (set! retry k)\n          (k 1))\n        (factorial (- x 1)\n                   (lambda (n)\n                     (k (* n x)))))))\n```\n\n3.4.3\n\n```scheme\n(define reciprocals\n  (lambda (ls success failure)\n    (let map1 [(ls ls) (ls2 '())]\n      (cond\n        [(null? ls)\n         (success (reverse ls2))]\n        [(= (car ls) 0)\n         (failure \"zero found\")]\n        [else (map1 (cdr ls) (cons (car ls) ls2))]))))\n```\n\n3.5.1\n\n```scheme\n(define-syntax complain\n  (syntax-rules ()\n    [(_ ek msg expr)\n     (ek (list msg expr))]))\n```\n\n3.5.2\n\n```scheme\n(define calc\n  (lambda (expr)\n    ; grab an error continuation ek\n    (call/cc\n     (lambda (ek)\n       (define do-calc\n         (lambda (ek expr)\n           (cond\n             [(number? expr) expr]\n             [(and (list? expr) (= (length expr) 3))\n              (let ([op (car expr)] [args (cdr expr)])\n                (case op\n                  [(add) (apply-op ek + args)]\n                  [(sub) (apply-op ek - args)]\n                  [(mul) (apply-op ek * args)]\n                  [(div) (apply-op ek / args)]\n                  [else (complain ek \"invalid operator\" op)]))]\n             [else (complain ek \"invalid expression\" expr)])))\n       (define apply-op\n         (lambda (ek op args)\n           (op (do-calc ek (car args)) (do-calc ek (cadr args)))))\n       (define complain\n         (lambda (ek msg expr)\n           (ek (list msg expr))))\n       (do-calc ek expr)))))\n```\n\n3.5.3\n\n```scheme\n(define calc #f)\n(let ()\n  (define do-calc\n    (lambda (expr)\n      (cond\n        [(number? expr) expr]\n        [(and (list? expr) (= (length expr) 3))\n         (let ([op (car expr)] [args (cdr expr)])\n           (case op\n             [(add) (apply-op + args)]\n             [(sub) (apply-op - args)]\n             [(mul) (apply-op * args)]\n             [(div) (apply-op / args)]\n             [else (assertion-violation 'do-calc \"invalid operator\" op)]))]\n        [else (assertion-violation 'do-calc \"invalid expression\" expr)])))\n  (define apply-op\n    (lambda (op args)\n      (op (do-calc (car args)) (do-calc (cadr args)))))\n  (set! calc do-calc))\n```\n\n3.5.4\n\n```scheme\n...\n       [(and (list? expr) (= (length expr) 2))\n         (let ([op (car expr)] [arg (cadr expr)])\n           (case op\n             [(minus) (- (do-calc arg))]))]\n...\n```\n\n3.6.1\n\n```scheme\n  (define-syntax gpa\n    (syntax-rules ()\n      [(_ g1 g2 ...)\n       (let ([ls (map letter->number\n                      (filter (lambda (g) (not (eq? g 'x)))\n                            '(g1 g2 ...)))])\n         (/ (apply + ls) (length ls)))]))\n```\n\n3.6.2\n\n```scheme\n...\n  define count\n    (lambda (g0 ls)\n      (length (filter (lambda (g) (eq? g g0))\n                      ls))))\n  (define gs '(a b c d f))\n\n  (define-syntax distribution\n    (syntax-rules ()\n      [(_ g1 g2 ...)\n       (let ([ls '(g1 g2 ...)])\n         (map list (map (lambda (g0) (count g0 ls))\n                        gs)\n              gs))]))\n...\n```\n\n3.6.3\n\n```scheme\n...\n  (define print-one\n    (lambda (gn)\n      (string-append\n       \"  \"\n       (symbol->string (cadr gn))\n       \": \"\n       (make-string (car gn) #\\*)\n       \"\\n\")))\n\n  (define print\n    (lambda (dist)\n      (if (null? dist)\n          \"\"\n          (string-append (print-one (car dist))\n                         (print (cdr dist))))))\n\n  (define histogram\n    (lambda (port dist)\n      (put-string port \"prints:\\n\")\n      (put-string port\n                  (print dist))))\n...\n```\n\n12.2.1\n\n使用 `(list (car ls))` 的原因是因为虽然此时 `n` 是 1，但是 `ls` 可能含有超过不只一个元素。如果直接返回 `ls`，就会导致结果不正确。\n\n如果替换成 `(if (null? (cdr ls)) ls (list (car ls)))`，可以省去 `ls` 的初始长度那么多的空间。\n\n12.2.2\n\n假设有 `n` 个数字排列，则可以省略 `n` 个空间。\n","slug":"tspl4","published":1,"updated":"2020-11-28T14:23:51.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki1szk0a001mrnq7b2skdd5p","content":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>Scheme 由 Gerald J. Sussman 和 Guy L. Steele Jr. 发明，支持 lexical scoping、first-class procedures 和 continuations。</p>\n<p>本书的目标是提供关于 Scheme 编程语言（R6RS 标准）的介绍。</p>\n<h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h2><blockquote>\n<p>Scheme is a call-by-value language, but for at least mutable (objects that can be modified), the values are pointers to the actual storage.</p>\n</blockquote>\n<blockquote>\n<p>At the heart of the Scheme language is a small core of syntactic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language.</p>\n</blockquote>\n<blockquote>\n<p>To support lexical scoping, a procedure carries the lexical context (environment) along with its code.</p>\n</blockquote>\n<h3 id=\"1-1-Scheme-Syntax\"><a href=\"#1-1-Scheme-Syntax\" class=\"headerlink\" title=\"1.1. Scheme Syntax\"></a>1.1. Scheme Syntax</h3><blockquote>\n<p>Scheme programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.</p>\n</blockquote>\n<blockquote>\n<p>Keywords, variables, and symbols are collectively called identifiers. Identifiers may be formed from letters, digits, and certain special characters, including ?, !, ., +, -, *, /, &lt;, =, &gt;, :, $, %, ^, &amp;, _, ~, and @, as well as a set of additional Unicode characters.</p>\n</blockquote>\n<blockquote>\n<p>A good rule is to use short identifiers when the scope of the identifier is small and longer identifiers when the scope is larger.</p>\n</blockquote>\n<blockquote>\n<p>Structured forms and list constants are enclosed within parentheses, e.g., (a b c) or (* (- x 2) y).</p>\n</blockquote>\n<blockquote>\n<p>Strings are enclosed in double quotation marks, e.g., “I am a string”. Characters are preceded by #, e.g., #\\a.</p>\n</blockquote>\n<p>comments: <code>; single line</code>, <code>#| block |#</code>, <code>#;(datum commnet)</code></p>\n<h3 id=\"1-2-Scheme-Naming-Conventions\"><a href=\"#1-2-Scheme-Naming-Conventions\" class=\"headerlink\" title=\"1.2. Scheme Naming Conventions\"></a>1.2. Scheme Naming Conventions</h3><h3 id=\"1-3-Typographical-and-Notational-Conventions\"><a href=\"#1-3-Typographical-and-Notational-Conventions\" class=\"headerlink\" title=\"1.3. Typographical and Notational Conventions\"></a>1.3. Typographical and Notational Conventions</h3><h2 id=\"2-Getting-Started\"><a href=\"#2-Getting-Started\" class=\"headerlink\" title=\"2. Getting Started\"></a>2. Getting Started</h2><h3 id=\"2-1-Interacting-with-Scheme\"><a href=\"#2-1-Interacting-with-Scheme\" class=\"headerlink\" title=\"2.1. Interacting with Scheme\"></a>2.1. Interacting with Scheme</h3><h3 id=\"2-2-Simple-Expressions\"><a href=\"#2-2-Simple-Expressions\" class=\"headerlink\" title=\"2.2. Simple Expressions\"></a>2.2. Simple Expressions</h3><blockquote>\n<p>The <code>quote</code> (<code>&#39;</code>) forces the list to be treated as data.</p>\n</blockquote>\n<blockquote>\n<p>Symbols and variables in Scheme are similar to symbols and variables in mathematical expressions and equations. When we evaluate the mathematical expression 1 - <em>x</em> for some value of <em>x</em>, we think of <em>x</em> as a variable. On the other hand, when we consider the algebraic equation <em>x_^2 - 1 = (_x</em> - 1)(<em>x</em> + 1), we think of <em>x</em> as a symbol (in fact, we think of the whole equation symbolically). Just as quoting a list tells Scheme to treat a parenthesized form as a list rather than as a procedure application, <strong>quoting an identifier tells Scheme to treat the identifier as a symbol rather than as a variable</strong>.</p>\n</blockquote>\n<blockquote>\n<p>Numbers and strings may be quoted, too. Numbers and strings are treated as constants in any case, however, so quoting them is unnecessary.</p>\n</blockquote>\n<h3 id=\"2-3-Evaluating-Scheme-Expressions\"><a href=\"#2-3-Evaluating-Scheme-Expressions\" class=\"headerlink\" title=\"2.3. Evaluating Scheme Expressions\"></a>2.3. Evaluating Scheme Expressions</h3><blockquote>\n<p>Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms provided by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme programmer; these are referred to as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms.</p>\n</blockquote>\n<h3 id=\"2-4-Variables-and-Let-Expressions\"><a href=\"#2-4-Variables-and-Let-Expressions\" class=\"headerlink\" title=\"2.4. Variables and Let Expressions\"></a>2.4. Variables and Let Expressions</h3><p>每一个 variable 都有它的 scope，同名的 variable，更里面的 variable 会 shadow 外层的 variable。这种 scope 叫做 lexical scoping。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">var</span> expr) ...) body1 body2 ...)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-Lambda-Expressions\"><a href=\"#2-5-Lambda-Expressions\" class=\"headerlink\" title=\"2.5. Lambda Expressions\"></a>2.5. Lambda Expressions</h3><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (var ...) body1 body2 ...)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> <span class=\"name\">var</span> <span class=\"name\">body1</span> <span class=\"name\">body2</span> <span class=\"name\"><span class=\"builtin-name\">...</span></span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (var ... var . var) body1 body2 ...)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-6-Top-Level-Definitions\"><a href=\"#2-6-Top-Level-Definitions\" class=\"headerlink\" title=\"2.6. Top-Level Definitions\"></a>2.6. Top-Level Definitions</h3><h3 id=\"2-7-Conditional-Expressions\"><a href=\"#2-7-Conditional-Expressions\" class=\"headerlink\" title=\"2.7. Conditional Expressions\"></a>2.7. Conditional Expressions</h3><blockquote>\n<p>A predicate is a procedure that answers a specific question about its arguments and returns one of the two values #t or #f.</p>\n</blockquote>\n<h3 id=\"2-8-Simple-Recursion\"><a href=\"#2-8-Simple-Recursion\" class=\"headerlink\" title=\"2.8. Simple Recursion\"></a>2.8. Simple Recursion</h3><blockquote>\n<p>Recursion is a simple concept: the application of a procedure from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive power far beyond ordinary looping constructs.</p>\n</blockquote>\n<p><strong>mapping</strong>: 映射</p>\n<h3 id=\"2-9-Assignment\"><a href=\"#2-9-Assignment\" class=\"headerlink\" title=\"2.9. Assignment\"></a>2.9. Assignment</h3><blockquote>\n<p>Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings. Assignments are performed with set!.</p>\n</blockquote>\n<h2 id=\"3-Going-Further\"><a href=\"#3-Going-Further\" class=\"headerlink\" title=\"3. Going Further\"></a>3. Going Further</h2><h3 id=\"3-1-Syntactic-Extension\"><a href=\"#3-1-Syntactic-Extension\" class=\"headerlink\" title=\"3.1. Syntactic Extension\"></a>3.1. Syntactic Extension</h3><blockquote>\n<p>The core syntactic forms include top-level <code>define</code> forms, constants, variables, procedure applications, <code>quote</code> expressions, <code>lambda</code> expressions, <code>if</code> expressions, and <code>set!</code> expressions.</p>\n</blockquote>\n<p>core grammar:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;program&gt; -&gt; &lt;form&gt;*</span><br><span class=\"line\">&lt;form&gt; -&gt; &lt;definition&gt; | &lt;expression&gt;</span><br><span class=\"line\">&lt;definition&gt; -&gt; &lt;variable definition&gt; | (begin &lt;definition&gt;*)</span><br><span class=\"line\">&lt;variable definition&gt; -&gt; (define &lt;variable&gt; &lt;expression&gt;)</span><br><span class=\"line\">&lt;expression&gt; -&gt; &lt;constant&gt;</span><br><span class=\"line\">             |  &lt;variable&gt;</span><br><span class=\"line\">             |  (quote &lt;datum&gt;)</span><br><span class=\"line\">             |  (lambda &lt;formals&gt; &lt;expression&gt; &lt;expression&gt;*)</span><br><span class=\"line\">             |  (if &lt;expression&gt; &lt;expression&gt; &lt;expression&gt;)</span><br><span class=\"line\">             |  (set! &lt;variable&gt; &lt;expression&gt;)</span><br><span class=\"line\">             |  &lt;application&gt;</span><br><span class=\"line\">&lt;constant&gt; -&gt; &lt;boolean&gt; | &lt;number&gt; | &lt;character&gt; | &lt;string&gt;</span><br><span class=\"line\">&lt;formals&gt; -&gt; &lt;variable&gt;</span><br><span class=\"line\">          |  (&lt;variable&gt;*)</span><br><span class=\"line\">          |  (&lt;variable&gt; &lt;variable&gt;* . &lt;variable&gt;)</span><br><span class=\"line\">&lt;application&gt; -&gt; (&lt;expression&gt; &lt;expression&gt;*)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable&gt; is any Scheme identifier</span><br><span class=\"line\">&lt;datum&gt; is any Scheme object, such as a number, list, symbol, or vector</span><br><span class=\"line\">&lt;boolean&gt; is either #t or #f</span><br><span class=\"line\">&lt;number&gt; is any number</span><br><span class=\"line\">&lt;character&gt; is any character</span><br><span class=\"line\">&lt;string&gt; is any string</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-More-Recursion\"><a href=\"#3-2-More-Recursion\" class=\"headerlink\" title=\"3.2. More Recursion\"></a>3.2. More Recursion</h3><blockquote>\n<p>In a <code>letrec</code> expression, <code>expr ...</code> are most often <code>lambda</code> expressions, though this need not be the case. One restriction on the expressions must be obeyed, however. It must be possible to evaluate each <code>expr</code> without evaluating any of the variables <code>var ...</code>.</p>\n</blockquote>\n<h3 id=\"3-3-Continuations\"><a href=\"#3-3-Continuations\" class=\"headerlink\" title=\"3.3. Continuations\"></a>3.3. Continuations</h3><blockquote>\n<p>During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. We call “what to do with the value” the continuation of a computation.</p>\n</blockquote>\n<p>对 continuation 的记录，意味着下次使用该 continuation 时会回到之前计算的某个点，再往下走。也就是说可以回到过去。</p>\n<h3 id=\"3-4-Continuation-Passing-Style\"><a href=\"#3-4-Continuation-Passing-Style\" class=\"headerlink\" title=\"3.4. Continuation Passing Style\"></a>3.4. Continuation Passing Style</h3><p>使函数调用的隐式 continuation 通过 CPS 转换变为显式。</p>\n<p>使用场景：</p>\n<ol>\n<li>是函数调用可以返回多个值</li>\n<li>可以传入多个 continuation</li>\n</ol>\n<h3 id=\"3-5-Internal-Definitions\"><a href=\"#3-5-Internal-Definitions\" class=\"headerlink\" title=\"3.5. Internal Definitions\"></a>3.5. Internal Definitions</h3><blockquote>\n<p>Definitions may also appear at the front of a lambda, let, or letrec body, in which case the bindings they create are local to the body.</p>\n</blockquote>\n<h3 id=\"3-6-Libraries\"><a href=\"#3-6-Libraries\" class=\"headerlink\" title=\"3.6. Libraries\"></a>3.6. Libraries</h3><p>用于模块化，只暴露必要的内容给使用者。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">library</span> (<span class=\"name\">lib-name</span>)</span><br><span class=\"line\">  (<span class=\"name\">export</span> x1 x2 ...)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">import</span></span> (<span class=\"name\">rnrs</span>))</span><br><span class=\"line\">  ...)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-Procedures-and-Variable-Bindings\"><a href=\"#4-Procedures-and-Variable-Bindings\" class=\"headerlink\" title=\"4. Procedures and Variable Bindings\"></a>4. Procedures and Variable Bindings</h2><h3 id=\"4-1-Variable-References\"><a href=\"#4-1-Variable-References\" class=\"headerlink\" title=\"4.1. Variable References\"></a>4.1. Variable References</h3><blockquote>\n<p>Since the scope of the definitions in a <code>library</code>, top-level program, <code>lambda</code>, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed.</p>\n</blockquote>\n<h3 id=\"4-2-Lambda\"><a href=\"#4-2-Lambda\" class=\"headerlink\" title=\"4.2. Lambda\"></a>4.2. Lambda</h3><p><code>(lambda formals body1 body2 ...)</code></p>\n<h3 id=\"4-3-Case-Lambda\"><a href=\"#4-3-Case-Lambda\" class=\"headerlink\" title=\"4.3. Case-Lambda\"></a>4.3. Case-Lambda</h3><blockquote>\n<p>The <code>case-lambda</code> syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments.</p>\n</blockquote>\n<p><code>(case-lambda clause ...)</code></p>\n<p><code>clause</code>:<br><code>[formals body1 body2 ...]</code></p>\n<h3 id=\"4-4-Local-Binding\"><a href=\"#4-4-Local-Binding\" class=\"headerlink\" title=\"4.4. Local Binding\"></a>4.4. Local Binding</h3><p><code>let</code>, <code>let*</code>, <code>letrec</code>, <code>letrec*</code></p>\n<h3 id=\"4-5-Multiple-Values\"><a href=\"#4-5-Multiple-Values\" class=\"headerlink\" title=\"4.5. Multiple Values\"></a>4.5. Multiple Values</h3><p><code>let-values</code>, <code>let*-values</code></p>\n<h3 id=\"4-6-Variable-Definitions\"><a href=\"#4-6-Variable-Definitions\" class=\"headerlink\" title=\"4.6. Variable Definitions\"></a>4.6. Variable Definitions</h3><p><code>define</code></p>\n<blockquote>\n<p>A set of definitions may be grouped by enclosing them in a <code>begin</code> form. Definitions grouped in this manner may appear wherever ordinary variable and syntax definitions may appear. They are treated as if written separately, i.e., without the enclosing <code>begin</code> form.</p>\n</blockquote>\n<h3 id=\"4-7-Assignment\"><a href=\"#4-7-Assignment\" class=\"headerlink\" title=\"4.7. Assignment\"></a>4.7. Assignment</h3><p><code>set!</code></p>\n<h2 id=\"5-Control-Operations\"><a href=\"#5-Control-Operations\" class=\"headerlink\" title=\"5. Control Operations\"></a>5. Control Operations</h2><h3 id=\"5-1-Procedure-Application\"><a href=\"#5-1-Procedure-Application\" class=\"headerlink\" title=\"5.1. Procedure Application\"></a>5.1. Procedure Application</h3><blockquote>\n<p>Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application.</p>\n</blockquote>\n<p><code>(apply procedure obj ... list)</code></p>\n<blockquote>\n<p><code>apply</code> is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.</p>\n</blockquote>\n<h3 id=\"5-2-Sequencing\"><a href=\"#5-2-Sequencing\" class=\"headerlink\" title=\"5.2. Sequencing\"></a>5.2. Sequencing</h3><p><code>(begin expr1 expr2 ...)</code></p>\n<blockquote>\n<p>The bodies of many syntactic forms, including <code>lambda</code>, <code>case-lambda</code>, <code>let</code>, <code>let*</code>, <code>letrec</code>, and <code>letrec*</code>, as well as the result clauses of <code>cond</code>, <code>case</code>, and <code>do</code>, are treated as if they were inside an implicit <code>begin</code>; i.e., the expressions making up the body or result clause are executed in sequence, with the values of the last expression being returned.</p>\n</blockquote>\n<h3 id=\"5-3-Conditionals\"><a href=\"#5-3-Conditionals\" class=\"headerlink\" title=\"5.3. Conditionals\"></a>5.3. Conditionals</h3><p><code>if</code>, <code>not</code>, <code>and</code>, <code>or</code>, <code>cond</code>, <code>when</code>, <code>unless</code>, <code>case</code></p>\n<h3 id=\"5-4-Recursion-and-Iteration\"><a href=\"#5-4-Recursion-and-Iteration\" class=\"headerlink\" title=\"5.4. Recursion and Iteration\"></a>5.4. Recursion and Iteration</h3><p><code>(let name ((var expr) ...) body1 body2 ...)</code></p>\n<p><code>(do ((var init update) ...) (test result ...) expr ...)</code></p>\n<h3 id=\"5-5-Mapping-and-Folding\"><a href=\"#5-5-Mapping-and-Folding\" class=\"headerlink\" title=\"5.5. Mapping and Folding\"></a>5.5. Mapping and Folding</h3><p><code>(map procedure list1 list2 ...)</code><br><code>(for-each procedure list1 list2 ...)</code></p>\n<blockquote>\n<p><code>for-each</code> is similar to <code>map</code> except that <code>for-each</code> does not create and return a list of the resulting values, and <code>for-each</code> guarantees to perform the applications in sequence over the elements from left to right.</p>\n</blockquote>\n<p><code>(exists procedure list1 list2 ...)</code><br><code>(for-all procedure list1 list2 ...)</code></p>\n<p><code>exists</code> 和 <code>for-all</code> 的区别在于前者是在调用函数返回 <code>#t</code> 是结束，后者是在返回 <code>#f</code> 是结束。</p>\n<p><code>(fold-left procedure obj list1 list2 ...)</code><br><code>(fold-right procedure obj list1 list2 ...)</code></p>\n<h3 id=\"5-6-Continuations\"><a href=\"#5-6-Continuations\" class=\"headerlink\" title=\"5.6. Continuations\"></a>5.6. Continuations</h3><p>用一句比较玄的话来讲就是：它（Continuation）可以去到未来，也可以回到过去。</p>\n<p><code>(call/cc procedure)</code><br><code>(dynamic-wind in body out)</code></p>\n<p><code>dynamic-wind</code> 还需要再思考清楚。</p>\n<h3 id=\"5-7-Delayed-Evaluation\"><a href=\"#5-7-Delayed-Evaluation\" class=\"headerlink\" title=\"5.7. Delayed Evaluation\"></a>5.7. Delayed Evaluation</h3><blockquote>\n<p>The benefit of using <code>delay</code> and <code>force</code> is that some amount of computation might be avoided altogether if it is delayed until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or streams.</p>\n</blockquote>\n<h3 id=\"5-8-Multiple-Values\"><a href=\"#5-8-Multiple-Values\" class=\"headerlink\" title=\"5.8. Multiple Values\"></a>5.8. Multiple Values</h3><p><code>(call-with-values producer consumer)</code></p>\n<h3 id=\"5-9-Eval\"><a href=\"#5-9-Eval\" class=\"headerlink\" title=\"5.9. Eval\"></a>5.9. Eval</h3><blockquote>\n<p>Scheme’s <code>eval</code> procedure allows programmers to write programs that construct and evaluate other programs. This ability to do run-time meta programming should not be overused but is handy when needed.</p>\n</blockquote>\n<p><code>(eval obj environment)</code><br><code>(environment import-spec ...)</code></p>\n<h2 id=\"6-Operations-on-objects\"><a href=\"#6-Operations-on-objects\" class=\"headerlink\" title=\"6. Operations on objects\"></a>6. Operations on objects</h2><blockquote>\n<p>This chapter describes the operations on objects, including lists, numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations.</p>\n</blockquote>\n<h3 id=\"6-1-Constants-and-Quotation\"><a href=\"#6-1-Constants-and-Quotation\" class=\"headerlink\" title=\"6.1. Constants and Quotation\"></a>6.1. Constants and Quotation</h3><p><code>quote</code>, <code>quasiquote</code>, <code>unquote</code>, <code>unquote-splicing</code></p>\n<h3 id=\"6-2-Generic-Equivalence-and-Type-Predicates\"><a href=\"#6-2-Generic-Equivalence-and-Type-Predicates\" class=\"headerlink\" title=\"6.2. Generic Equivalence and Type Predicates\"></a>6.2. Generic Equivalence and Type Predicates</h3><blockquote>\n<p><code>eq?</code> is most often used to compare symbols or to check for pointer equivalence of allocated objects</p>\n</blockquote>\n<p><code>eq?</code>, <code>eqv?</code>, <code>equal?</code> 三者的区别在于后者比前者能判断的更加广泛。</p>\n<h3 id=\"6-3-Lists-and-Pairs\"><a href=\"#6-3-Lists-and-Pairs\" class=\"headerlink\" title=\"6.3. Lists and Pairs\"></a>6.3. Lists and Pairs</h3><p><code>(list &#39;+)</code> 与 <code>(list +)</code> 的区别在于，第一个 list 包含的是符号 symbol +，而第二个 list 包含的是程序 procedure +。</p>\n<p>也就是说， list 的内容可以包含任意类型的值，包括 procedure。</p>\n<p>注意 <code>&#39;(a b c)</code> 表示含有 symbol <code>a</code> 、 <code>b</code> 和 <code>c</code> 的 list，而不是一个叫 <code>(a b c)</code> 的 symbol。</p>\n<h3 id=\"6-4-Numbers\"><a href=\"#6-4-Numbers\" class=\"headerlink\" title=\"6.4. Numbers\"></a>6.4. Numbers</h3><blockquote>\n<p>Scheme numbers may be classified as integers, rational numbers, real numbers, or complex numbers. This classification is hierarchical, in that all integers are rational, all rational numbers are real, and all real numbers are complex.</p>\n</blockquote>\n<blockquote>\n<p>A Scheme number may also be classified as exact or inexact, depending upon the quality of operations used to derive the number and the inputs to these operations.</p>\n</blockquote>\n<h3 id=\"6-5-Fixnums\"><a href=\"#6-5-Fixnums\" class=\"headerlink\" title=\"6.5. Fixnums\"></a>6.5. Fixnums</h3><p>fixnum 指固定范围内的整数。</p>\n<h3 id=\"6-6-Flonums\"><a href=\"#6-6-Flonums\" class=\"headerlink\" title=\"6.6. Flonums\"></a>6.6. Flonums</h3><h3 id=\"6-7-Characters\"><a href=\"#6-7-Characters\" class=\"headerlink\" title=\"6.7. Characters\"></a>6.7. Characters</h3><h3 id=\"6-8-Strings\"><a href=\"#6-8-Strings\" class=\"headerlink\" title=\"6.8. Strings\"></a>6.8. Strings</h3><h3 id=\"6-9-Vectors\"><a href=\"#6-9-Vectors\" class=\"headerlink\" title=\"6.9. Vectors\"></a>6.9. Vectors</h3><blockquote>\n<p>Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time.</p>\n</blockquote>\n<h3 id=\"6-10-Bytevectors\"><a href=\"#6-10-Bytevectors\" class=\"headerlink\" title=\"6.10. Bytevectors\"></a>6.10. Bytevectors</h3><blockquote>\n<p>Bytevectors are vectors of raw binary data.</p>\n</blockquote>\n<h3 id=\"6-11-Symbols\"><a href=\"#6-11-Symbols\" class=\"headerlink\" title=\"6.11. Symbols\"></a>6.11. Symbols</h3><blockquote>\n<p>The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as identifiers in the representation of programs, allowing fast comparison of identifiers.</p>\n</blockquote>\n<h3 id=\"6-12-Booleans\"><a href=\"#6-12-Booleans\" class=\"headerlink\" title=\"6.12. Booleans\"></a>6.12. Booleans</h3><h3 id=\"6-13-Hashtables\"><a href=\"#6-13-Hashtables\" class=\"headerlink\" title=\"6.13. Hashtables\"></a>6.13. Hashtables</h3><blockquote>\n<p>Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose as association lists but are typically much faster when large numbers of associations are involved.</p>\n</blockquote>\n<h3 id=\"6-14-Enumerations\"><a href=\"#6-14-Enumerations\" class=\"headerlink\" title=\"6.14. Enumerations\"></a>6.14. Enumerations</h3><h2 id=\"7-Input-and-Output\"><a href=\"#7-Input-and-Output\" class=\"headerlink\" title=\"7. Input and Output\"></a>7. Input and Output</h2><blockquote>\n<p>All input and output operations are performed through ports.</p>\n</blockquote>\n<blockquote>\n<p>Ports are first-class objects, like any other object in Scheme.</p>\n</blockquote>\n<h3 id=\"7-1-Transcoders\"><a href=\"#7-1-Transcoders\" class=\"headerlink\" title=\"7.1. Transcoders\"></a>7.1. Transcoders</h3><h3 id=\"7-2-Opening-Files\"><a href=\"#7-2-Opening-Files\" class=\"headerlink\" title=\"7.2. Opening Files\"></a>7.2. Opening Files</h3><blockquote>\n<p>It is perhaps easier to imagine that the default file options are the imaginary option symbols <code>create</code>, <code>fail-if-exists</code>, and <code>truncate</code>; <code>no-create</code> removes <code>create</code>, <code>no-fail</code> removes <code>fail-if-exists</code>, and <code>no-truncate</code> removes <code>truncate</code>.</p>\n</blockquote>\n<h3 id=\"7-3-Standard-Ports\"><a href=\"#7-3-Standard-Ports\" class=\"headerlink\" title=\"7.3. Standard Ports\"></a>7.3. Standard Ports</h3><h3 id=\"7-4-String-and-Bytevector-Ports\"><a href=\"#7-4-String-and-Bytevector-Ports\" class=\"headerlink\" title=\"7.4. String and Bytevector Ports\"></a>7.4. String and Bytevector Ports</h3><h3 id=\"7-5-Opening-Custom-Ports\"><a href=\"#7-5-Opening-Custom-Ports\" class=\"headerlink\" title=\"7.5. Opening Custom Ports\"></a>7.5. Opening Custom Ports</h3><h3 id=\"7-6-Port-Operations\"><a href=\"#7-6-Port-Operations\" class=\"headerlink\" title=\"7.6. Port Operations\"></a>7.6. Port Operations</h3><h3 id=\"7-7-Input-Operations\"><a href=\"#7-7-Input-Operations\" class=\"headerlink\" title=\"7.7. Input Operations\"></a>7.7. Input Operations</h3><h3 id=\"7-8-Output-Operations\"><a href=\"#7-8-Output-Operations\" class=\"headerlink\" title=\"7.8. Output Operations\"></a>7.8. Output Operations</h3><h3 id=\"7-9-Convenience-I-O\"><a href=\"#7-9-Convenience-I-O\" class=\"headerlink\" title=\"7.9. Convenience I/O\"></a>7.9. Convenience I/O</h3><h3 id=\"7-10-Filesystem-Operations\"><a href=\"#7-10-Filesystem-Operations\" class=\"headerlink\" title=\"7.10. Filesystem Operations\"></a>7.10. Filesystem Operations</h3><h3 id=\"7-11-Bytevector-String-Conversions\"><a href=\"#7-11-Bytevector-String-Conversions\" class=\"headerlink\" title=\"7.11. Bytevector/String Conversions\"></a>7.11. Bytevector/String Conversions</h3><h2 id=\"8-Syntactic-Extension\"><a href=\"#8-Syntactic-Extension\" class=\"headerlink\" title=\"8. Syntactic Extension\"></a>8. Syntactic Extension</h2><blockquote>\n<p>Syntactic extensions, or macros, are used to simplify and regularize repeated patterns in a program, to introduce syntactic forms with new evaluation rules, and to perform transformations that help make programs more efficient.</p>\n</blockquote>\n<blockquote>\n<p>Syntactic extensions are expanded into core forms at the start of evaluation (before compilation or interpretation) by a syntax expander.</p>\n</blockquote>\n<h3 id=\"8-1-Keyword-Bindings\"><a href=\"#8-1-Keyword-Bindings\" class=\"headerlink\" title=\"8.1. Keyword Bindings\"></a>8.1. Keyword Bindings</h3><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> keyword expr)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let-syntax</span></span> ((<span class=\"name\">keyword</span> expr) ...) form1 form2 ...)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">letrec-syntax</span></span> ((<span class=\"name\">keyword</span> expr) ...) form1 form2 ...)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-Syntax-Rules-Transformers\"><a href=\"#8-2-Syntax-Rules-Transformers\" class=\"headerlink\" title=\"8.2. Syntax-Rules Transformers\"></a>8.2. Syntax-Rules Transformers</h3><blockquote>\n<p>P is of the form (P1 … Pn) and F is a list of n elements that match P1 through Pn</p>\n</blockquote>\n<p>上面一句话的意思如果模式 P 是 <code>(p1 p2 p3 p4)</code> 这样子的格式的话，则 F 也必须是包含 4 个元素的列表。这里的 <code>...</code> 表示的是确定的指定了 n 个子模式。而不是在模式出现 <code>...</code> 这个标识符。表示模式中出现 <code>...</code> 标识符是通过下面中提到的标识符 <code>ellipsis</code> 来指代的。注意这里容易造成混淆。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\"><span class=\"builtin-name\">if</span></span> <span class=\"literal\">#f</span>])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">t</span> <span class=\"symbol\">&#x27;okay</span>])</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">or</span></span> if t)))</span><br></pre></td></tr></table></figure>\n\n<p>扩展为：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (if1)</span><br><span class=\"line\">   ((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (t1)</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (t2)</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">if</span></span> t2 t2 t1))</span><br><span class=\"line\">       if1))</span><br><span class=\"line\">    <span class=\"symbol\">&#x27;okay</span>))</span><br><span class=\"line\"> <span class=\"literal\">#f</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-Syntax-Case-Transformers\"><a href=\"#8-3-Syntax-Case-Transformers\" class=\"headerlink\" title=\"8.3. Syntax-Case Transformers\"></a>8.3. Syntax-Case Transformers</h3><blockquote>\n<p>With this mechanism (<code>syntax-case</code>), transformers are procedures of one argument. The argument is a syntax object representing the form to be processed. The return value is a syntax object representing the output form. A syntax object may be any of the following.</p>\n</blockquote>\n<blockquote>\n<p><code>#&#39;template</code> is equivalent to <code>(syntax template)</code>. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.</p>\n</blockquote>\n<blockquote>\n<p>Syntactic extensions ordinarily take the form <code>(keyword subform ...)</code>, but the <code>syntax-case</code> system permits them to take the form of singleton identifiers as well.</p>\n</blockquote>\n<p><code>(with-syntax ((pattern expr) ...) body1 body2 ...)</code></p>\n<p>理解：这里理解的重点是 <code>pattern</code>，其实和 <code>syntax-case</code> 中的 <code>pattern</code> 一致。用于解构 <code>expr</code> 的值。且看下面的示例：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> lab</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">syntax-case</span></span> x ()</span><br><span class=\"line\">      [(<span class=\"name\">_</span> e1 e2)</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">with-syntax</span></span> ([(<span class=\"name\">_</span> x1 x2) #<span class=\"symbol\">&#x27;e1</span>]</span><br><span class=\"line\">                     [(<span class=\"name\">_</span> y1 y2) #<span class=\"symbol\">&#x27;e2</span>])</span><br><span class=\"line\">         #&#x27;(+ x1 x2 y1 y2))])))</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>quasisyntax</code> can be used in place of <code>with-syntax</code> in many cases.</p>\n</blockquote>\n<p>值得思考 <code>(datum-&gt;syntax template-identifier obj)</code> 的作用。</p>\n<p>关于本章的语法扩展问题，需要多思考作用域相关的问题。</p>\n<h2 id=\"9-Records\"><a href=\"#9-Records\" class=\"headerlink\" title=\"9. Records\"></a>9. Records</h2><h3 id=\"9-1-Defining-Records\"><a href=\"#9-1-Defining-Records\" class=\"headerlink\" title=\"9.1. Defining Records\"></a>9.1. Defining Records</h3><p>注意每次定义 record type ，即使名字一样，也是不同的。</p>\n<h3 id=\"9-2-Procedural-Interface\"><a href=\"#9-2-Procedural-Interface\" class=\"headerlink\" title=\"9.2. Procedural Interface\"></a>9.2. Procedural Interface</h3><h2 id=\"10-Libraries-and-Top-Level-Programs\"><a href=\"#10-Libraries-and-Top-Level-Programs\" class=\"headerlink\" title=\"10. Libraries and Top-Level Programs\"></a>10. Libraries and Top-Level Programs</h2><p>学习 Scheme 库的建立。</p>\n<h3 id=\"10-1-Standard-Libraries\"><a href=\"#10-1-Standard-Libraries\" class=\"headerlink\" title=\"10.1. Standard Libraries\"></a>10.1. Standard Libraries</h3><h3 id=\"10-2-Defining-New-Libraries\"><a href=\"#10-2-Defining-New-Libraries\" class=\"headerlink\" title=\"10.2. Defining New Libraries\"></a>10.2. Defining New Libraries</h3><h3 id=\"10-3-Top-Level-Programs\"><a href=\"#10-3-Top-Level-Programs\" class=\"headerlink\" title=\"10.3. Top-Level Programs\"></a>10.3. Top-Level Programs</h3><blockquote>\n<p>Top-level programs can be thought of as <code>library</code> forms without the library wrapper, library name, and export form.</p>\n</blockquote>\n<h2 id=\"11-Exceptions-and-Conditions\"><a href=\"#11-Exceptions-and-Conditions\" class=\"headerlink\" title=\"11. Exceptions and Conditions\"></a>11. Exceptions and Conditions</h2><blockquote>\n<p>Exceptions and conditions provide the means for system and user code to signal, detect, and recover from errors that occur when a program is run.</p>\n</blockquote>\n<h3 id=\"11-1-Raising-and-Handling-Exceptions\"><a href=\"#11-1-Raising-and-Handling-Exceptions\" class=\"headerlink\" title=\"11.1. Raising and Handling Exceptions\"></a>11.1. Raising and Handling Exceptions</h3><h3 id=\"11-2-Defining-Condition-Types\"><a href=\"#11-2-Defining-Condition-Types\" class=\"headerlink\" title=\"11.2. Defining Condition Types\"></a>11.2. Defining Condition Types</h3><h3 id=\"11-3-Standard-Condition-Types\"><a href=\"#11-3-Standard-Condition-Types\" class=\"headerlink\" title=\"11.3. Standard Condition Types\"></a>11.3. Standard Condition Types</h3><h2 id=\"12-Extended-Examples\"><a href=\"#12-Extended-Examples\" class=\"headerlink\" title=\"12. Extended Examples\"></a>12. Extended Examples</h2><h3 id=\"12-1-Matrix-and-Vector-Multiplication\"><a href=\"#12-1-Matrix-and-Vector-Multiplication\" class=\"headerlink\" title=\"12.1. Matrix and Vector Multiplication\"></a>12.1. Matrix and Vector Multiplication</h3><h3 id=\"12-2-Sorting\"><a href=\"#12-2-Sorting\" class=\"headerlink\" title=\"12.2. Sorting\"></a>12.2. Sorting</h3><h3 id=\"12-3-A-Set-Constructor\"><a href=\"#12-3-A-Set-Constructor\" class=\"headerlink\" title=\"12.3. A Set Constructor\"></a>12.3. A Set Constructor</h3><h3 id=\"12-4-Word-Frequency-Counting\"><a href=\"#12-4-Word-Frequency-Counting\" class=\"headerlink\" title=\"12.4. Word Frequency Counting\"></a>12.4. Word Frequency Counting</h3><h3 id=\"12-5-Scheme-Printer\"><a href=\"#12-5-Scheme-Printer\" class=\"headerlink\" title=\"12.5. Scheme Printer\"></a>12.5. Scheme Printer</h3><h3 id=\"12-6-Formatted-Output\"><a href=\"#12-6-Formatted-Output\" class=\"headerlink\" title=\"12.6. Formatted Output\"></a>12.6. Formatted Output</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>重点是前三章的内容，值得多读几遍。另外第十二章的示例还差几个没有看完。其余章节都浏览了一遍。之后需要查阅相关的内容时，请在索引页面搜索。</p>\n<h2 id=\"Exercise\"><a href=\"#Exercise\" class=\"headerlink\" title=\"Exercise\"></a>Exercise</h2><p>2.2.1</p>\n<p>a. (+ (* 1.2 (- 2 1/3) -8.7))<br>b. (/ (+ 2/3 4/9) (- 5/11 -4/3))<br>c. (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 1/2)))))<br>d. (* 1 -2 3 -4 5 -6 7)</p>\n<p>2.2.2</p>\n<p>complex numbers<br>real numbers<br>rational numbers<br>integers</p>\n<p>2.2.3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a. (car cdr)</span><br><span class=\"line\">b. (this ((is silly)))</span><br><span class=\"line\">c. (is this silly?)</span><br><span class=\"line\">d. (+ 2 3)</span><br><span class=\"line\">e. (+ 2 3)</span><br><span class=\"line\">f. +</span><br><span class=\"line\">g. (2 3)</span><br><span class=\"line\">h. #&lt;procedure cons&gt;</span><br><span class=\"line\">i. cons</span><br><span class=\"line\">j. (quote cons)</span><br><span class=\"line\">k. quote</span><br><span class=\"line\">l. 5</span><br><span class=\"line\">m. 5</span><br><span class=\"line\">n. 5</span><br><span class=\"line\">o. 5</span><br></pre></td></tr></table></figure>\n\n<p>2.2.4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(car (car &#39;((a b) (c d)))) &#x3D;&gt; a</span><br><span class=\"line\">(car (cdr (car &#39;((a b) (c d))))) &#x3D;&gt; b</span><br><span class=\"line\">(car (car (cdr &#39;((a b) (c d))))) &#x3D;&gt; c</span><br><span class=\"line\">(car (cdr (car (cdr &#39;((a b) (c d)))))) &#x3D;&gt; d</span><br></pre></td></tr></table></figure>\n\n<p>2.2.5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;((a . b) ((c) d) ())</span><br></pre></td></tr></table></figure>\n\n<p>2.2.6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1 (2 (3)) (()) 4 . 5)</span><br></pre></td></tr></table></figure>\n\n<p>2.2.8</p>\n<p>试着解释 Scheme 表达式是如何求值。</p>\n<p>答：先递归求值每个操作数，然后将得到的值应用到操作符上。</p>\n<p>2.3.1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(cdr (list + - * &#x2F;)) &#x3D;&gt; (list - * &#x2F;)</span><br><span class=\"line\">(car (list - * &#x2F;)) &#x3D;&gt; -</span><br><span class=\"line\">(- 17 5) &#x3D;&gt; 12</span><br></pre></td></tr></table></figure>\n\n<p>2.4.1</p>\n<p>a.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">3</span> a)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">y1</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x b)]</span><br><span class=\"line\">        [<span class=\"name\">y2</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x b)])</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> y1 y2)))</span><br></pre></td></tr></table></figure>\n\n<p>b.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> a b c)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)]</span><br><span class=\"line\">        [<span class=\"name\">x2</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls)])</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x1 x2)))</span><br></pre></td></tr></table></figure>\n\n<p>2.4.3</p>\n<p>a.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> <span class=\"symbol\">&#x27;a</span>] [<span class=\"name\">y1</span> <span class=\"symbol\">&#x27;b</span>])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x2</span> <span class=\"symbol\">&#x27;c</span>]) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x2 y1))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">y2</span> <span class=\"symbol\">&#x27;d</span>]) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x1 y2))))</span><br></pre></td></tr></table></figure>\n\n<p>b.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> &#x27;((a b) c)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x2</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x1)])</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x2))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x3</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x1)])</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x4</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x3)])</span><br><span class=\"line\">                  (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x4))</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x5</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x3)])</span><br><span class=\"line\">                        x5)</span><br><span class=\"line\">                      (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x3))))))</span><br></pre></td></tr></table></figure>\n\n<p>2.5.1</p>\n<p>a. ‘a<br>b. ‘(a)<br>c. ‘a<br>d. ‘()</p>\n<p>2.5.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> <span class=\"name\">ls</span> <span class=\"name\">ls</span>))</span><br></pre></td></tr></table></figure>\n\n<p>2.5.3</p>\n<p>a. empty<br>b. +<br>c. f<br>d. f, y<br>e. y</p>\n<p>2.6.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> compose</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (p1 p2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">      (<span class=\"name\">p1</span> (<span class=\"name\">p2</span> x)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadr (<span class=\"name\">compose</span> car cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddr (<span class=\"name\">compose</span> cdr cdr))</span><br></pre></td></tr></table></figure>\n\n<p>2.6.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caar (<span class=\"name\">compose</span> car car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdar (<span class=\"name\">compose</span> cdr car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaar (<span class=\"name\">compose</span> caar car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caadr (<span class=\"name\">compose</span> caar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadar (<span class=\"name\">compose</span> cadr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaar (<span class=\"name\">compose</span> cdar car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdddr (<span class=\"name\">compose</span> cddr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddar (<span class=\"name\">compose</span> cddr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdadr (<span class=\"name\">compose</span> cdar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caddr (<span class=\"name\">compose</span> cadr cdr))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaaar (<span class=\"name\">compose</span> caaar car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaadr (<span class=\"name\">compose</span> caaar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caadar (<span class=\"name\">compose</span> caadr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadaar (<span class=\"name\">compose</span> cadar car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaaar (<span class=\"name\">compose</span> cdaar car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaddr (<span class=\"name\">compose</span> caadr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadadr (<span class=\"name\">compose</span> cadar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaadr (<span class=\"name\">compose</span> cdaar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caddar (<span class=\"name\">compose</span> caddr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdadar (<span class=\"name\">compose</span> cdadr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddaar (<span class=\"name\">compose</span> cddar car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddddr (<span class=\"name\">compose</span> cdddr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdddar (<span class=\"name\">compose</span> cdddr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddadr (<span class=\"name\">compose</span> cddar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaddr (<span class=\"name\">compose</span> cdadr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadddr (<span class=\"name\">compose</span> caddr cdr))</span><br></pre></td></tr></table></figure>\n\n<p>2.7.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> atom?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x))))</span><br></pre></td></tr></table></figure>\n\n<p>2.7.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> shorter</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls1 ls2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> ls2) (<span class=\"name\"><span class=\"builtin-name\">length</span></span> ls1))</span><br><span class=\"line\">        ls2</span><br><span class=\"line\">        ls1)))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.1</p>\n<p>交换 cons 的参数顺序将会导致复制的 tree 的每一个节点的子节点被调换。</p>\n<p>2.8.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-list</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n obj)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#x27;()</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> obj (<span class=\"name\">make-list</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>) obj)))))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-ref</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls idx)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> idx <span class=\"number\">1</span>)))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-tail</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls idx)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">        ls</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> idx <span class=\"number\">1</span>)))))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.5</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> shorter?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls1 ls2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls1) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls2) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">shorter?</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls1) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls2))])))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> shorter</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls1 ls2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">shorter?</span> ls1 ls2)</span><br><span class=\"line\">        ls1</span><br><span class=\"line\">        ls2)))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.6</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> odd?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"literal\">#f</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">even?</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>)))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> even?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"literal\">#t</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">odd?</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>)))))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.7</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> transpose</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">left</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> car ls)]</span><br><span class=\"line\">          [<span class=\"name\">right</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> cdr ls)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> left right))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-counter</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (init step)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">init</span> init])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> init (<span class=\"name\"><span class=\"builtin-name\">+</span></span> init step))</span><br><span class=\"line\">        init))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-stack</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> &#x27;()])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (msg . args)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">case</span></span> msg</span><br><span class=\"line\">          [(<span class=\"name\">empty?</span>) (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">push!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args) ls))]</span><br><span class=\"line\">          [(<span class=\"name\">top</span>) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">pop!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"string\">&quot;oops&quot;</span>])))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-stack</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> &#x27;()])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (msg . args)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">case</span></span> msg</span><br><span class=\"line\">          [(<span class=\"name\">empty?</span>) (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">push!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args) ls))]</span><br><span class=\"line\">          [(<span class=\"name\">top</span>) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">pop!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls))]</span><br><span class=\"line\">          [(<span class=\"name\">ref</span>) (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">set!</span></span>) (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> (<span class=\"name\"><span class=\"builtin-name\">list-tail</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))</span><br><span class=\"line\">                            (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"string\">&quot;oops&quot;</span>])))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-stack</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\"><span class=\"builtin-name\">vector</span></span> (<span class=\"name\"><span class=\"builtin-name\">make-vector</span></span> n)]</span><br><span class=\"line\">          [<span class=\"name\">at</span> <span class=\"number\">0</span>])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (msg . args)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">case</span></span> msg</span><br><span class=\"line\">          [(<span class=\"name\">empty?</span>) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> at <span class=\"number\">0</span>)]</span><br><span class=\"line\">          [(<span class=\"name\">push!</span>) (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">                     (<span class=\"name\"><span class=\"builtin-name\">vector-set!</span></span> vector at (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))</span><br><span class=\"line\">                     (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> at (<span class=\"name\"><span class=\"builtin-name\">+</span></span> at <span class=\"number\">1</span>)))]</span><br><span class=\"line\">          [(<span class=\"name\">top</span>) (<span class=\"name\"><span class=\"builtin-name\">vector-ref</span></span> vector (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span>))]</span><br><span class=\"line\">          [(<span class=\"name\">pop!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> at (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span>))]</span><br><span class=\"line\">          [(<span class=\"name\">ref</span>)</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">idx</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))])</span><br><span class=\"line\">             (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">                 (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;make-stack</span> <span class=\"string\">&quot;out of range.&quot;</span> idx)</span><br><span class=\"line\">                 (<span class=\"name\"><span class=\"builtin-name\">vector-ref</span></span> vector idx)))]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">set!</span></span>)</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">idx</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))])</span><br><span class=\"line\">             (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">                 (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;make-stack</span> <span class=\"string\">&quot;out of range.&quot;</span> idx)</span><br><span class=\"line\">                 (<span class=\"name\"><span class=\"builtin-name\">vector-set!</span></span> vector idx (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args))))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"string\">&quot;oops&quot;</span>])))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.5</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-queue</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">end</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"symbol\">&#x27;ignored</span> &#x27;())])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> end end))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> emptyq?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> putq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q v)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">end</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"symbol\">&#x27;ignored</span> &#x27;())])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q) v)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q) end)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q end))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> getq</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">        (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;getq</span> <span class=\"string\">&quot;queue is empty&quot;</span> q)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">car</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> delq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">        (<span class=\"name\">assertion-violation</span> delq <span class=\"string\">&quot;queue is empty&quot;</span> q)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q))))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.6</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-queue</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">end</span> &#x27;()])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> end end))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> emptyq?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q))</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> putq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q v)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">tail</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> tail)</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">body</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> v &#x27;())])</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q body)</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q body))</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> tail (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> v &#x27;()))</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> tail)))))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> getq</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">        (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;getq</span> <span class=\"string\">&quot;queue is empty&quot;</span> q)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">car</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> delq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">       (<span class=\"name\">assertion-violation</span> delq <span class=\"string\">&quot;queue is empty&quot;</span> q)]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q))</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">empty</span> &#x27;()])</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q empty)</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q empty))]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span></span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q)))])))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.8</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> x) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x)</span><br><span class=\"line\">            (<span class=\"name\">have-cyclic?</span> x x)) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x) (<span class=\"name\">list-help</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x))]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"literal\">#f</span>])))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-help</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> x) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x) (<span class=\"name\">list-help</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x))]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"literal\">#f</span>])))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> have-cyclic?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (hare tortoise)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> hare))) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> (<span class=\"name\">cddr</span> hare))) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\">cddr</span> hare) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> tortoise)) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">have-cyclic?</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> hare)) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> tortoise))])))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x</span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;a</span> ls)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">and</span></span> x (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;b</span> x)))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">   (<span class=\"name\"><span class=\"builtin-name\">if</span></span> x (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;b</span> x)) <span class=\"literal\">#f</span>))</span><br><span class=\"line\"> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;a</span> ls))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">   (<span class=\"name\"><span class=\"builtin-name\">if</span></span> x (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;b</span> x) <span class=\"literal\">#f</span>))</span><br><span class=\"line\"> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;a</span> ls))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c)) (<span class=\"name\"><span class=\"builtin-name\">list</span></span> x))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> x)))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">list</span></span> x))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> let*</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> () b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> () b1 b2 ...)]</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ([<span class=\"name\">x</span> e]) b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x</span> e]) b1 b2 ...)]</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ([<span class=\"name\">x1</span> e1] [<span class=\"name\">x2</span> e2] ...) b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> e1])</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">let*</span></span> ([<span class=\"name\">x2</span> e2] ...) b1 b2 ...))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> when <span class=\"comment\">;; 如果对</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> test e1 e2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">if</span></span> test</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> e1 e2 ...)</span><br><span class=\"line\">         <span class=\"literal\">#f</span>)]))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> unless <span class=\"comment\">;; 如果不对</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> test e1 e2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">when</span></span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> test) e1 e2 ...)]))</span><br></pre></td></tr></table></figure>\n\n<p>3.2.2</p>\n<p>the named <code>let</code>, beacuse it’s more simple.</p>\n<p>3.2.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> xxx ([<span class=\"name\">t</span> <span class=\"symbol\">&#x27;even?</span>] [<span class=\"name\">x</span> <span class=\"number\">20</span>])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> t <span class=\"symbol\">&#x27;even?</span>)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">         (<span class=\"name\">xxx</span> <span class=\"symbol\">&#x27;odd?</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>)))]</span><br><span class=\"line\">    [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> t <span class=\"symbol\">&#x27;odd?</span>)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>))</span><br><span class=\"line\">          (<span class=\"name\">xxx</span> <span class=\"symbol\">&#x27;even?</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>)))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.2.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">fibonacci</span> <span class=\"number\">40</span>)</span><br></pre></td></tr></table></figure>\n\n<p>1: 331160280次<br>2: 39次</p>\n<p>3.2.5</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; use set!</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> let</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ((<span class=\"name\">x</span> e) ...) b1 b2 ...)</span><br><span class=\"line\">     ((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x ...) b1 b2 ...) e ...)]</span><br><span class=\"line\">    [(<span class=\"name\">_</span> name ((<span class=\"name\">x</span> e) ...) b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">name</span> <span class=\"literal\">#f</span>])</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> name (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x ...) b1 b2 ...))</span><br><span class=\"line\">       (<span class=\"name\">name</span> e ...))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.2.6</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> even? <span class=\"comment\">; incorrect!</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">a</span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> a</span><br><span class=\"line\">          a</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">b</span> (<span class=\"name\"><span class=\"builtin-name\">odd?</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>))])</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">if</span></span> b b <span class=\"literal\">#f</span>))))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> even? <span class=\"comment\">; correct!</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">a</span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> a</span><br><span class=\"line\">          a</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">odd?</span></span> (<span class=\"name\">-x</span> <span class=\"number\">1</span>))))))</span><br></pre></td></tr></table></figure>\n\n<p>注意它们的区别：每次调用 <code>even?</code> 就多了一层 <code>let</code> 和 <code>if</code></p>\n<p>3.2.7</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> factor</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> f ([<span class=\"name\">n</span> n] [<span class=\"name\">i</span> <span class=\"number\">3</span>])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">let-values</span></span> ([(<span class=\"name\">s</span> r) (<span class=\"name\">exact-integer-sqrt</span> n)])</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> i s) (<span class=\"name\"><span class=\"builtin-name\">list</span></span> n)]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">integer?</span></span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n <span class=\"number\">2</span>))</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">2</span> (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n <span class=\"number\">2</span>) i))]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">integer?</span></span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n i))</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> i (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n i) i))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">f</span> n (<span class=\"name\"><span class=\"builtin-name\">+</span></span> i <span class=\"number\">1</span>))])))))</span><br></pre></td></tr></table></figure>\n\n<p>First is the most important problem to solve.</p>\n<p>3.3.1</p>\n<p>3.3.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> product</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> f ([<span class=\"name\">ls</span> ls] [<span class=\"name\">c</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> () <span class=\"number\">1</span>)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls) (<span class=\"name\">c</span>)]</span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) <span class=\"number\">0</span>) <span class=\"number\">0</span>]</span><br><span class=\"line\">        [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">                            (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) (<span class=\"name\">c</span>))))]))))</span><br></pre></td></tr></table></figure>\n\n<p>通过回调的形式返回。</p>\n<p>3.3.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> exit (<span class=\"name\"><span class=\"builtin-name\">call/cc</span></span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (k) k)))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> quit</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> lwp-list)</span><br><span class=\"line\">        (<span class=\"name\">exit</span> <span class=\"literal\">#f</span>)</span><br><span class=\"line\">        (<span class=\"name\">start</span>))))</span><br></pre></td></tr></table></figure>\n\n<p>关键是定义一个退出的 continuation。</p>\n<p>3.3.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> lwp-list (<span class=\"name\">make-queue</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> lwp</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (thunk)</span><br><span class=\"line\">    (<span class=\"name\">putq!</span> lwp-list thunk)))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> start</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">p</span> (<span class=\"name\">getq</span> lwp-list)])</span><br><span class=\"line\">      (<span class=\"name\">delq!</span> lwp-list)</span><br><span class=\"line\">      (<span class=\"name\">p</span>))))</span><br></pre></td></tr></table></figure>\n\n<p>3.3.5</p>\n<p>3.4.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> reciprocal</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n success failure)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\">failure</span>)</span><br><span class=\"line\">        (<span class=\"name\">success</span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> <span class=\"number\">1</span> n)))))</span><br></pre></td></tr></table></figure>\n\n<p>3.4.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> retry <span class=\"literal\">#f</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> factorial</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x k)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> retry k)</span><br><span class=\"line\">          (<span class=\"name\">k</span> <span class=\"number\">1</span>))</span><br><span class=\"line\">        (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">                   (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">                     (<span class=\"name\">k</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> n x)))))))</span><br></pre></td></tr></table></figure>\n\n<p>3.4.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> reciprocals</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls success failure)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> map1 [(<span class=\"name\">ls</span> ls) (<span class=\"name\">ls2</span> &#x27;())]</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls)</span><br><span class=\"line\">         (<span class=\"name\">success</span> (<span class=\"name\"><span class=\"builtin-name\">reverse</span></span> ls2))]</span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) <span class=\"number\">0</span>)</span><br><span class=\"line\">         (<span class=\"name\">failure</span> <span class=\"string\">&quot;zero found&quot;</span>)]</span><br><span class=\"line\">        [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">map1</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) ls2))]))))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> complain</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ek msg expr)</span><br><span class=\"line\">     (<span class=\"name\">ek</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> msg expr))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> calc</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (expr)</span><br><span class=\"line\">    <span class=\"comment\">; grab an error continuation ek</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">call/cc</span></span></span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek)</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">define</span></span> do-calc</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek expr)</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">             [(<span class=\"name\"><span class=\"builtin-name\">number?</span></span> expr) expr]</span><br><span class=\"line\">             [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">list?</span></span> expr) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> expr) <span class=\"number\">3</span>))</span><br><span class=\"line\">              (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">op</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> expr)] [<span class=\"name\">args</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> expr)])</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">case</span></span> op</span><br><span class=\"line\">                  [(<span class=\"name\">add</span>) (<span class=\"name\">apply-op</span> ek + args)]</span><br><span class=\"line\">                  [(<span class=\"name\">sub</span>) (<span class=\"name\">apply-op</span> ek - args)]</span><br><span class=\"line\">                  [(<span class=\"name\">mul</span>) (<span class=\"name\">apply-op</span> ek * args)]</span><br><span class=\"line\">                  [(<span class=\"name\">div</span>) (<span class=\"name\">apply-op</span> ek / args)]</span><br><span class=\"line\">                  [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">complain</span> ek <span class=\"string\">&quot;invalid operator&quot;</span> op)]))]</span><br><span class=\"line\">             [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">complain</span> ek <span class=\"string\">&quot;invalid expression&quot;</span> expr)])))</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">define</span></span> apply-op</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek op args)</span><br><span class=\"line\">           (<span class=\"name\">op</span> (<span class=\"name\">do-calc</span> ek (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args)) (<span class=\"name\">do-calc</span> ek (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args)))))</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">define</span></span> complain</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek msg expr)</span><br><span class=\"line\">           (<span class=\"name\">ek</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> msg expr))))</span><br><span class=\"line\">       (<span class=\"name\">do-calc</span> ek expr)))))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> calc <span class=\"literal\">#f</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ()</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> do-calc</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (expr)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">number?</span></span> expr) expr]</span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">list?</span></span> expr) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> expr) <span class=\"number\">3</span>))</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">op</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> expr)] [<span class=\"name\">args</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> expr)])</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">case</span></span> op</span><br><span class=\"line\">             [(<span class=\"name\">add</span>) (<span class=\"name\">apply-op</span> + args)]</span><br><span class=\"line\">             [(<span class=\"name\">sub</span>) (<span class=\"name\">apply-op</span> - args)]</span><br><span class=\"line\">             [(<span class=\"name\">mul</span>) (<span class=\"name\">apply-op</span> * args)]</span><br><span class=\"line\">             [(<span class=\"name\">div</span>) (<span class=\"name\">apply-op</span> / args)]</span><br><span class=\"line\">             [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;do-calc</span> <span class=\"string\">&quot;invalid operator&quot;</span> op)]))]</span><br><span class=\"line\">        [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;do-calc</span> <span class=\"string\">&quot;invalid expression&quot;</span> expr)])))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> apply-op</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (op args)</span><br><span class=\"line\">      (<span class=\"name\">op</span> (<span class=\"name\">do-calc</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args)) (<span class=\"name\">do-calc</span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args)))))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> calc do-calc))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.4</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">       [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">list?</span></span> expr) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> expr) <span class=\"number\">2</span>))</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">op</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> expr)] [<span class=\"name\">arg</span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> expr)])</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">case</span></span> op</span><br><span class=\"line\">             [(<span class=\"name\">minus</span>) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\">do-calc</span> arg))]))]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>3.6.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> gpa</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> g1 g2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> letter-&gt;number</span><br><span class=\"line\">                    (<span class=\"name\">filter</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g) (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> g <span class=\"symbol\">&#x27;x</span>)))</span><br><span class=\"line\">                          &#x27;(g1 g2 ...)))])</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">/</span></span> (<span class=\"name\"><span class=\"builtin-name\">apply</span></span> + ls) (<span class=\"name\"><span class=\"builtin-name\">length</span></span> ls)))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.6.2</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  define count</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g0 ls)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">length</span></span> (<span class=\"name\">filter</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g) (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> g g0))</span><br><span class=\"line\">                      ls))))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> gs &#x27;(a b c d f))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> distribution</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">      [(<span class=\"name\">_</span> g1 g2 ...)</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> &#x27;(g1 g2 ...)])</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">map</span></span> list (<span class=\"name\"><span class=\"builtin-name\">map</span></span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g0) (<span class=\"name\">count</span> g0 ls))</span><br><span class=\"line\">                        gs)</span><br><span class=\"line\">              gs))]))</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>3.6.3</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> print-one</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (gn)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">string-append</span></span></span><br><span class=\"line\">       <span class=\"string\">&quot;  &quot;</span></span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">symbol-&gt;string</span></span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> gn))</span><br><span class=\"line\">       <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">make-string</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> gn) <span class=\"literal\">#\\*</span>)</span><br><span class=\"line\">       <span class=\"string\">&quot;\\n&quot;</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> print</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (dist)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> dist)</span><br><span class=\"line\">          <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">string-append</span></span> (<span class=\"name\">print-one</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> dist))</span><br><span class=\"line\">                         (<span class=\"name\">print</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> dist))))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> histogram</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (port dist)</span><br><span class=\"line\">      (<span class=\"name\">put-string</span> port <span class=\"string\">&quot;prints:\\n&quot;</span>)</span><br><span class=\"line\">      (<span class=\"name\">put-string</span> port</span><br><span class=\"line\">                  (<span class=\"name\">print</span> dist))))</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>12.2.1</p>\n<p>使用 <code>(list (car ls))</code> 的原因是因为虽然此时 <code>n</code> 是 1，但是 <code>ls</code> 可能含有超过不只一个元素。如果直接返回 <code>ls</code>，就会导致结果不正确。</p>\n<p>如果替换成 <code>(if (null? (cdr ls)) ls (list (car ls)))</code>，可以省去 <code>ls</code> 的初始长度那么多的空间。</p>\n<p>12.2.2</p>\n<p>假设有 <code>n</code> 个数字排列，则可以省略 <code>n</code> 个空间。</p>\n","site":{"data":{}},"more":"<h2 id=\"Preface\"><a href=\"#Preface\" class=\"headerlink\" title=\"Preface\"></a>Preface</h2><p>Scheme 由 Gerald J. Sussman 和 Guy L. Steele Jr. 发明，支持 lexical scoping、first-class procedures 和 continuations。</p>\n<p>本书的目标是提供关于 Scheme 编程语言（R6RS 标准）的介绍。</p>\n<h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h2><blockquote>\n<p>Scheme is a call-by-value language, but for at least mutable (objects that can be modified), the values are pointers to the actual storage.</p>\n</blockquote>\n<blockquote>\n<p>At the heart of the Scheme language is a small core of syntactic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language.</p>\n</blockquote>\n<blockquote>\n<p>To support lexical scoping, a procedure carries the lexical context (environment) along with its code.</p>\n</blockquote>\n<h3 id=\"1-1-Scheme-Syntax\"><a href=\"#1-1-Scheme-Syntax\" class=\"headerlink\" title=\"1.1. Scheme Syntax\"></a>1.1. Scheme Syntax</h3><blockquote>\n<p>Scheme programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.</p>\n</blockquote>\n<blockquote>\n<p>Keywords, variables, and symbols are collectively called identifiers. Identifiers may be formed from letters, digits, and certain special characters, including ?, !, ., +, -, *, /, &lt;, =, &gt;, :, $, %, ^, &amp;, _, ~, and @, as well as a set of additional Unicode characters.</p>\n</blockquote>\n<blockquote>\n<p>A good rule is to use short identifiers when the scope of the identifier is small and longer identifiers when the scope is larger.</p>\n</blockquote>\n<blockquote>\n<p>Structured forms and list constants are enclosed within parentheses, e.g., (a b c) or (* (- x 2) y).</p>\n</blockquote>\n<blockquote>\n<p>Strings are enclosed in double quotation marks, e.g., “I am a string”. Characters are preceded by #, e.g., #\\a.</p>\n</blockquote>\n<p>comments: <code>; single line</code>, <code>#| block |#</code>, <code>#;(datum commnet)</code></p>\n<h3 id=\"1-2-Scheme-Naming-Conventions\"><a href=\"#1-2-Scheme-Naming-Conventions\" class=\"headerlink\" title=\"1.2. Scheme Naming Conventions\"></a>1.2. Scheme Naming Conventions</h3><h3 id=\"1-3-Typographical-and-Notational-Conventions\"><a href=\"#1-3-Typographical-and-Notational-Conventions\" class=\"headerlink\" title=\"1.3. Typographical and Notational Conventions\"></a>1.3. Typographical and Notational Conventions</h3><h2 id=\"2-Getting-Started\"><a href=\"#2-Getting-Started\" class=\"headerlink\" title=\"2. Getting Started\"></a>2. Getting Started</h2><h3 id=\"2-1-Interacting-with-Scheme\"><a href=\"#2-1-Interacting-with-Scheme\" class=\"headerlink\" title=\"2.1. Interacting with Scheme\"></a>2.1. Interacting with Scheme</h3><h3 id=\"2-2-Simple-Expressions\"><a href=\"#2-2-Simple-Expressions\" class=\"headerlink\" title=\"2.2. Simple Expressions\"></a>2.2. Simple Expressions</h3><blockquote>\n<p>The <code>quote</code> (<code>&#39;</code>) forces the list to be treated as data.</p>\n</blockquote>\n<blockquote>\n<p>Symbols and variables in Scheme are similar to symbols and variables in mathematical expressions and equations. When we evaluate the mathematical expression 1 - <em>x</em> for some value of <em>x</em>, we think of <em>x</em> as a variable. On the other hand, when we consider the algebraic equation <em>x_^2 - 1 = (_x</em> - 1)(<em>x</em> + 1), we think of <em>x</em> as a symbol (in fact, we think of the whole equation symbolically). Just as quoting a list tells Scheme to treat a parenthesized form as a list rather than as a procedure application, <strong>quoting an identifier tells Scheme to treat the identifier as a symbol rather than as a variable</strong>.</p>\n</blockquote>\n<blockquote>\n<p>Numbers and strings may be quoted, too. Numbers and strings are treated as constants in any case, however, so quoting them is unnecessary.</p>\n</blockquote>\n<h3 id=\"2-3-Evaluating-Scheme-Expressions\"><a href=\"#2-3-Evaluating-Scheme-Expressions\" class=\"headerlink\" title=\"2.3. Evaluating Scheme Expressions\"></a>2.3. Evaluating Scheme Expressions</h3><blockquote>\n<p>Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms provided by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme programmer; these are referred to as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms.</p>\n</blockquote>\n<h3 id=\"2-4-Variables-and-Let-Expressions\"><a href=\"#2-4-Variables-and-Let-Expressions\" class=\"headerlink\" title=\"2.4. Variables and Let Expressions\"></a>2.4. Variables and Let Expressions</h3><p>每一个 variable 都有它的 scope，同名的 variable，更里面的 variable 会 shadow 外层的 variable。这种 scope 叫做 lexical scoping。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ((<span class=\"name\">var</span> expr) ...) body1 body2 ...)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-Lambda-Expressions\"><a href=\"#2-5-Lambda-Expressions\" class=\"headerlink\" title=\"2.5. Lambda Expressions\"></a>2.5. Lambda Expressions</h3><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (var ...) body1 body2 ...)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> <span class=\"name\">var</span> <span class=\"name\">body1</span> <span class=\"name\">body2</span> <span class=\"name\"><span class=\"builtin-name\">...</span></span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (var ... var . var) body1 body2 ...)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-6-Top-Level-Definitions\"><a href=\"#2-6-Top-Level-Definitions\" class=\"headerlink\" title=\"2.6. Top-Level Definitions\"></a>2.6. Top-Level Definitions</h3><h3 id=\"2-7-Conditional-Expressions\"><a href=\"#2-7-Conditional-Expressions\" class=\"headerlink\" title=\"2.7. Conditional Expressions\"></a>2.7. Conditional Expressions</h3><blockquote>\n<p>A predicate is a procedure that answers a specific question about its arguments and returns one of the two values #t or #f.</p>\n</blockquote>\n<h3 id=\"2-8-Simple-Recursion\"><a href=\"#2-8-Simple-Recursion\" class=\"headerlink\" title=\"2.8. Simple Recursion\"></a>2.8. Simple Recursion</h3><blockquote>\n<p>Recursion is a simple concept: the application of a procedure from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive power far beyond ordinary looping constructs.</p>\n</blockquote>\n<p><strong>mapping</strong>: 映射</p>\n<h3 id=\"2-9-Assignment\"><a href=\"#2-9-Assignment\" class=\"headerlink\" title=\"2.9. Assignment\"></a>2.9. Assignment</h3><blockquote>\n<p>Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings. Assignments are performed with set!.</p>\n</blockquote>\n<h2 id=\"3-Going-Further\"><a href=\"#3-Going-Further\" class=\"headerlink\" title=\"3. Going Further\"></a>3. Going Further</h2><h3 id=\"3-1-Syntactic-Extension\"><a href=\"#3-1-Syntactic-Extension\" class=\"headerlink\" title=\"3.1. Syntactic Extension\"></a>3.1. Syntactic Extension</h3><blockquote>\n<p>The core syntactic forms include top-level <code>define</code> forms, constants, variables, procedure applications, <code>quote</code> expressions, <code>lambda</code> expressions, <code>if</code> expressions, and <code>set!</code> expressions.</p>\n</blockquote>\n<p>core grammar:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;program&gt; -&gt; &lt;form&gt;*</span><br><span class=\"line\">&lt;form&gt; -&gt; &lt;definition&gt; | &lt;expression&gt;</span><br><span class=\"line\">&lt;definition&gt; -&gt; &lt;variable definition&gt; | (begin &lt;definition&gt;*)</span><br><span class=\"line\">&lt;variable definition&gt; -&gt; (define &lt;variable&gt; &lt;expression&gt;)</span><br><span class=\"line\">&lt;expression&gt; -&gt; &lt;constant&gt;</span><br><span class=\"line\">             |  &lt;variable&gt;</span><br><span class=\"line\">             |  (quote &lt;datum&gt;)</span><br><span class=\"line\">             |  (lambda &lt;formals&gt; &lt;expression&gt; &lt;expression&gt;*)</span><br><span class=\"line\">             |  (if &lt;expression&gt; &lt;expression&gt; &lt;expression&gt;)</span><br><span class=\"line\">             |  (set! &lt;variable&gt; &lt;expression&gt;)</span><br><span class=\"line\">             |  &lt;application&gt;</span><br><span class=\"line\">&lt;constant&gt; -&gt; &lt;boolean&gt; | &lt;number&gt; | &lt;character&gt; | &lt;string&gt;</span><br><span class=\"line\">&lt;formals&gt; -&gt; &lt;variable&gt;</span><br><span class=\"line\">          |  (&lt;variable&gt;*)</span><br><span class=\"line\">          |  (&lt;variable&gt; &lt;variable&gt;* . &lt;variable&gt;)</span><br><span class=\"line\">&lt;application&gt; -&gt; (&lt;expression&gt; &lt;expression&gt;*)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;variable&gt; is any Scheme identifier</span><br><span class=\"line\">&lt;datum&gt; is any Scheme object, such as a number, list, symbol, or vector</span><br><span class=\"line\">&lt;boolean&gt; is either #t or #f</span><br><span class=\"line\">&lt;number&gt; is any number</span><br><span class=\"line\">&lt;character&gt; is any character</span><br><span class=\"line\">&lt;string&gt; is any string</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-More-Recursion\"><a href=\"#3-2-More-Recursion\" class=\"headerlink\" title=\"3.2. More Recursion\"></a>3.2. More Recursion</h3><blockquote>\n<p>In a <code>letrec</code> expression, <code>expr ...</code> are most often <code>lambda</code> expressions, though this need not be the case. One restriction on the expressions must be obeyed, however. It must be possible to evaluate each <code>expr</code> without evaluating any of the variables <code>var ...</code>.</p>\n</blockquote>\n<h3 id=\"3-3-Continuations\"><a href=\"#3-3-Continuations\" class=\"headerlink\" title=\"3.3. Continuations\"></a>3.3. Continuations</h3><blockquote>\n<p>During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. We call “what to do with the value” the continuation of a computation.</p>\n</blockquote>\n<p>对 continuation 的记录，意味着下次使用该 continuation 时会回到之前计算的某个点，再往下走。也就是说可以回到过去。</p>\n<h3 id=\"3-4-Continuation-Passing-Style\"><a href=\"#3-4-Continuation-Passing-Style\" class=\"headerlink\" title=\"3.4. Continuation Passing Style\"></a>3.4. Continuation Passing Style</h3><p>使函数调用的隐式 continuation 通过 CPS 转换变为显式。</p>\n<p>使用场景：</p>\n<ol>\n<li>是函数调用可以返回多个值</li>\n<li>可以传入多个 continuation</li>\n</ol>\n<h3 id=\"3-5-Internal-Definitions\"><a href=\"#3-5-Internal-Definitions\" class=\"headerlink\" title=\"3.5. Internal Definitions\"></a>3.5. Internal Definitions</h3><blockquote>\n<p>Definitions may also appear at the front of a lambda, let, or letrec body, in which case the bindings they create are local to the body.</p>\n</blockquote>\n<h3 id=\"3-6-Libraries\"><a href=\"#3-6-Libraries\" class=\"headerlink\" title=\"3.6. Libraries\"></a>3.6. Libraries</h3><p>用于模块化，只暴露必要的内容给使用者。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">library</span> (<span class=\"name\">lib-name</span>)</span><br><span class=\"line\">  (<span class=\"name\">export</span> x1 x2 ...)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">import</span></span> (<span class=\"name\">rnrs</span>))</span><br><span class=\"line\">  ...)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-Procedures-and-Variable-Bindings\"><a href=\"#4-Procedures-and-Variable-Bindings\" class=\"headerlink\" title=\"4. Procedures and Variable Bindings\"></a>4. Procedures and Variable Bindings</h2><h3 id=\"4-1-Variable-References\"><a href=\"#4-1-Variable-References\" class=\"headerlink\" title=\"4.1. Variable References\"></a>4.1. Variable References</h3><blockquote>\n<p>Since the scope of the definitions in a <code>library</code>, top-level program, <code>lambda</code>, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed.</p>\n</blockquote>\n<h3 id=\"4-2-Lambda\"><a href=\"#4-2-Lambda\" class=\"headerlink\" title=\"4.2. Lambda\"></a>4.2. Lambda</h3><p><code>(lambda formals body1 body2 ...)</code></p>\n<h3 id=\"4-3-Case-Lambda\"><a href=\"#4-3-Case-Lambda\" class=\"headerlink\" title=\"4.3. Case-Lambda\"></a>4.3. Case-Lambda</h3><blockquote>\n<p>The <code>case-lambda</code> syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments.</p>\n</blockquote>\n<p><code>(case-lambda clause ...)</code></p>\n<p><code>clause</code>:<br><code>[formals body1 body2 ...]</code></p>\n<h3 id=\"4-4-Local-Binding\"><a href=\"#4-4-Local-Binding\" class=\"headerlink\" title=\"4.4. Local Binding\"></a>4.4. Local Binding</h3><p><code>let</code>, <code>let*</code>, <code>letrec</code>, <code>letrec*</code></p>\n<h3 id=\"4-5-Multiple-Values\"><a href=\"#4-5-Multiple-Values\" class=\"headerlink\" title=\"4.5. Multiple Values\"></a>4.5. Multiple Values</h3><p><code>let-values</code>, <code>let*-values</code></p>\n<h3 id=\"4-6-Variable-Definitions\"><a href=\"#4-6-Variable-Definitions\" class=\"headerlink\" title=\"4.6. Variable Definitions\"></a>4.6. Variable Definitions</h3><p><code>define</code></p>\n<blockquote>\n<p>A set of definitions may be grouped by enclosing them in a <code>begin</code> form. Definitions grouped in this manner may appear wherever ordinary variable and syntax definitions may appear. They are treated as if written separately, i.e., without the enclosing <code>begin</code> form.</p>\n</blockquote>\n<h3 id=\"4-7-Assignment\"><a href=\"#4-7-Assignment\" class=\"headerlink\" title=\"4.7. Assignment\"></a>4.7. Assignment</h3><p><code>set!</code></p>\n<h2 id=\"5-Control-Operations\"><a href=\"#5-Control-Operations\" class=\"headerlink\" title=\"5. Control Operations\"></a>5. Control Operations</h2><h3 id=\"5-1-Procedure-Application\"><a href=\"#5-1-Procedure-Application\" class=\"headerlink\" title=\"5.1. Procedure Application\"></a>5.1. Procedure Application</h3><blockquote>\n<p>Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application.</p>\n</blockquote>\n<p><code>(apply procedure obj ... list)</code></p>\n<blockquote>\n<p><code>apply</code> is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.</p>\n</blockquote>\n<h3 id=\"5-2-Sequencing\"><a href=\"#5-2-Sequencing\" class=\"headerlink\" title=\"5.2. Sequencing\"></a>5.2. Sequencing</h3><p><code>(begin expr1 expr2 ...)</code></p>\n<blockquote>\n<p>The bodies of many syntactic forms, including <code>lambda</code>, <code>case-lambda</code>, <code>let</code>, <code>let*</code>, <code>letrec</code>, and <code>letrec*</code>, as well as the result clauses of <code>cond</code>, <code>case</code>, and <code>do</code>, are treated as if they were inside an implicit <code>begin</code>; i.e., the expressions making up the body or result clause are executed in sequence, with the values of the last expression being returned.</p>\n</blockquote>\n<h3 id=\"5-3-Conditionals\"><a href=\"#5-3-Conditionals\" class=\"headerlink\" title=\"5.3. Conditionals\"></a>5.3. Conditionals</h3><p><code>if</code>, <code>not</code>, <code>and</code>, <code>or</code>, <code>cond</code>, <code>when</code>, <code>unless</code>, <code>case</code></p>\n<h3 id=\"5-4-Recursion-and-Iteration\"><a href=\"#5-4-Recursion-and-Iteration\" class=\"headerlink\" title=\"5.4. Recursion and Iteration\"></a>5.4. Recursion and Iteration</h3><p><code>(let name ((var expr) ...) body1 body2 ...)</code></p>\n<p><code>(do ((var init update) ...) (test result ...) expr ...)</code></p>\n<h3 id=\"5-5-Mapping-and-Folding\"><a href=\"#5-5-Mapping-and-Folding\" class=\"headerlink\" title=\"5.5. Mapping and Folding\"></a>5.5. Mapping and Folding</h3><p><code>(map procedure list1 list2 ...)</code><br><code>(for-each procedure list1 list2 ...)</code></p>\n<blockquote>\n<p><code>for-each</code> is similar to <code>map</code> except that <code>for-each</code> does not create and return a list of the resulting values, and <code>for-each</code> guarantees to perform the applications in sequence over the elements from left to right.</p>\n</blockquote>\n<p><code>(exists procedure list1 list2 ...)</code><br><code>(for-all procedure list1 list2 ...)</code></p>\n<p><code>exists</code> 和 <code>for-all</code> 的区别在于前者是在调用函数返回 <code>#t</code> 是结束，后者是在返回 <code>#f</code> 是结束。</p>\n<p><code>(fold-left procedure obj list1 list2 ...)</code><br><code>(fold-right procedure obj list1 list2 ...)</code></p>\n<h3 id=\"5-6-Continuations\"><a href=\"#5-6-Continuations\" class=\"headerlink\" title=\"5.6. Continuations\"></a>5.6. Continuations</h3><p>用一句比较玄的话来讲就是：它（Continuation）可以去到未来，也可以回到过去。</p>\n<p><code>(call/cc procedure)</code><br><code>(dynamic-wind in body out)</code></p>\n<p><code>dynamic-wind</code> 还需要再思考清楚。</p>\n<h3 id=\"5-7-Delayed-Evaluation\"><a href=\"#5-7-Delayed-Evaluation\" class=\"headerlink\" title=\"5.7. Delayed Evaluation\"></a>5.7. Delayed Evaluation</h3><blockquote>\n<p>The benefit of using <code>delay</code> and <code>force</code> is that some amount of computation might be avoided altogether if it is delayed until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or streams.</p>\n</blockquote>\n<h3 id=\"5-8-Multiple-Values\"><a href=\"#5-8-Multiple-Values\" class=\"headerlink\" title=\"5.8. Multiple Values\"></a>5.8. Multiple Values</h3><p><code>(call-with-values producer consumer)</code></p>\n<h3 id=\"5-9-Eval\"><a href=\"#5-9-Eval\" class=\"headerlink\" title=\"5.9. Eval\"></a>5.9. Eval</h3><blockquote>\n<p>Scheme’s <code>eval</code> procedure allows programmers to write programs that construct and evaluate other programs. This ability to do run-time meta programming should not be overused but is handy when needed.</p>\n</blockquote>\n<p><code>(eval obj environment)</code><br><code>(environment import-spec ...)</code></p>\n<h2 id=\"6-Operations-on-objects\"><a href=\"#6-Operations-on-objects\" class=\"headerlink\" title=\"6. Operations on objects\"></a>6. Operations on objects</h2><blockquote>\n<p>This chapter describes the operations on objects, including lists, numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations.</p>\n</blockquote>\n<h3 id=\"6-1-Constants-and-Quotation\"><a href=\"#6-1-Constants-and-Quotation\" class=\"headerlink\" title=\"6.1. Constants and Quotation\"></a>6.1. Constants and Quotation</h3><p><code>quote</code>, <code>quasiquote</code>, <code>unquote</code>, <code>unquote-splicing</code></p>\n<h3 id=\"6-2-Generic-Equivalence-and-Type-Predicates\"><a href=\"#6-2-Generic-Equivalence-and-Type-Predicates\" class=\"headerlink\" title=\"6.2. Generic Equivalence and Type Predicates\"></a>6.2. Generic Equivalence and Type Predicates</h3><blockquote>\n<p><code>eq?</code> is most often used to compare symbols or to check for pointer equivalence of allocated objects</p>\n</blockquote>\n<p><code>eq?</code>, <code>eqv?</code>, <code>equal?</code> 三者的区别在于后者比前者能判断的更加广泛。</p>\n<h3 id=\"6-3-Lists-and-Pairs\"><a href=\"#6-3-Lists-and-Pairs\" class=\"headerlink\" title=\"6.3. Lists and Pairs\"></a>6.3. Lists and Pairs</h3><p><code>(list &#39;+)</code> 与 <code>(list +)</code> 的区别在于，第一个 list 包含的是符号 symbol +，而第二个 list 包含的是程序 procedure +。</p>\n<p>也就是说， list 的内容可以包含任意类型的值，包括 procedure。</p>\n<p>注意 <code>&#39;(a b c)</code> 表示含有 symbol <code>a</code> 、 <code>b</code> 和 <code>c</code> 的 list，而不是一个叫 <code>(a b c)</code> 的 symbol。</p>\n<h3 id=\"6-4-Numbers\"><a href=\"#6-4-Numbers\" class=\"headerlink\" title=\"6.4. Numbers\"></a>6.4. Numbers</h3><blockquote>\n<p>Scheme numbers may be classified as integers, rational numbers, real numbers, or complex numbers. This classification is hierarchical, in that all integers are rational, all rational numbers are real, and all real numbers are complex.</p>\n</blockquote>\n<blockquote>\n<p>A Scheme number may also be classified as exact or inexact, depending upon the quality of operations used to derive the number and the inputs to these operations.</p>\n</blockquote>\n<h3 id=\"6-5-Fixnums\"><a href=\"#6-5-Fixnums\" class=\"headerlink\" title=\"6.5. Fixnums\"></a>6.5. Fixnums</h3><p>fixnum 指固定范围内的整数。</p>\n<h3 id=\"6-6-Flonums\"><a href=\"#6-6-Flonums\" class=\"headerlink\" title=\"6.6. Flonums\"></a>6.6. Flonums</h3><h3 id=\"6-7-Characters\"><a href=\"#6-7-Characters\" class=\"headerlink\" title=\"6.7. Characters\"></a>6.7. Characters</h3><h3 id=\"6-8-Strings\"><a href=\"#6-8-Strings\" class=\"headerlink\" title=\"6.8. Strings\"></a>6.8. Strings</h3><h3 id=\"6-9-Vectors\"><a href=\"#6-9-Vectors\" class=\"headerlink\" title=\"6.9. Vectors\"></a>6.9. Vectors</h3><blockquote>\n<p>Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time.</p>\n</blockquote>\n<h3 id=\"6-10-Bytevectors\"><a href=\"#6-10-Bytevectors\" class=\"headerlink\" title=\"6.10. Bytevectors\"></a>6.10. Bytevectors</h3><blockquote>\n<p>Bytevectors are vectors of raw binary data.</p>\n</blockquote>\n<h3 id=\"6-11-Symbols\"><a href=\"#6-11-Symbols\" class=\"headerlink\" title=\"6.11. Symbols\"></a>6.11. Symbols</h3><blockquote>\n<p>The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as identifiers in the representation of programs, allowing fast comparison of identifiers.</p>\n</blockquote>\n<h3 id=\"6-12-Booleans\"><a href=\"#6-12-Booleans\" class=\"headerlink\" title=\"6.12. Booleans\"></a>6.12. Booleans</h3><h3 id=\"6-13-Hashtables\"><a href=\"#6-13-Hashtables\" class=\"headerlink\" title=\"6.13. Hashtables\"></a>6.13. Hashtables</h3><blockquote>\n<p>Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose as association lists but are typically much faster when large numbers of associations are involved.</p>\n</blockquote>\n<h3 id=\"6-14-Enumerations\"><a href=\"#6-14-Enumerations\" class=\"headerlink\" title=\"6.14. Enumerations\"></a>6.14. Enumerations</h3><h2 id=\"7-Input-and-Output\"><a href=\"#7-Input-and-Output\" class=\"headerlink\" title=\"7. Input and Output\"></a>7. Input and Output</h2><blockquote>\n<p>All input and output operations are performed through ports.</p>\n</blockquote>\n<blockquote>\n<p>Ports are first-class objects, like any other object in Scheme.</p>\n</blockquote>\n<h3 id=\"7-1-Transcoders\"><a href=\"#7-1-Transcoders\" class=\"headerlink\" title=\"7.1. Transcoders\"></a>7.1. Transcoders</h3><h3 id=\"7-2-Opening-Files\"><a href=\"#7-2-Opening-Files\" class=\"headerlink\" title=\"7.2. Opening Files\"></a>7.2. Opening Files</h3><blockquote>\n<p>It is perhaps easier to imagine that the default file options are the imaginary option symbols <code>create</code>, <code>fail-if-exists</code>, and <code>truncate</code>; <code>no-create</code> removes <code>create</code>, <code>no-fail</code> removes <code>fail-if-exists</code>, and <code>no-truncate</code> removes <code>truncate</code>.</p>\n</blockquote>\n<h3 id=\"7-3-Standard-Ports\"><a href=\"#7-3-Standard-Ports\" class=\"headerlink\" title=\"7.3. Standard Ports\"></a>7.3. Standard Ports</h3><h3 id=\"7-4-String-and-Bytevector-Ports\"><a href=\"#7-4-String-and-Bytevector-Ports\" class=\"headerlink\" title=\"7.4. String and Bytevector Ports\"></a>7.4. String and Bytevector Ports</h3><h3 id=\"7-5-Opening-Custom-Ports\"><a href=\"#7-5-Opening-Custom-Ports\" class=\"headerlink\" title=\"7.5. Opening Custom Ports\"></a>7.5. Opening Custom Ports</h3><h3 id=\"7-6-Port-Operations\"><a href=\"#7-6-Port-Operations\" class=\"headerlink\" title=\"7.6. Port Operations\"></a>7.6. Port Operations</h3><h3 id=\"7-7-Input-Operations\"><a href=\"#7-7-Input-Operations\" class=\"headerlink\" title=\"7.7. Input Operations\"></a>7.7. Input Operations</h3><h3 id=\"7-8-Output-Operations\"><a href=\"#7-8-Output-Operations\" class=\"headerlink\" title=\"7.8. Output Operations\"></a>7.8. Output Operations</h3><h3 id=\"7-9-Convenience-I-O\"><a href=\"#7-9-Convenience-I-O\" class=\"headerlink\" title=\"7.9. Convenience I/O\"></a>7.9. Convenience I/O</h3><h3 id=\"7-10-Filesystem-Operations\"><a href=\"#7-10-Filesystem-Operations\" class=\"headerlink\" title=\"7.10. Filesystem Operations\"></a>7.10. Filesystem Operations</h3><h3 id=\"7-11-Bytevector-String-Conversions\"><a href=\"#7-11-Bytevector-String-Conversions\" class=\"headerlink\" title=\"7.11. Bytevector/String Conversions\"></a>7.11. Bytevector/String Conversions</h3><h2 id=\"8-Syntactic-Extension\"><a href=\"#8-Syntactic-Extension\" class=\"headerlink\" title=\"8. Syntactic Extension\"></a>8. Syntactic Extension</h2><blockquote>\n<p>Syntactic extensions, or macros, are used to simplify and regularize repeated patterns in a program, to introduce syntactic forms with new evaluation rules, and to perform transformations that help make programs more efficient.</p>\n</blockquote>\n<blockquote>\n<p>Syntactic extensions are expanded into core forms at the start of evaluation (before compilation or interpretation) by a syntax expander.</p>\n</blockquote>\n<h3 id=\"8-1-Keyword-Bindings\"><a href=\"#8-1-Keyword-Bindings\" class=\"headerlink\" title=\"8.1. Keyword Bindings\"></a>8.1. Keyword Bindings</h3><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> keyword expr)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let-syntax</span></span> ((<span class=\"name\">keyword</span> expr) ...) form1 form2 ...)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">letrec-syntax</span></span> ((<span class=\"name\">keyword</span> expr) ...) form1 form2 ...)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-Syntax-Rules-Transformers\"><a href=\"#8-2-Syntax-Rules-Transformers\" class=\"headerlink\" title=\"8.2. Syntax-Rules Transformers\"></a>8.2. Syntax-Rules Transformers</h3><blockquote>\n<p>P is of the form (P1 … Pn) and F is a list of n elements that match P1 through Pn</p>\n</blockquote>\n<p>上面一句话的意思如果模式 P 是 <code>(p1 p2 p3 p4)</code> 这样子的格式的话，则 F 也必须是包含 4 个元素的列表。这里的 <code>...</code> 表示的是确定的指定了 n 个子模式。而不是在模式出现 <code>...</code> 这个标识符。表示模式中出现 <code>...</code> 标识符是通过下面中提到的标识符 <code>ellipsis</code> 来指代的。注意这里容易造成混淆。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\"><span class=\"builtin-name\">if</span></span> <span class=\"literal\">#f</span>])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">t</span> <span class=\"symbol\">&#x27;okay</span>])</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">or</span></span> if t)))</span><br></pre></td></tr></table></figure>\n\n<p>扩展为：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (if1)</span><br><span class=\"line\">   ((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (t1)</span><br><span class=\"line\">      ((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (t2)</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">if</span></span> t2 t2 t1))</span><br><span class=\"line\">       if1))</span><br><span class=\"line\">    <span class=\"symbol\">&#x27;okay</span>))</span><br><span class=\"line\"> <span class=\"literal\">#f</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-Syntax-Case-Transformers\"><a href=\"#8-3-Syntax-Case-Transformers\" class=\"headerlink\" title=\"8.3. Syntax-Case Transformers\"></a>8.3. Syntax-Case Transformers</h3><blockquote>\n<p>With this mechanism (<code>syntax-case</code>), transformers are procedures of one argument. The argument is a syntax object representing the form to be processed. The return value is a syntax object representing the output form. A syntax object may be any of the following.</p>\n</blockquote>\n<blockquote>\n<p><code>#&#39;template</code> is equivalent to <code>(syntax template)</code>. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.</p>\n</blockquote>\n<blockquote>\n<p>Syntactic extensions ordinarily take the form <code>(keyword subform ...)</code>, but the <code>syntax-case</code> system permits them to take the form of singleton identifiers as well.</p>\n</blockquote>\n<p><code>(with-syntax ((pattern expr) ...) body1 body2 ...)</code></p>\n<p>理解：这里理解的重点是 <code>pattern</code>，其实和 <code>syntax-case</code> 中的 <code>pattern</code> 一致。用于解构 <code>expr</code> 的值。且看下面的示例：</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> lab</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">syntax-case</span></span> x ()</span><br><span class=\"line\">      [(<span class=\"name\">_</span> e1 e2)</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">with-syntax</span></span> ([(<span class=\"name\">_</span> x1 x2) #<span class=\"symbol\">&#x27;e1</span>]</span><br><span class=\"line\">                     [(<span class=\"name\">_</span> y1 y2) #<span class=\"symbol\">&#x27;e2</span>])</span><br><span class=\"line\">         #&#x27;(+ x1 x2 y1 y2))])))</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>quasisyntax</code> can be used in place of <code>with-syntax</code> in many cases.</p>\n</blockquote>\n<p>值得思考 <code>(datum-&gt;syntax template-identifier obj)</code> 的作用。</p>\n<p>关于本章的语法扩展问题，需要多思考作用域相关的问题。</p>\n<h2 id=\"9-Records\"><a href=\"#9-Records\" class=\"headerlink\" title=\"9. Records\"></a>9. Records</h2><h3 id=\"9-1-Defining-Records\"><a href=\"#9-1-Defining-Records\" class=\"headerlink\" title=\"9.1. Defining Records\"></a>9.1. Defining Records</h3><p>注意每次定义 record type ，即使名字一样，也是不同的。</p>\n<h3 id=\"9-2-Procedural-Interface\"><a href=\"#9-2-Procedural-Interface\" class=\"headerlink\" title=\"9.2. Procedural Interface\"></a>9.2. Procedural Interface</h3><h2 id=\"10-Libraries-and-Top-Level-Programs\"><a href=\"#10-Libraries-and-Top-Level-Programs\" class=\"headerlink\" title=\"10. Libraries and Top-Level Programs\"></a>10. Libraries and Top-Level Programs</h2><p>学习 Scheme 库的建立。</p>\n<h3 id=\"10-1-Standard-Libraries\"><a href=\"#10-1-Standard-Libraries\" class=\"headerlink\" title=\"10.1. Standard Libraries\"></a>10.1. Standard Libraries</h3><h3 id=\"10-2-Defining-New-Libraries\"><a href=\"#10-2-Defining-New-Libraries\" class=\"headerlink\" title=\"10.2. Defining New Libraries\"></a>10.2. Defining New Libraries</h3><h3 id=\"10-3-Top-Level-Programs\"><a href=\"#10-3-Top-Level-Programs\" class=\"headerlink\" title=\"10.3. Top-Level Programs\"></a>10.3. Top-Level Programs</h3><blockquote>\n<p>Top-level programs can be thought of as <code>library</code> forms without the library wrapper, library name, and export form.</p>\n</blockquote>\n<h2 id=\"11-Exceptions-and-Conditions\"><a href=\"#11-Exceptions-and-Conditions\" class=\"headerlink\" title=\"11. Exceptions and Conditions\"></a>11. Exceptions and Conditions</h2><blockquote>\n<p>Exceptions and conditions provide the means for system and user code to signal, detect, and recover from errors that occur when a program is run.</p>\n</blockquote>\n<h3 id=\"11-1-Raising-and-Handling-Exceptions\"><a href=\"#11-1-Raising-and-Handling-Exceptions\" class=\"headerlink\" title=\"11.1. Raising and Handling Exceptions\"></a>11.1. Raising and Handling Exceptions</h3><h3 id=\"11-2-Defining-Condition-Types\"><a href=\"#11-2-Defining-Condition-Types\" class=\"headerlink\" title=\"11.2. Defining Condition Types\"></a>11.2. Defining Condition Types</h3><h3 id=\"11-3-Standard-Condition-Types\"><a href=\"#11-3-Standard-Condition-Types\" class=\"headerlink\" title=\"11.3. Standard Condition Types\"></a>11.3. Standard Condition Types</h3><h2 id=\"12-Extended-Examples\"><a href=\"#12-Extended-Examples\" class=\"headerlink\" title=\"12. Extended Examples\"></a>12. Extended Examples</h2><h3 id=\"12-1-Matrix-and-Vector-Multiplication\"><a href=\"#12-1-Matrix-and-Vector-Multiplication\" class=\"headerlink\" title=\"12.1. Matrix and Vector Multiplication\"></a>12.1. Matrix and Vector Multiplication</h3><h3 id=\"12-2-Sorting\"><a href=\"#12-2-Sorting\" class=\"headerlink\" title=\"12.2. Sorting\"></a>12.2. Sorting</h3><h3 id=\"12-3-A-Set-Constructor\"><a href=\"#12-3-A-Set-Constructor\" class=\"headerlink\" title=\"12.3. A Set Constructor\"></a>12.3. A Set Constructor</h3><h3 id=\"12-4-Word-Frequency-Counting\"><a href=\"#12-4-Word-Frequency-Counting\" class=\"headerlink\" title=\"12.4. Word Frequency Counting\"></a>12.4. Word Frequency Counting</h3><h3 id=\"12-5-Scheme-Printer\"><a href=\"#12-5-Scheme-Printer\" class=\"headerlink\" title=\"12.5. Scheme Printer\"></a>12.5. Scheme Printer</h3><h3 id=\"12-6-Formatted-Output\"><a href=\"#12-6-Formatted-Output\" class=\"headerlink\" title=\"12.6. Formatted Output\"></a>12.6. Formatted Output</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>重点是前三章的内容，值得多读几遍。另外第十二章的示例还差几个没有看完。其余章节都浏览了一遍。之后需要查阅相关的内容时，请在索引页面搜索。</p>\n<h2 id=\"Exercise\"><a href=\"#Exercise\" class=\"headerlink\" title=\"Exercise\"></a>Exercise</h2><p>2.2.1</p>\n<p>a. (+ (* 1.2 (- 2 1/3) -8.7))<br>b. (/ (+ 2/3 4/9) (- 5/11 -4/3))<br>c. (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 1/2)))))<br>d. (* 1 -2 3 -4 5 -6 7)</p>\n<p>2.2.2</p>\n<p>complex numbers<br>real numbers<br>rational numbers<br>integers</p>\n<p>2.2.3</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a. (car cdr)</span><br><span class=\"line\">b. (this ((is silly)))</span><br><span class=\"line\">c. (is this silly?)</span><br><span class=\"line\">d. (+ 2 3)</span><br><span class=\"line\">e. (+ 2 3)</span><br><span class=\"line\">f. +</span><br><span class=\"line\">g. (2 3)</span><br><span class=\"line\">h. #&lt;procedure cons&gt;</span><br><span class=\"line\">i. cons</span><br><span class=\"line\">j. (quote cons)</span><br><span class=\"line\">k. quote</span><br><span class=\"line\">l. 5</span><br><span class=\"line\">m. 5</span><br><span class=\"line\">n. 5</span><br><span class=\"line\">o. 5</span><br></pre></td></tr></table></figure>\n\n<p>2.2.4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(car (car &#39;((a b) (c d)))) &#x3D;&gt; a</span><br><span class=\"line\">(car (cdr (car &#39;((a b) (c d))))) &#x3D;&gt; b</span><br><span class=\"line\">(car (car (cdr &#39;((a b) (c d))))) &#x3D;&gt; c</span><br><span class=\"line\">(car (cdr (car (cdr &#39;((a b) (c d)))))) &#x3D;&gt; d</span><br></pre></td></tr></table></figure>\n\n<p>2.2.5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;((a . b) ((c) d) ())</span><br></pre></td></tr></table></figure>\n\n<p>2.2.6</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1 (2 (3)) (()) 4 . 5)</span><br></pre></td></tr></table></figure>\n\n<p>2.2.8</p>\n<p>试着解释 Scheme 表达式是如何求值。</p>\n<p>答：先递归求值每个操作数，然后将得到的值应用到操作符上。</p>\n<p>2.3.1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(cdr (list + - * &#x2F;)) &#x3D;&gt; (list - * &#x2F;)</span><br><span class=\"line\">(car (list - * &#x2F;)) &#x3D;&gt; -</span><br><span class=\"line\">(- 17 5) &#x3D;&gt; 12</span><br></pre></td></tr></table></figure>\n\n<p>2.4.1</p>\n<p>a.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">3</span> a)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">y1</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x b)]</span><br><span class=\"line\">        [<span class=\"name\">y2</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x b)])</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> y1 y2)))</span><br></pre></td></tr></table></figure>\n\n<p>b.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> a b c)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)]</span><br><span class=\"line\">        [<span class=\"name\">x2</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls)])</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x1 x2)))</span><br></pre></td></tr></table></figure>\n\n<p>2.4.3</p>\n<p>a.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> <span class=\"symbol\">&#x27;a</span>] [<span class=\"name\">y1</span> <span class=\"symbol\">&#x27;b</span>])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x2</span> <span class=\"symbol\">&#x27;c</span>]) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x2 y1))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">y2</span> <span class=\"symbol\">&#x27;d</span>]) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> x1 y2))))</span><br></pre></td></tr></table></figure>\n\n<p>b.</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> &#x27;((a b) c)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x2</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x1)])</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x2))</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x3</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x1)])</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x4</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x3)])</span><br><span class=\"line\">                  (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x4))</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x5</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> x3)])</span><br><span class=\"line\">                        x5)</span><br><span class=\"line\">                      (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x3))))))</span><br></pre></td></tr></table></figure>\n\n<p>2.5.1</p>\n<p>a. ‘a<br>b. ‘(a)<br>c. ‘a<br>d. ‘()</p>\n<p>2.5.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> <span class=\"name\">ls</span> <span class=\"name\">ls</span>))</span><br></pre></td></tr></table></figure>\n\n<p>2.5.3</p>\n<p>a. empty<br>b. +<br>c. f<br>d. f, y<br>e. y</p>\n<p>2.6.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> compose</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (p1 p2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">      (<span class=\"name\">p1</span> (<span class=\"name\">p2</span> x)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadr (<span class=\"name\">compose</span> car cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddr (<span class=\"name\">compose</span> cdr cdr))</span><br></pre></td></tr></table></figure>\n\n<p>2.6.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caar (<span class=\"name\">compose</span> car car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdar (<span class=\"name\">compose</span> cdr car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaar (<span class=\"name\">compose</span> caar car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caadr (<span class=\"name\">compose</span> caar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadar (<span class=\"name\">compose</span> cadr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaar (<span class=\"name\">compose</span> cdar car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdddr (<span class=\"name\">compose</span> cddr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddar (<span class=\"name\">compose</span> cddr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdadr (<span class=\"name\">compose</span> cdar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caddr (<span class=\"name\">compose</span> cadr cdr))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaaar (<span class=\"name\">compose</span> caaar car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaadr (<span class=\"name\">compose</span> caaar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caadar (<span class=\"name\">compose</span> caadr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadaar (<span class=\"name\">compose</span> cadar car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaaar (<span class=\"name\">compose</span> cdaar car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caaddr (<span class=\"name\">compose</span> caadr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadadr (<span class=\"name\">compose</span> cadar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaadr (<span class=\"name\">compose</span> cdaar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> caddar (<span class=\"name\">compose</span> caddr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdadar (<span class=\"name\">compose</span> cdadr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddaar (<span class=\"name\">compose</span> cddar car))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddddr (<span class=\"name\">compose</span> cdddr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdddar (<span class=\"name\">compose</span> cdddr car))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cddadr (<span class=\"name\">compose</span> cddar cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cdaddr (<span class=\"name\">compose</span> cdadr cdr))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> cadddr (<span class=\"name\">compose</span> caddr cdr))</span><br></pre></td></tr></table></figure>\n\n<p>2.7.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> atom?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x))))</span><br></pre></td></tr></table></figure>\n\n<p>2.7.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> shorter</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls1 ls2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> ls2) (<span class=\"name\"><span class=\"builtin-name\">length</span></span> ls1))</span><br><span class=\"line\">        ls2</span><br><span class=\"line\">        ls1)))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.1</p>\n<p>交换 cons 的参数顺序将会导致复制的 tree 的每一个节点的子节点被调换。</p>\n<p>2.8.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-list</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n obj)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#x27;()</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> obj (<span class=\"name\">make-list</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>) obj)))))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-ref</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls idx)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> idx <span class=\"number\">1</span>)))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-tail</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls idx)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">        ls</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> idx <span class=\"number\">1</span>)))))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.5</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> shorter?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls1 ls2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls1) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls2) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">shorter?</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls1) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls2))])))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> shorter</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls1 ls2)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">shorter?</span> ls1 ls2)</span><br><span class=\"line\">        ls1</span><br><span class=\"line\">        ls2)))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.6</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> odd?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"literal\">#f</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">even?</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>)))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> even?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"literal\">#t</span></span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">odd?</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> n <span class=\"number\">1</span>)))))</span><br></pre></td></tr></table></figure>\n\n<p>2.8.7</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> transpose</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">left</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> car ls)]</span><br><span class=\"line\">          [<span class=\"name\">right</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> cdr ls)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> left right))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-counter</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (init step)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">init</span> init])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> init (<span class=\"name\"><span class=\"builtin-name\">+</span></span> init step))</span><br><span class=\"line\">        init))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-stack</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> &#x27;()])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (msg . args)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">case</span></span> msg</span><br><span class=\"line\">          [(<span class=\"name\">empty?</span>) (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">push!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args) ls))]</span><br><span class=\"line\">          [(<span class=\"name\">top</span>) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">pop!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"string\">&quot;oops&quot;</span>])))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-stack</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> &#x27;()])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (msg . args)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">case</span></span> msg</span><br><span class=\"line\">          [(<span class=\"name\">empty?</span>) (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">push!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args) ls))]</span><br><span class=\"line\">          [(<span class=\"name\">top</span>) (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls)]</span><br><span class=\"line\">          [(<span class=\"name\">pop!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls))]</span><br><span class=\"line\">          [(<span class=\"name\">ref</span>) (<span class=\"name\"><span class=\"builtin-name\">list-ref</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">set!</span></span>) (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> (<span class=\"name\"><span class=\"builtin-name\">list-tail</span></span> ls (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))</span><br><span class=\"line\">                            (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"string\">&quot;oops&quot;</span>])))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-stack</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\"><span class=\"builtin-name\">vector</span></span> (<span class=\"name\"><span class=\"builtin-name\">make-vector</span></span> n)]</span><br><span class=\"line\">          [<span class=\"name\">at</span> <span class=\"number\">0</span>])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (msg . args)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">case</span></span> msg</span><br><span class=\"line\">          [(<span class=\"name\">empty?</span>) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> at <span class=\"number\">0</span>)]</span><br><span class=\"line\">          [(<span class=\"name\">push!</span>) (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">                     (<span class=\"name\"><span class=\"builtin-name\">vector-set!</span></span> vector at (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))</span><br><span class=\"line\">                     (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> at (<span class=\"name\"><span class=\"builtin-name\">+</span></span> at <span class=\"number\">1</span>)))]</span><br><span class=\"line\">          [(<span class=\"name\">top</span>) (<span class=\"name\"><span class=\"builtin-name\">vector-ref</span></span> vector (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span>))]</span><br><span class=\"line\">          [(<span class=\"name\">pop!</span>) (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> at (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span>))]</span><br><span class=\"line\">          [(<span class=\"name\">ref</span>)</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">idx</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))])</span><br><span class=\"line\">             (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">                 (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;make-stack</span> <span class=\"string\">&quot;out of range.&quot;</span> idx)</span><br><span class=\"line\">                 (<span class=\"name\"><span class=\"builtin-name\">vector-ref</span></span> vector idx)))]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">set!</span></span>)</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">idx</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> at <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args))])</span><br><span class=\"line\">             (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> idx <span class=\"number\">0</span>)</span><br><span class=\"line\">                 (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;make-stack</span> <span class=\"string\">&quot;out of range.&quot;</span> idx)</span><br><span class=\"line\">                 (<span class=\"name\"><span class=\"builtin-name\">vector-set!</span></span> vector idx (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args))))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"string\">&quot;oops&quot;</span>])))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.5</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-queue</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">end</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"symbol\">&#x27;ignored</span> &#x27;())])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> end end))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> emptyq?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> putq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q v)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">end</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"symbol\">&#x27;ignored</span> &#x27;())])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q) v)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q) end)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q end))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> getq</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">        (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;getq</span> <span class=\"string\">&quot;queue is empty&quot;</span> q)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">car</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> delq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">        (<span class=\"name\">assertion-violation</span> delq <span class=\"string\">&quot;queue is empty&quot;</span> q)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q))))))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.6</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> make-queue</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">end</span> &#x27;()])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> end end))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> emptyq?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q))</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> putq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q v)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">tail</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> tail)</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">body</span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> v &#x27;())])</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q body)</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q body))</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> tail (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> v &#x27;()))</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> tail)))))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> getq</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">        (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;getq</span> <span class=\"string\">&quot;queue is empty&quot;</span> q)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">car</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q)))))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> delq!</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (q)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\">emptyq?</span> q)</span><br><span class=\"line\">       (<span class=\"name\">assertion-violation</span> delq <span class=\"string\">&quot;queue is empty&quot;</span> q)]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> q))</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">empty</span> &#x27;()])</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q empty)</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">set-cdr!</span></span> q empty))]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span></span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">set-car!</span></span> q (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> q)))])))</span><br></pre></td></tr></table></figure>\n\n<p>2.9.8</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> x) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x)</span><br><span class=\"line\">            (<span class=\"name\">have-cyclic?</span> x x)) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x) (<span class=\"name\">list-help</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x))]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"literal\">#f</span>])))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> list-help</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> x) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> x) (<span class=\"name\">list-help</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> x))]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> <span class=\"literal\">#f</span>])))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> have-cyclic?</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (hare tortoise)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> hare))) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">pair?</span></span> (<span class=\"name\">cddr</span> hare))) <span class=\"literal\">#f</span>]</span><br><span class=\"line\">      [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> (<span class=\"name\">cddr</span> hare) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> tortoise)) <span class=\"literal\">#t</span>]</span><br><span class=\"line\">      [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">have-cyclic?</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> hare)) (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> tortoise))])))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x</span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;a</span> ls)])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">and</span></span> x (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;b</span> x)))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">   (<span class=\"name\"><span class=\"builtin-name\">if</span></span> x (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;b</span> x)) <span class=\"literal\">#f</span>))</span><br><span class=\"line\"> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;a</span> ls))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">   (<span class=\"name\"><span class=\"builtin-name\">if</span></span> x (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;b</span> x) <span class=\"literal\">#f</span>))</span><br><span class=\"line\"> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> <span class=\"symbol\">&#x27;a</span> ls))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c)) (<span class=\"name\"><span class=\"builtin-name\">list</span></span> x))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> x)))</span><br><span class=\"line\"><span class=\"comment\">;; =&gt;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">memv</span></span> x &#x27;(a b c))</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">list</span></span> x))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> let*</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> () b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> () b1 b2 ...)]</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ([<span class=\"name\">x</span> e]) b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x</span> e]) b1 b2 ...)]</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ([<span class=\"name\">x1</span> e1] [<span class=\"name\">x2</span> e2] ...) b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">x1</span> e1])</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">let*</span></span> ([<span class=\"name\">x2</span> e2] ...) b1 b2 ...))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.1.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> when <span class=\"comment\">;; 如果对</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> test e1 e2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">if</span></span> test</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">begin</span></span> e1 e2 ...)</span><br><span class=\"line\">         <span class=\"literal\">#f</span>)]))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> unless <span class=\"comment\">;; 如果不对</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> test e1 e2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">when</span></span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> test) e1 e2 ...)]))</span><br></pre></td></tr></table></figure>\n\n<p>3.2.2</p>\n<p>the named <code>let</code>, beacuse it’s more simple.</p>\n<p>3.2.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> xxx ([<span class=\"name\">t</span> <span class=\"symbol\">&#x27;even?</span>] [<span class=\"name\">x</span> <span class=\"number\">20</span>])</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> t <span class=\"symbol\">&#x27;even?</span>)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">         (<span class=\"name\">xxx</span> <span class=\"symbol\">&#x27;odd?</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>)))]</span><br><span class=\"line\">    [(<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> t <span class=\"symbol\">&#x27;odd?</span>)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>))</span><br><span class=\"line\">          (<span class=\"name\">xxx</span> <span class=\"symbol\">&#x27;even?</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>)))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.2.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">fibonacci</span> <span class=\"number\">40</span>)</span><br></pre></td></tr></table></figure>\n\n<p>1: 331160280次<br>2: 39次</p>\n<p>3.2.5</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;; use set!</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> let</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ((<span class=\"name\">x</span> e) ...) b1 b2 ...)</span><br><span class=\"line\">     ((<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x ...) b1 b2 ...) e ...)]</span><br><span class=\"line\">    [(<span class=\"name\">_</span> name ((<span class=\"name\">x</span> e) ...) b1 b2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">name</span> <span class=\"literal\">#f</span>])</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> name (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x ...) b1 b2 ...))</span><br><span class=\"line\">       (<span class=\"name\">name</span> e ...))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.2.6</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> even? <span class=\"comment\">; incorrect!</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">a</span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> a</span><br><span class=\"line\">          a</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">b</span> (<span class=\"name\"><span class=\"builtin-name\">odd?</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>))])</span><br><span class=\"line\">            (<span class=\"name\"><span class=\"builtin-name\">if</span></span> b b <span class=\"literal\">#f</span>))))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> even? <span class=\"comment\">; correct!</span></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">a</span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> a</span><br><span class=\"line\">          a</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">odd?</span></span> (<span class=\"name\">-x</span> <span class=\"number\">1</span>))))))</span><br></pre></td></tr></table></figure>\n\n<p>注意它们的区别：每次调用 <code>even?</code> 就多了一层 <code>let</code> 和 <code>if</code></p>\n<p>3.2.7</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> factor</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> f ([<span class=\"name\">n</span> n] [<span class=\"name\">i</span> <span class=\"number\">3</span>])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">let-values</span></span> ([(<span class=\"name\">s</span> r) (<span class=\"name\">exact-integer-sqrt</span> n)])</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> i s) (<span class=\"name\"><span class=\"builtin-name\">list</span></span> n)]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">integer?</span></span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n <span class=\"number\">2</span>))</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">2</span> (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n <span class=\"number\">2</span>) i))]</span><br><span class=\"line\">          [(<span class=\"name\"><span class=\"builtin-name\">integer?</span></span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n i))</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> i (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> n i) i))]</span><br><span class=\"line\">          [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">f</span> n (<span class=\"name\"><span class=\"builtin-name\">+</span></span> i <span class=\"number\">1</span>))])))))</span><br></pre></td></tr></table></figure>\n\n<p>First is the most important problem to solve.</p>\n<p>3.3.1</p>\n<p>3.3.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> product</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> f ([<span class=\"name\">ls</span> ls] [<span class=\"name\">c</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> () <span class=\"number\">1</span>)])</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls) (<span class=\"name\">c</span>)]</span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) <span class=\"number\">0</span>) <span class=\"number\">0</span>]</span><br><span class=\"line\">        [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">f</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">                            (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) (<span class=\"name\">c</span>))))]))))</span><br></pre></td></tr></table></figure>\n\n<p>通过回调的形式返回。</p>\n<p>3.3.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> exit (<span class=\"name\"><span class=\"builtin-name\">call/cc</span></span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (k) k)))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> quit</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> lwp-list)</span><br><span class=\"line\">        (<span class=\"name\">exit</span> <span class=\"literal\">#f</span>)</span><br><span class=\"line\">        (<span class=\"name\">start</span>))))</span><br></pre></td></tr></table></figure>\n\n<p>关键是定义一个退出的 continuation。</p>\n<p>3.3.4</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> lwp-list (<span class=\"name\">make-queue</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> lwp</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (thunk)</span><br><span class=\"line\">    (<span class=\"name\">putq!</span> lwp-list thunk)))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> start</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> ()</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">p</span> (<span class=\"name\">getq</span> lwp-list)])</span><br><span class=\"line\">      (<span class=\"name\">delq!</span> lwp-list)</span><br><span class=\"line\">      (<span class=\"name\">p</span>))))</span><br></pre></td></tr></table></figure>\n\n<p>3.3.5</p>\n<p>3.4.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> reciprocal</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n success failure)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> n <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\">failure</span>)</span><br><span class=\"line\">        (<span class=\"name\">success</span> (<span class=\"name\"><span class=\"builtin-name\">/</span></span> <span class=\"number\">1</span> n)))))</span><br></pre></td></tr></table></figure>\n\n<p>3.4.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> retry <span class=\"literal\">#f</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> factorial</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (x k)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">begin</span></span></span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> retry k)</span><br><span class=\"line\">          (<span class=\"name\">k</span> <span class=\"number\">1</span>))</span><br><span class=\"line\">        (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">                   (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (n)</span><br><span class=\"line\">                     (<span class=\"name\">k</span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> n x)))))))</span><br></pre></td></tr></table></figure>\n\n<p>3.4.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> reciprocals</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ls success failure)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">let</span></span> map1 [(<span class=\"name\">ls</span> ls) (<span class=\"name\">ls2</span> &#x27;())]</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">null?</span></span> ls)</span><br><span class=\"line\">         (<span class=\"name\">success</span> (<span class=\"name\"><span class=\"builtin-name\">reverse</span></span> ls2))]</span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) <span class=\"number\">0</span>)</span><br><span class=\"line\">         (<span class=\"name\">failure</span> <span class=\"string\">&quot;zero found&quot;</span>)]</span><br><span class=\"line\">        [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">map1</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> ls) (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> ls) ls2))]))))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> complain</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> ek msg expr)</span><br><span class=\"line\">     (<span class=\"name\">ek</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> msg expr))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.2</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> calc</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (expr)</span><br><span class=\"line\">    <span class=\"comment\">; grab an error continuation ek</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">call/cc</span></span></span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek)</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">define</span></span> do-calc</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek expr)</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">             [(<span class=\"name\"><span class=\"builtin-name\">number?</span></span> expr) expr]</span><br><span class=\"line\">             [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">list?</span></span> expr) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> expr) <span class=\"number\">3</span>))</span><br><span class=\"line\">              (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">op</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> expr)] [<span class=\"name\">args</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> expr)])</span><br><span class=\"line\">                (<span class=\"name\"><span class=\"builtin-name\">case</span></span> op</span><br><span class=\"line\">                  [(<span class=\"name\">add</span>) (<span class=\"name\">apply-op</span> ek + args)]</span><br><span class=\"line\">                  [(<span class=\"name\">sub</span>) (<span class=\"name\">apply-op</span> ek - args)]</span><br><span class=\"line\">                  [(<span class=\"name\">mul</span>) (<span class=\"name\">apply-op</span> ek * args)]</span><br><span class=\"line\">                  [(<span class=\"name\">div</span>) (<span class=\"name\">apply-op</span> ek / args)]</span><br><span class=\"line\">                  [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">complain</span> ek <span class=\"string\">&quot;invalid operator&quot;</span> op)]))]</span><br><span class=\"line\">             [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">complain</span> ek <span class=\"string\">&quot;invalid expression&quot;</span> expr)])))</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">define</span></span> apply-op</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek op args)</span><br><span class=\"line\">           (<span class=\"name\">op</span> (<span class=\"name\">do-calc</span> ek (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args)) (<span class=\"name\">do-calc</span> ek (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args)))))</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">define</span></span> complain</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (ek msg expr)</span><br><span class=\"line\">           (<span class=\"name\">ek</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> msg expr))))</span><br><span class=\"line\">       (<span class=\"name\">do-calc</span> ek expr)))))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.3</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define</span></span> calc <span class=\"literal\">#f</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> ()</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> do-calc</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (expr)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">number?</span></span> expr) expr]</span><br><span class=\"line\">        [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">list?</span></span> expr) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> expr) <span class=\"number\">3</span>))</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">op</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> expr)] [<span class=\"name\">args</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> expr)])</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">case</span></span> op</span><br><span class=\"line\">             [(<span class=\"name\">add</span>) (<span class=\"name\">apply-op</span> + args)]</span><br><span class=\"line\">             [(<span class=\"name\">sub</span>) (<span class=\"name\">apply-op</span> - args)]</span><br><span class=\"line\">             [(<span class=\"name\">mul</span>) (<span class=\"name\">apply-op</span> * args)]</span><br><span class=\"line\">             [(<span class=\"name\">div</span>) (<span class=\"name\">apply-op</span> / args)]</span><br><span class=\"line\">             [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;do-calc</span> <span class=\"string\">&quot;invalid operator&quot;</span> op)]))]</span><br><span class=\"line\">        [<span class=\"name\"><span class=\"builtin-name\">else</span></span> (<span class=\"name\">assertion-violation</span> <span class=\"symbol\">&#x27;do-calc</span> <span class=\"string\">&quot;invalid expression&quot;</span> expr)])))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> apply-op</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (op args)</span><br><span class=\"line\">      (<span class=\"name\">op</span> (<span class=\"name\">do-calc</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> args)) (<span class=\"name\">do-calc</span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> args)))))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">set!</span></span> calc do-calc))</span><br></pre></td></tr></table></figure>\n\n<p>3.5.4</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">       [(<span class=\"name\"><span class=\"builtin-name\">and</span></span> (<span class=\"name\"><span class=\"builtin-name\">list?</span></span> expr) (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">length</span></span> expr) <span class=\"number\">2</span>))</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">op</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> expr)] [<span class=\"name\">arg</span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> expr)])</span><br><span class=\"line\">           (<span class=\"name\"><span class=\"builtin-name\">case</span></span> op</span><br><span class=\"line\">             [(<span class=\"name\">minus</span>) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> (<span class=\"name\">do-calc</span> arg))]))]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>3.6.1</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> gpa</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">    [(<span class=\"name\">_</span> g1 g2 ...)</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> letter-&gt;number</span><br><span class=\"line\">                    (<span class=\"name\">filter</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g) (<span class=\"name\"><span class=\"builtin-name\">not</span></span> (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> g <span class=\"symbol\">&#x27;x</span>)))</span><br><span class=\"line\">                          &#x27;(g1 g2 ...)))])</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">/</span></span> (<span class=\"name\"><span class=\"builtin-name\">apply</span></span> + ls) (<span class=\"name\"><span class=\"builtin-name\">length</span></span> ls)))]))</span><br></pre></td></tr></table></figure>\n\n<p>3.6.2</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  define count</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g0 ls)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">length</span></span> (<span class=\"name\">filter</span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g) (<span class=\"name\"><span class=\"builtin-name\">eq?</span></span> g g0))</span><br><span class=\"line\">                      ls))))</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> gs &#x27;(a b c d f))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define-syntax</span></span> distribution</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">syntax-rules</span></span> ()</span><br><span class=\"line\">      [(<span class=\"name\">_</span> g1 g2 ...)</span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">let</span></span> ([<span class=\"name\">ls</span> &#x27;(g1 g2 ...)])</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">map</span></span> list (<span class=\"name\"><span class=\"builtin-name\">map</span></span> (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (g0) (<span class=\"name\">count</span> g0 ls))</span><br><span class=\"line\">                        gs)</span><br><span class=\"line\">              gs))]))</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>3.6.3</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> print-one</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (gn)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">string-append</span></span></span><br><span class=\"line\">       <span class=\"string\">&quot;  &quot;</span></span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">symbol-&gt;string</span></span> (<span class=\"name\"><span class=\"builtin-name\">cadr</span></span> gn))</span><br><span class=\"line\">       <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">       (<span class=\"name\"><span class=\"builtin-name\">make-string</span></span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> gn) <span class=\"literal\">#\\*</span>)</span><br><span class=\"line\">       <span class=\"string\">&quot;\\n&quot;</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> print</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (dist)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">null?</span></span> dist)</span><br><span class=\"line\">          <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">string-append</span></span> (<span class=\"name\">print-one</span> (<span class=\"name\"><span class=\"builtin-name\">car</span></span> dist))</span><br><span class=\"line\">                         (<span class=\"name\">print</span> (<span class=\"name\"><span class=\"builtin-name\">cdr</span></span> dist))))))</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">define</span></span> histogram</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">lambda</span></span> (port dist)</span><br><span class=\"line\">      (<span class=\"name\">put-string</span> port <span class=\"string\">&quot;prints:\\n&quot;</span>)</span><br><span class=\"line\">      (<span class=\"name\">put-string</span> port</span><br><span class=\"line\">                  (<span class=\"name\">print</span> dist))))</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>12.2.1</p>\n<p>使用 <code>(list (car ls))</code> 的原因是因为虽然此时 <code>n</code> 是 1，但是 <code>ls</code> 可能含有超过不只一个元素。如果直接返回 <code>ls</code>，就会导致结果不正确。</p>\n<p>如果替换成 <code>(if (null? (cdr ls)) ls (list (car ls)))</code>，可以省去 <code>ls</code> 的初始长度那么多的空间。</p>\n<p>12.2.2</p>\n<p>假设有 <code>n</code> 个数字排列，则可以省略 <code>n</code> 个空间。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cki1szjzn0000rnq750akh49k","category_id":"cki1szjzs0002rnq70kjy6s6u","_id":"cki1szjzx000crnq704eh7r2h"},{"post_id":"cki1szjzw000arnq732oldox6","category_id":"cki1szjzv0007rnq74tej3gmi","_id":"cki1szk00000irnq78i0cg5u7"},{"post_id":"cki1szjzq0001rnq72p3te9xv","category_id":"cki1szjzv0007rnq74tej3gmi","_id":"cki1szk01000mrnq756727o5f"},{"post_id":"cki1szjzx000brnq7buqj97j9","category_id":"cki1szjzv0007rnq74tej3gmi","_id":"cki1szk02000ornq771hrasb2"},{"post_id":"cki1szjzu0004rnq7cwzg9n6n","category_id":"cki1szjzv0007rnq74tej3gmi","_id":"cki1szk02000rrnq73dk6e71w"},{"post_id":"cki1szjzu0005rnq7f7c46zbd","category_id":"cki1szk00000jrnq7dzqw97nz","_id":"cki1szk02000trnq7bbdf4t2o"},{"post_id":"cki1szjzv0006rnq7bgpbbdir","category_id":"cki1szk02000prnq72eabcaqw","_id":"cki1szk03000wrnq7h2hi0f1k"},{"post_id":"cki1szjzz000frnq71jivamv4","category_id":"cki1szk03000urnq7gku82efl","_id":"cki1szk040010rnq75xqdeavg"},{"post_id":"cki1szjzz000hrnq7fyjbcqgh","category_id":"cki1szk03000xrnq7cg7e10u0","_id":"cki1szk040014rnq7ayd317hu"},{"post_id":"cki1szk08001frnq7aobf9viw","category_id":"cki1szjzv0007rnq74tej3gmi","_id":"cki1szk0b001nrnq7eb9r00qe"},{"post_id":"cki1szk06001arnq7fbe2girz","category_id":"cki1szk07001crnq7ax9hbuip","_id":"cki1szk0b001rrnq7g89a41w1"},{"post_id":"cki1szk09001grnq77j2p1cji","category_id":"cki1szjzs0002rnq70kjy6s6u","_id":"cki1szk0c001srnq721e7axf0"},{"post_id":"cki1szk08001ernq70xbs03t7","category_id":"cki1szk07001crnq7ax9hbuip","_id":"cki1szk0c001urnq75vivea3e"},{"post_id":"cki1szk0a001mrnq7b2skdd5p","category_id":"cki1szjzv0007rnq74tej3gmi","_id":"cki1szk0c001wrnq7bef53yux"},{"post_id":"cki1szk0a001krnq7fgpb0jr9","category_id":"cki1szk0b001prnq78xkx15yt","_id":"cki1szk0c001yrnq7cz82gsqv"}],"PostTag":[{"post_id":"cki1szjzn0000rnq750akh49k","tag_id":"cki1szjzt0003rnq73m3v375o","_id":"cki1szjzw0009rnq7129parle"},{"post_id":"cki1szjzq0001rnq72p3te9xv","tag_id":"cki1szjzw0008rnq7gpae85b8","_id":"cki1szjzz000grnq73q6e6nny"},{"post_id":"cki1szjzu0004rnq7cwzg9n6n","tag_id":"cki1szjzx000ernq75gir06m6","_id":"cki1szk01000nrnq70tv9c3e7"},{"post_id":"cki1szjzu0005rnq7f7c46zbd","tag_id":"cki1szk01000krnq7464kag96","_id":"cki1szk02000srnq7cqagh9uc"},{"post_id":"cki1szjzv0006rnq7bgpbbdir","tag_id":"cki1szk02000qrnq75ig601ae","_id":"cki1szk03000zrnq70cdnht5c"},{"post_id":"cki1szjzv0006rnq7bgpbbdir","tag_id":"cki1szk03000vrnq7fmw9b14s","_id":"cki1szk040011rnq72nhzfzdj"},{"post_id":"cki1szjzw000arnq732oldox6","tag_id":"cki1szk03000yrnq7a7vc5z6x","_id":"cki1szk040013rnq7gmoh1lyr"},{"post_id":"cki1szjzx000brnq7buqj97j9","tag_id":"cki1szk040012rnq7fl86cbvf","_id":"cki1szk040016rnq7bm2ifvd4"},{"post_id":"cki1szjzz000frnq71jivamv4","tag_id":"cki1szk040015rnq78ej48352","_id":"cki1szk050018rnq770hp79rj"},{"post_id":"cki1szjzz000hrnq7fyjbcqgh","tag_id":"cki1szk040017rnq75feygvf7","_id":"cki1szk050019rnq710p11szv"},{"post_id":"cki1szk06001arnq7fbe2girz","tag_id":"cki1szk07001drnq74calcuiv","_id":"cki1szk0a001jrnq79pvddyna"},{"post_id":"cki1szk09001grnq77j2p1cji","tag_id":"cki1szjzt0003rnq73m3v375o","_id":"cki1szk0a001lrnq76154588q"},{"post_id":"cki1szk08001ernq70xbs03t7","tag_id":"cki1szk07001drnq74calcuiv","_id":"cki1szk0b001qrnq7gne68ljb"},{"post_id":"cki1szk08001frnq7aobf9viw","tag_id":"cki1szk0b001ornq7gbtdd40d","_id":"cki1szk0c001vrnq7fvm2hma8"},{"post_id":"cki1szk0a001krnq7fgpb0jr9","tag_id":"cki1szk0c001trnq70a1e5x85","_id":"cki1szk0c001zrnq74eow85zm"},{"post_id":"cki1szk0a001mrnq7b2skdd5p","tag_id":"cki1szk0c001xrnq79p9s29dx","_id":"cki1szk0d0020rnq76rbo68sg"}],"Tag":[{"name":"llvm","_id":"cki1szjzt0003rnq73m3v375o"},{"name":"java","_id":"cki1szjzw0008rnq7gpae85b8"},{"name":"nand2tetris","_id":"cki1szjzx000ernq75gir06m6"},{"name":"经济学","_id":"cki1szk01000krnq7464kag96"},{"name":"js","_id":"cki1szk02000qrnq75ig601ae"},{"name":"quickjs","_id":"cki1szk03000vrnq7fmw9b14s"},{"name":"design","_id":"cki1szk03000yrnq7a7vc5z6x"},{"name":"ukulele","_id":"cki1szk040012rnq7fl86cbvf"},{"name":"guide","_id":"cki1szk040015rnq78ej48352"},{"name":"software","_id":"cki1szk040017rnq75feygvf7"},{"name":"笔记","_id":"cki1szk07001drnq74calcuiv"},{"name":"econ","_id":"cki1szk0b001ornq7gbtdd40d"},{"name":"note","_id":"cki1szk0c001trnq70a1e5x85"},{"name":"scheme","_id":"cki1szk0c001xrnq79p9s29dx"}]}}