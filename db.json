{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"a9572525c1f1d3173570809d540c4bb882ad0f8c","modified":1593792672570},{"_id":"themes/hexo-theme-landscape/.gitignore","hash":"4c78c751a5bbca6b54ad06922947573c967d51c8","modified":1592144269438},{"_id":"themes/hexo-theme-landscape/.travis.yml","hash":"0f850b4da6ba203ddc399bd7ffd675ca4e3da791","modified":1592144269438},{"_id":"themes/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1592144269439},{"_id":"themes/hexo-theme-landscape/README.md","hash":"f723575f1243852b8bec9ba05004500b943e20f1","modified":1592144269439},{"_id":"themes/hexo-theme-landscape/_config.yml","hash":"33a60bb6efd5e8d61e25b893e5da145f34931a05","modified":1592145263657},{"_id":"themes/hexo-theme-landscape/package.json","hash":"c35345c642b4ec5287728d3a9e76f5fbeeb8b81c","modified":1592144269459},{"_id":"source/_drafts/homebrew.md","hash":"96e1252945cee7832bcd753a45f0af26b96e71c3","modified":1593704908800},{"_id":"source/_posts/llvm-0.md","hash":"5a2c53f42f4d93cf0784bf46836f6e6c6d958767","modified":1593704908802},{"_id":"source/_drafts/llvm-1.md","hash":"a3d357d2c87572313d8bdbe2fb46befd58ca4a03","modified":1593532241540},{"_id":"source/_posts/quickjs.md","hash":"1ab847357a7d28f1b0eaa8ae9a9be57d89d850ec","modified":1593704908803},{"_id":"source/_posts/hexo-guide.md","hash":"7286f2d3b2985d3169bcbad04206bd94f3d9ef47","modified":1593450610214},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1592138202203},{"_id":"source/images/logo.jpg","hash":"576d1ad1ad886e33802a1071f678ca8af6575823","modified":1592130886406},{"_id":"themes/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1592144269439},{"_id":"themes/hexo-theme-landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1592144269440},{"_id":"themes/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1592144269440},{"_id":"themes/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1592144269441},{"_id":"themes/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1592144269442},{"_id":"themes/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1592144269443},{"_id":"themes/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1592144269444},{"_id":"themes/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1592144269444},{"_id":"themes/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1592144269444},{"_id":"themes/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1592144269444},{"_id":"themes/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1592144269445},{"_id":"themes/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1592144269445},{"_id":"themes/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1592144269446},{"_id":"themes/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1592144269447},{"_id":"themes/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1592144269449},{"_id":"themes/hexo-theme-landscape/languages/zh-CN.yml","hash":"88c5beedec7042d388755278e3cd9f4296a6ed93","modified":1593270419541},{"_id":"themes/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1592144269457},{"_id":"themes/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1592144269458},{"_id":"themes/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1592144269458},{"_id":"themes/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1592144269458},{"_id":"themes/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1592144269458},{"_id":"themes/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1592144269459},{"_id":"themes/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1592144269459},{"_id":"themes/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1592144269459},{"_id":"themes/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1592144269450},{"_id":"themes/hexo-theme-landscape/layout/_partial/analytics.ejs","hash":"76b5b8caba94e6e9e5b876497d0874367908f388","modified":1592144269450},{"_id":"themes/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1592144269451},{"_id":"themes/hexo-theme-landscape/layout/_partial/article.ejs","hash":"551cd7cc595a48c5e6df774a39e1a4d2906c34d9","modified":1592145509699},{"_id":"themes/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1592144269451},{"_id":"themes/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"8488955d4a8e1459aff71eb6747f647663774b42","modified":1592145290321},{"_id":"themes/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1592144269451},{"_id":"themes/hexo-theme-landscape/layout/_partial/head.ejs","hash":"7c7c17e58292bd3e463a489b7ca70b7ae66242d3","modified":1592144269452},{"_id":"themes/hexo-theme-landscape/layout/_partial/header.ejs","hash":"997923d389ba294e89ce1d3a23b063b6e210a197","modified":1592144269452},{"_id":"themes/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1592144269452},{"_id":"themes/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1592144269454},{"_id":"themes/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1592144269455},{"_id":"themes/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1592144269455},{"_id":"themes/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1592144269455},{"_id":"themes/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1592144269455},{"_id":"themes/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1592144269456},{"_id":"themes/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1592144269460},{"_id":"themes/hexo-theme-landscape/source/css/_variables.styl","hash":"161b4bf70a9c74cb00d91a167728e677b2e00fd8","modified":1593152180147},{"_id":"themes/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1592144269479},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1592144269480},{"_id":"themes/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1592144269482},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1592144269480},{"_id":"themes/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1592144269481},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1592144269453},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1592144269453},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1592144269453},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1592144269453},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1592144269454},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"ab51fc70770d5409585686d4bccc68bfb3d1b7b4","modified":1592144269454},{"_id":"themes/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1592144269460},{"_id":"themes/hexo-theme-landscape/source/css/_partial/article.styl","hash":"f2fb2084784df43f699d9112987df9a47ac76ae5","modified":1592144269460},{"_id":"themes/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1592144269461},{"_id":"themes/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"b45dcda3db2daf4389a300c5865976e085bc938b","modified":1592144269461},{"_id":"themes/hexo-theme-landscape/source/css/_partial/header.styl","hash":"e74194d4aa2ed7350894fc69d204e5dfa1839aed","modified":1592144269461},{"_id":"themes/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1592144269461},{"_id":"themes/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1592144269461},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1592144269462},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1592144269462},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1592144269462},{"_id":"themes/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1592144269462},{"_id":"themes/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1592144269463},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1592144269475},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1592144269476},{"_id":"themes/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1592144269465},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1592144269469},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1592144269474},{"_id":"themes/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1592144269479},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1592144269471},{"_id":"public/2020/07/02/quickjs/index.html","hash":"88b2b005e05e4fae3da3ac0c9a0137eb1afbbb53","modified":1593792711661},{"_id":"public/2020/06/25/llvm-0/index.html","hash":"1c65cfdc7a0fee1f1723756aa5876a5d2983e93d","modified":1593792711661},{"_id":"public/2020/06/14/hexo-guide/index.html","hash":"7e201e36ad60a8e7af03376644f8b31f666c233b","modified":1593792711661},{"_id":"public/archives/index.html","hash":"24bcca1507c556db2571ba19179db7a9bfd3e13b","modified":1593792711661},{"_id":"public/archives/page/2/index.html","hash":"dda93f83d0eae833a23ffb86e8cfc9e238db56c2","modified":1593792711661},{"_id":"public/archives/2020/index.html","hash":"f6d2350f5208427c85307f52097bc5ccb79e2101","modified":1593792711661},{"_id":"public/archives/2020/page/2/index.html","hash":"3acce2c6e0231cf82c2814822592ccb737831cea","modified":1593792711661},{"_id":"public/archives/2020/06/index.html","hash":"81f2c488ed69b6a40092bc180ec812108d061a4f","modified":1593792711661},{"_id":"public/archives/2020/07/index.html","hash":"d15a573dcb4b462adc91259364961c6d06d75e3c","modified":1593792711661},{"_id":"public/categories/llvm/index.html","hash":"72e0b5b7cbc853a4d06deef92d9d98ca4f201d9c","modified":1593792711661},{"_id":"public/categories/js/index.html","hash":"081809eeefa63ebd03e2a2540f28d22e1c4f235c","modified":1593792711661},{"_id":"public/categories/guide/index.html","hash":"13192ea016e9c2c84e6cc40af28726f77bd3c55a","modified":1593792711661},{"_id":"public/index.html","hash":"0da25c3134677cf32318253d731806af3f17617b","modified":1593792711661},{"_id":"public/tags/llvm/index.html","hash":"c522d1f8232ee249ef7c38761e559b12474f6cd6","modified":1593792711661},{"_id":"public/tags/js/index.html","hash":"841d4b0c4f8b18170e98307f8cdc9efd5cd8ad32","modified":1593792711661},{"_id":"public/tags/quickjs/index.html","hash":"3c2cbc59dc0714abc303bbe128870afa7ddba79e","modified":1593792711661},{"_id":"public/tags/guide/index.html","hash":"d2d12ec010f95a23a5712e98edb38126a5ca0f33","modified":1593792711661},{"_id":"public/CNAME","hash":"a9572525c1f1d3173570809d540c4bb882ad0f8c","modified":1593792711661},{"_id":"public/images/logo.jpg","hash":"576d1ad1ad886e33802a1071f678ca8af6575823","modified":1593792711661},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1593792711661},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1593792711661},{"_id":"public/css/style.css","hash":"eb01cea578e3c9387b3dd903ecd78abe50acd0e6","modified":1593792711661},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1593792711661},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1593792711661},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1593792711661},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1593792711661},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1593792711661},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1593792711661},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1593792711661},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1593792711661},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1593792711661}],"Category":[{"name":"software","_id":"ckc6f138z00024njkbb6h2i3p"},{"name":"llvm","_id":"ckc6f139300054njk1nur8zqj"},{"name":"js","_id":"ckc6f139w000h4njk9aie5i4o"},{"name":"guide","_id":"ckc6f139z000j4njk4eaw41c9"}],"Data":[],"Page":[],"Post":[{"title":"homebrew国内安装指南","date":"2020-06-17T02:30:39.000Z","_content":"\n[Homebrew](https://brew.sh)是一款Mac上的包管理器，可以很方便的安装各种软件。\n\nfishshell:\n\n```\n# 安装brew\n/bin/bash -c (curl -fsSL https://gitee.com/lhtin/brew-install/raw/master/install.sh)\n\n# 修改源为gitee\ncd (brew --repo)\ngit remote set-url origin https://gitee.com/lhtin/brew.git\n\ncd (brew --repo)/Library/Taps/homebrew/homebrew-core\ngit remote set-url origin https://gitee.com/lhtin/homebrew-core.git\n\n# 安装了cask才有\ncd (brew --repo)/Library/Taps/homebrew/homebrew-cask\ngit remote set-url origin https://gitee.com/lhtin/homebrew-cask.git\n\n# 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址\n\n# 修改Bottles源\n## 中科大源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.ustc.edu.cn/homebrew-bottles\n## 清华源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\n```\n","source":"_drafts/homebrew.md","raw":"---\ntitle: homebrew国内安装指南\ndate: 2020-06-17 10:30:39\ncategories:\n- software\ntags:\n- software\n---\n\n[Homebrew](https://brew.sh)是一款Mac上的包管理器，可以很方便的安装各种软件。\n\nfishshell:\n\n```\n# 安装brew\n/bin/bash -c (curl -fsSL https://gitee.com/lhtin/brew-install/raw/master/install.sh)\n\n# 修改源为gitee\ncd (brew --repo)\ngit remote set-url origin https://gitee.com/lhtin/brew.git\n\ncd (brew --repo)/Library/Taps/homebrew/homebrew-core\ngit remote set-url origin https://gitee.com/lhtin/homebrew-core.git\n\n# 安装了cask才有\ncd (brew --repo)/Library/Taps/homebrew/homebrew-cask\ngit remote set-url origin https://gitee.com/lhtin/homebrew-cask.git\n\n# 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址\n\n# 修改Bottles源\n## 中科大源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.ustc.edu.cn/homebrew-bottles\n## 清华源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\n```\n","slug":"homebrew","published":0,"updated":"2020-07-02T15:48:28.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc6f138r00004njkdk7d2gp5","content":"<p><a href=\"https://brew.sh\" target=\"_blank\" rel=\"noopener\">Homebrew</a>是一款Mac上的包管理器，可以很方便的安装各种软件。</p>\n<p>fishshell:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装brew</span><br><span class=\"line\">&#x2F;bin&#x2F;bash -c (curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew-install&#x2F;raw&#x2F;master&#x2F;install.sh)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改源为gitee</span><br><span class=\"line\">cd (brew --repo)</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-core.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装了cask才有</span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-cask.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改Bottles源</span><br><span class=\"line\">## 中科大源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles</span><br><span class=\"line\">## 清华源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;homebrew-bottles</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://brew.sh\" target=\"_blank\" rel=\"noopener\">Homebrew</a>是一款Mac上的包管理器，可以很方便的安装各种软件。</p>\n<p>fishshell:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装brew</span><br><span class=\"line\">&#x2F;bin&#x2F;bash -c (curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew-install&#x2F;raw&#x2F;master&#x2F;install.sh)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改源为gitee</span><br><span class=\"line\">cd (brew --repo)</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-core.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装了cask才有</span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-cask.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改Bottles源</span><br><span class=\"line\">## 中科大源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles</span><br><span class=\"line\">## 清华源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;homebrew-bottles</span><br></pre></td></tr></table></figure>\n"},{"title":"学习LLVM第0篇：LLVM项目介绍","date":"2020-06-25T13:55:21.000Z","excerpt":"本文学习LLVM的第0篇文章，介绍LLVM项目的一些内容，包括如何构建命令行工具和本地文档、常用LLVM命令的使用。目的是为了后续研究LLVM作准备。","_content":"\n更全面的内容请直接参考[官方文档](https://llvm.org/docs)，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。\n\n\n\n## 编译项目\n\n1. 安装[CMake](https://cmake.org)、[Ninja](https://ninja-build.org)构建工具。\n   \n   这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。\n   \n2. 克隆LLVM仓库：`git clone https://github.com/llvm/llvm-project`\n\n   如果国内clone太慢，也可以使用Gitee提供的镜像仓库`https://gitee.com/mirrors/LLVM`（注意：镜像仓库目前每天同步一次，所以内容会有延后）\n\n3. 创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：`mkdir build`，然后进到构建目录： `cd build`\n\n4. 生成构建系统：`cmake -G Ninja -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\" ../llvm`\n\n   常用参数：\n\n   - `LLVM_ENABLE_PROJECTS`：比如`\"clang;libcxx\"`。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如`clang`、`clang-tools-extra`、`libcxx`、`libc`等。\n\n     小提示：所有支持的项目可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_PROJECTS`变量的内容。当前的内容为：`clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl`\n\n   - `LLVM_TARGETS_TO_BUILD`：比如`\"X86;RISCV\"`。指定LLVM后端支持的目标架构，比如`X86`、`ARM`、`RISCV`、`WebAssembly`\n\n     小提示：所有支持的目标架构可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_TARGETS`变量的内容。当前的内容为：`AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore`\n\n   - `LLVM_ENABLE_SPHINX`：是否编译LLVM文档。`ON`表示启动。依赖[Sphinx](https://www.sphinx-doc.org)\n\n   - `LLVM_ENABLE_DOXYGEN`：是否编译LLVM API文档。`ON`表示启动。依赖[Doxygen](https://www.doxygen.nl)\n\n5. 进行构建：\n\n   - `cmake --build .` 表示编译默认目标包括LLVM和`LLVM_ENABLE_PROJECTS`指定的项目\n\n   - `cmake --build . --target docs-llvm-html` 表示只编译LLVM文档\n\n     小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：`llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef`，这是一个警告，但是因为编译的时候指定了`-W`，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报`llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info`。目前我的解决办法是去掉`-W`之后单独执行：`sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html`。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。\n\n     更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。\n\n   - `cmake --build . --target doxygen-llvm` 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。\n   \n   小提示：1. 想要查看有哪些target可以去查看生成的`build/CMakeFiles/TargetDirectories.txt`文件。像这里的`doxygen-llvm`我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。\n\n将前面的命令放在一起方便拷贝：\n\n```shell\ngit clone https://github.com/llvm/llvm-project\n// Gitee源：git clone https://gitee.com/mirrors/LLVM\ncd llvm-project && mkdir build && cd build\ncmake -G Ninja\\\n  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\\n  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\\n  -DLLVM_ENABLE_SPHINX=ON\\\n  -DLLVM_ENABLE_DOXYGEN=ON\\\n  ../llvm\ncmake --build . // 编译llvm、clang、libcxx\ncmake --build . --target docs-llvm-html // 编译LLVM文档\ncmake --build . --target doxygen-llvm // 编译LLVM API文档\n```\n\n官方文档参考：\n\n- [Getting Started with the LLVM System](https://llvm.org/docs/GettingStarted.html)：介绍了编译项目的基本步骤，常用参数\n- [Building LLVM with CMake](https://llvm.org/docs/CMake.html)：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数\n\n\n\n## 常用LLVM命令\n\n- clang\n  - `clang -S -emit-llvm input.c -o out.ll`：生成人可读的LLVM IR\n  - `clang -c -emit-llvm input.c -o out.bc`：生成二进制LLVM IR，也可以不加`-c`，默认编译为二进制IR\n- [opt](https://llvm.org/docs/CommandGuide/opt.html)\n  - `opt -load-pass-plugin=libHelloWorld.dylib -passes=\"hello-world\" a.ll`：使用HelloWorld Pass对`out.ll`进行处理。注意这是新的单独调用Pass的方式，老的方式为：`opt -load libHelloWorld.dylib -legacy-hello-world a.ll`\n  - `opt -analyze -view-cfg a.ll` 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。\n- [llvm-as](https://llvm.org/docs/CommandGuide/llvm-as.html)、[llvm-dis](https://llvm.org/docs/CommandGuide/llvm-dis.html)\n  - `llvm-as a.ll -o a.bc`：将人可读的LLVM IR编译为二进制LLVM IR\n  - `llvm-dis a.bc -o a.ll`：将二进制LLVM IR反编译为人可读的LLVM IR\n- [llc](https://llvm.org/docs/CommandGuide/llc.html)\n  - `llc a.ll -o a.out`：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件\n- [lli](https://llvm.org/docs/CommandGuide/lli.html)\n  - `lli a.ll`：直接解释执行LLVM IR\n- [llvm-link](https://llvm.org/docs/CommandGuide/llvm-link.html)\n  - `llvm-link -S add.ll main.ll -o all.ll`：链接多个LLVM IR为一个LLVM IR文件，`-S`表示输出的为人可读的LLVM IR，默认为二进制LLVM IR\n- [llvm-config](https://llvm.org/docs/CommandGuide/llvm-config.html)：使用`llvm-config --help`查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。\n  - `llvm-config --cxxflags`：生成编译时的头文件库参数，比如在我电脑上会输出`-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS`\n  - `llvm-config --ldflags`：生成链接时的LLVM库文件地址，比如在我电脑上会输出`-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names`\n  - `llvm-config --libs`：生成LLVM提供的库名称，结合`llvm-config --ldflags`，就可以让链接器找到对应的库文件。在`--libs`后面还可以添加各种组件名称，不添加表示所有组件。比如`--libs core native`，则只会输出core和native组件相关的库。通过下面的`llvm-config --components`命令可以列举出所有的LLVM组件列表\n  - `llvm-config --components`：输出所有的LLVM组件\n\n官方文档参考：\n\n- [LLVM Command Guide](https://llvm.org/docs/CommandGuide/index.html)：命令行工具使用说明\n\n\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->","source":"_posts/llvm-0.md","raw":"---\ntitle: 学习LLVM第0篇：LLVM项目介绍\ndate: 2020-06-25 21:55:21\ncategories:\n- llvm\ntags:\n- llvm\nexcerpt: 本文学习LLVM的第0篇文章，介绍LLVM项目的一些内容，包括如何构建命令行工具和本地文档、常用LLVM命令的使用。目的是为了后续研究LLVM作准备。\n---\n\n更全面的内容请直接参考[官方文档](https://llvm.org/docs)，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。\n\n\n\n## 编译项目\n\n1. 安装[CMake](https://cmake.org)、[Ninja](https://ninja-build.org)构建工具。\n   \n   这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。\n   \n2. 克隆LLVM仓库：`git clone https://github.com/llvm/llvm-project`\n\n   如果国内clone太慢，也可以使用Gitee提供的镜像仓库`https://gitee.com/mirrors/LLVM`（注意：镜像仓库目前每天同步一次，所以内容会有延后）\n\n3. 创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：`mkdir build`，然后进到构建目录： `cd build`\n\n4. 生成构建系统：`cmake -G Ninja -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\" ../llvm`\n\n   常用参数：\n\n   - `LLVM_ENABLE_PROJECTS`：比如`\"clang;libcxx\"`。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如`clang`、`clang-tools-extra`、`libcxx`、`libc`等。\n\n     小提示：所有支持的项目可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_PROJECTS`变量的内容。当前的内容为：`clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl`\n\n   - `LLVM_TARGETS_TO_BUILD`：比如`\"X86;RISCV\"`。指定LLVM后端支持的目标架构，比如`X86`、`ARM`、`RISCV`、`WebAssembly`\n\n     小提示：所有支持的目标架构可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_TARGETS`变量的内容。当前的内容为：`AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore`\n\n   - `LLVM_ENABLE_SPHINX`：是否编译LLVM文档。`ON`表示启动。依赖[Sphinx](https://www.sphinx-doc.org)\n\n   - `LLVM_ENABLE_DOXYGEN`：是否编译LLVM API文档。`ON`表示启动。依赖[Doxygen](https://www.doxygen.nl)\n\n5. 进行构建：\n\n   - `cmake --build .` 表示编译默认目标包括LLVM和`LLVM_ENABLE_PROJECTS`指定的项目\n\n   - `cmake --build . --target docs-llvm-html` 表示只编译LLVM文档\n\n     小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：`llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef`，这是一个警告，但是因为编译的时候指定了`-W`，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报`llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info`。目前我的解决办法是去掉`-W`之后单独执行：`sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html`。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。\n\n     更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。\n\n   - `cmake --build . --target doxygen-llvm` 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。\n   \n   小提示：1. 想要查看有哪些target可以去查看生成的`build/CMakeFiles/TargetDirectories.txt`文件。像这里的`doxygen-llvm`我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。\n\n将前面的命令放在一起方便拷贝：\n\n```shell\ngit clone https://github.com/llvm/llvm-project\n// Gitee源：git clone https://gitee.com/mirrors/LLVM\ncd llvm-project && mkdir build && cd build\ncmake -G Ninja\\\n  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\\n  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\\n  -DLLVM_ENABLE_SPHINX=ON\\\n  -DLLVM_ENABLE_DOXYGEN=ON\\\n  ../llvm\ncmake --build . // 编译llvm、clang、libcxx\ncmake --build . --target docs-llvm-html // 编译LLVM文档\ncmake --build . --target doxygen-llvm // 编译LLVM API文档\n```\n\n官方文档参考：\n\n- [Getting Started with the LLVM System](https://llvm.org/docs/GettingStarted.html)：介绍了编译项目的基本步骤，常用参数\n- [Building LLVM with CMake](https://llvm.org/docs/CMake.html)：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数\n\n\n\n## 常用LLVM命令\n\n- clang\n  - `clang -S -emit-llvm input.c -o out.ll`：生成人可读的LLVM IR\n  - `clang -c -emit-llvm input.c -o out.bc`：生成二进制LLVM IR，也可以不加`-c`，默认编译为二进制IR\n- [opt](https://llvm.org/docs/CommandGuide/opt.html)\n  - `opt -load-pass-plugin=libHelloWorld.dylib -passes=\"hello-world\" a.ll`：使用HelloWorld Pass对`out.ll`进行处理。注意这是新的单独调用Pass的方式，老的方式为：`opt -load libHelloWorld.dylib -legacy-hello-world a.ll`\n  - `opt -analyze -view-cfg a.ll` 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。\n- [llvm-as](https://llvm.org/docs/CommandGuide/llvm-as.html)、[llvm-dis](https://llvm.org/docs/CommandGuide/llvm-dis.html)\n  - `llvm-as a.ll -o a.bc`：将人可读的LLVM IR编译为二进制LLVM IR\n  - `llvm-dis a.bc -o a.ll`：将二进制LLVM IR反编译为人可读的LLVM IR\n- [llc](https://llvm.org/docs/CommandGuide/llc.html)\n  - `llc a.ll -o a.out`：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件\n- [lli](https://llvm.org/docs/CommandGuide/lli.html)\n  - `lli a.ll`：直接解释执行LLVM IR\n- [llvm-link](https://llvm.org/docs/CommandGuide/llvm-link.html)\n  - `llvm-link -S add.ll main.ll -o all.ll`：链接多个LLVM IR为一个LLVM IR文件，`-S`表示输出的为人可读的LLVM IR，默认为二进制LLVM IR\n- [llvm-config](https://llvm.org/docs/CommandGuide/llvm-config.html)：使用`llvm-config --help`查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。\n  - `llvm-config --cxxflags`：生成编译时的头文件库参数，比如在我电脑上会输出`-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS`\n  - `llvm-config --ldflags`：生成链接时的LLVM库文件地址，比如在我电脑上会输出`-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names`\n  - `llvm-config --libs`：生成LLVM提供的库名称，结合`llvm-config --ldflags`，就可以让链接器找到对应的库文件。在`--libs`后面还可以添加各种组件名称，不添加表示所有组件。比如`--libs core native`，则只会输出core和native组件相关的库。通过下面的`llvm-config --components`命令可以列举出所有的LLVM组件列表\n  - `llvm-config --components`：输出所有的LLVM组件\n\n官方文档参考：\n\n- [LLVM Command Guide](https://llvm.org/docs/CommandGuide/index.html)：命令行工具使用说明\n\n\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->","slug":"llvm-0","published":1,"updated":"2020-07-02T15:48:28.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc6f138x00014njk595w1z4n","content":"<p>更全面的内容请直接参考<a href=\"https://llvm.org/docs\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。</p>\n<h2 id=\"编译项目\"><a href=\"#编译项目\" class=\"headerlink\" title=\"编译项目\"></a>编译项目</h2><ol>\n<li><p>安装<a href=\"https://cmake.org\" target=\"_blank\" rel=\"noopener\">CMake</a>、<a href=\"https://ninja-build.org\" target=\"_blank\" rel=\"noopener\">Ninja</a>构建工具。</p>\n<p>这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。</p>\n</li>\n<li><p>克隆LLVM仓库：<code>git clone https://github.com/llvm/llvm-project</code></p>\n<p>如果国内clone太慢，也可以使用Gitee提供的镜像仓库<code>https://gitee.com/mirrors/LLVM</code>（注意：镜像仓库目前每天同步一次，所以内容会有延后）</p>\n</li>\n<li><p>创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：<code>mkdir build</code>，然后进到构建目录： <code>cd build</code></p>\n</li>\n<li><p>生成构建系统：<code>cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot; ../llvm</code></p>\n<p>常用参数：</p>\n<ul>\n<li><p><code>LLVM_ENABLE_PROJECTS</code>：比如<code>&quot;clang;libcxx&quot;</code>。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如<code>clang</code>、<code>clang-tools-extra</code>、<code>libcxx</code>、<code>libc</code>等。</p>\n<p>小提示：所有支持的项目可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_PROJECTS</code>变量的内容。当前的内容为：<code>clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl</code></p>\n</li>\n<li><p><code>LLVM_TARGETS_TO_BUILD</code>：比如<code>&quot;X86;RISCV&quot;</code>。指定LLVM后端支持的目标架构，比如<code>X86</code>、<code>ARM</code>、<code>RISCV</code>、<code>WebAssembly</code></p>\n<p>小提示：所有支持的目标架构可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_TARGETS</code>变量的内容。当前的内容为：<code>AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore</code></p>\n</li>\n<li><p><code>LLVM_ENABLE_SPHINX</code>：是否编译LLVM文档。<code>ON</code>表示启动。依赖<a href=\"https://www.sphinx-doc.org\" target=\"_blank\" rel=\"noopener\">Sphinx</a></p>\n</li>\n<li><p><code>LLVM_ENABLE_DOXYGEN</code>：是否编译LLVM API文档。<code>ON</code>表示启动。依赖<a href=\"https://www.doxygen.nl\" target=\"_blank\" rel=\"noopener\">Doxygen</a></p>\n</li>\n</ul>\n</li>\n<li><p>进行构建：</p>\n<ul>\n<li><p><code>cmake --build .</code> 表示编译默认目标包括LLVM和<code>LLVM_ENABLE_PROJECTS</code>指定的项目</p>\n</li>\n<li><p><code>cmake --build . --target docs-llvm-html</code> 表示只编译LLVM文档</p>\n<p>小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：<code>llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef</code>，这是一个警告，但是因为编译的时候指定了<code>-W</code>，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报<code>llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info</code>。目前我的解决办法是去掉<code>-W</code>之后单独执行：<code>sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html</code>。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。</p>\n<p>更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。</p>\n</li>\n<li><p><code>cmake --build . --target doxygen-llvm</code> 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。</p>\n</li>\n</ul>\n<p>小提示：1. 想要查看有哪些target可以去查看生成的<code>build/CMakeFiles/TargetDirectories.txt</code>文件。像这里的<code>doxygen-llvm</code>我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。</p>\n</li>\n</ol>\n<p>将前面的命令放在一起方便拷贝：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/llvm/llvm-project</span><br><span class=\"line\">// Gitee源：git clone https://gitee.com/mirrors/LLVM</span><br><span class=\"line\">cd llvm-project &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class=\"line\">cmake -G Ninja\\</span><br><span class=\"line\">  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\</span><br><span class=\"line\">  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\</span><br><span class=\"line\">  -DLLVM_ENABLE_SPHINX=ON\\</span><br><span class=\"line\">  -DLLVM_ENABLE_DOXYGEN=ON\\</span><br><span class=\"line\">  ../llvm</span><br><span class=\"line\">cmake --build . // 编译llvm、clang、libcxx</span><br><span class=\"line\">cmake --build . --target docs-llvm-html // 编译LLVM文档</span><br><span class=\"line\">cmake --build . --target doxygen-llvm // 编译LLVM API文档</span><br></pre></td></tr></table></figure>\n\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/GettingStarted.html\" target=\"_blank\" rel=\"noopener\">Getting Started with the LLVM System</a>：介绍了编译项目的基本步骤，常用参数</li>\n<li><a href=\"https://llvm.org/docs/CMake.html\" target=\"_blank\" rel=\"noopener\">Building LLVM with CMake</a>：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数</li>\n</ul>\n<h2 id=\"常用LLVM命令\"><a href=\"#常用LLVM命令\" class=\"headerlink\" title=\"常用LLVM命令\"></a>常用LLVM命令</h2><ul>\n<li>clang<ul>\n<li><code>clang -S -emit-llvm input.c -o out.ll</code>：生成人可读的LLVM IR</li>\n<li><code>clang -c -emit-llvm input.c -o out.bc</code>：生成二进制LLVM IR，也可以不加<code>-c</code>，默认编译为二进制IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/opt.html\" target=\"_blank\" rel=\"noopener\">opt</a><ul>\n<li><code>opt -load-pass-plugin=libHelloWorld.dylib -passes=&quot;hello-world&quot; a.ll</code>：使用HelloWorld Pass对<code>out.ll</code>进行处理。注意这是新的单独调用Pass的方式，老的方式为：<code>opt -load libHelloWorld.dylib -legacy-hello-world a.ll</code></li>\n<li><code>opt -analyze -view-cfg a.ll</code> 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-as.html\" target=\"_blank\" rel=\"noopener\">llvm-as</a>、<a href=\"https://llvm.org/docs/CommandGuide/llvm-dis.html\" target=\"_blank\" rel=\"noopener\">llvm-dis</a><ul>\n<li><code>llvm-as a.ll -o a.bc</code>：将人可读的LLVM IR编译为二进制LLVM IR</li>\n<li><code>llvm-dis a.bc -o a.ll</code>：将二进制LLVM IR反编译为人可读的LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llc.html\" target=\"_blank\" rel=\"noopener\">llc</a><ul>\n<li><code>llc a.ll -o a.out</code>：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/lli.html\" target=\"_blank\" rel=\"noopener\">lli</a><ul>\n<li><code>lli a.ll</code>：直接解释执行LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-link.html\" target=\"_blank\" rel=\"noopener\">llvm-link</a><ul>\n<li><code>llvm-link -S add.ll main.ll -o all.ll</code>：链接多个LLVM IR为一个LLVM IR文件，<code>-S</code>表示输出的为人可读的LLVM IR，默认为二进制LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-config.html\" target=\"_blank\" rel=\"noopener\">llvm-config</a>：使用<code>llvm-config --help</code>查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。<ul>\n<li><code>llvm-config --cxxflags</code>：生成编译时的头文件库参数，比如在我电脑上会输出<code>-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS</code></li>\n<li><code>llvm-config --ldflags</code>：生成链接时的LLVM库文件地址，比如在我电脑上会输出<code>-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names</code></li>\n<li><code>llvm-config --libs</code>：生成LLVM提供的库名称，结合<code>llvm-config --ldflags</code>，就可以让链接器找到对应的库文件。在<code>--libs</code>后面还可以添加各种组件名称，不添加表示所有组件。比如<code>--libs core native</code>，则只会输出core和native组件相关的库。通过下面的<code>llvm-config --components</code>命令可以列举出所有的LLVM组件列表</li>\n<li><code>llvm-config --components</code>：输出所有的LLVM组件</li>\n</ul>\n</li>\n</ul>\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/CommandGuide/index.html\" target=\"_blank\" rel=\"noopener\">LLVM Command Guide</a>：命令行工具使用说明</li>\n</ul>\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->","site":{"data":{}},"more":"<p>更全面的内容请直接参考<a href=\"https://llvm.org/docs\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。</p>\n<h2 id=\"编译项目\"><a href=\"#编译项目\" class=\"headerlink\" title=\"编译项目\"></a>编译项目</h2><ol>\n<li><p>安装<a href=\"https://cmake.org\" target=\"_blank\" rel=\"noopener\">CMake</a>、<a href=\"https://ninja-build.org\" target=\"_blank\" rel=\"noopener\">Ninja</a>构建工具。</p>\n<p>这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。</p>\n</li>\n<li><p>克隆LLVM仓库：<code>git clone https://github.com/llvm/llvm-project</code></p>\n<p>如果国内clone太慢，也可以使用Gitee提供的镜像仓库<code>https://gitee.com/mirrors/LLVM</code>（注意：镜像仓库目前每天同步一次，所以内容会有延后）</p>\n</li>\n<li><p>创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：<code>mkdir build</code>，然后进到构建目录： <code>cd build</code></p>\n</li>\n<li><p>生成构建系统：<code>cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot; ../llvm</code></p>\n<p>常用参数：</p>\n<ul>\n<li><p><code>LLVM_ENABLE_PROJECTS</code>：比如<code>&quot;clang;libcxx&quot;</code>。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如<code>clang</code>、<code>clang-tools-extra</code>、<code>libcxx</code>、<code>libc</code>等。</p>\n<p>小提示：所有支持的项目可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_PROJECTS</code>变量的内容。当前的内容为：<code>clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl</code></p>\n</li>\n<li><p><code>LLVM_TARGETS_TO_BUILD</code>：比如<code>&quot;X86;RISCV&quot;</code>。指定LLVM后端支持的目标架构，比如<code>X86</code>、<code>ARM</code>、<code>RISCV</code>、<code>WebAssembly</code></p>\n<p>小提示：所有支持的目标架构可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_TARGETS</code>变量的内容。当前的内容为：<code>AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore</code></p>\n</li>\n<li><p><code>LLVM_ENABLE_SPHINX</code>：是否编译LLVM文档。<code>ON</code>表示启动。依赖<a href=\"https://www.sphinx-doc.org\" target=\"_blank\" rel=\"noopener\">Sphinx</a></p>\n</li>\n<li><p><code>LLVM_ENABLE_DOXYGEN</code>：是否编译LLVM API文档。<code>ON</code>表示启动。依赖<a href=\"https://www.doxygen.nl\" target=\"_blank\" rel=\"noopener\">Doxygen</a></p>\n</li>\n</ul>\n</li>\n<li><p>进行构建：</p>\n<ul>\n<li><p><code>cmake --build .</code> 表示编译默认目标包括LLVM和<code>LLVM_ENABLE_PROJECTS</code>指定的项目</p>\n</li>\n<li><p><code>cmake --build . --target docs-llvm-html</code> 表示只编译LLVM文档</p>\n<p>小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：<code>llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef</code>，这是一个警告，但是因为编译的时候指定了<code>-W</code>，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报<code>llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info</code>。目前我的解决办法是去掉<code>-W</code>之后单独执行：<code>sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html</code>。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。</p>\n<p>更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。</p>\n</li>\n<li><p><code>cmake --build . --target doxygen-llvm</code> 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。</p>\n</li>\n</ul>\n<p>小提示：1. 想要查看有哪些target可以去查看生成的<code>build/CMakeFiles/TargetDirectories.txt</code>文件。像这里的<code>doxygen-llvm</code>我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。</p>\n</li>\n</ol>\n<p>将前面的命令放在一起方便拷贝：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/llvm/llvm-project</span><br><span class=\"line\">// Gitee源：git clone https://gitee.com/mirrors/LLVM</span><br><span class=\"line\">cd llvm-project &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class=\"line\">cmake -G Ninja\\</span><br><span class=\"line\">  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\</span><br><span class=\"line\">  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\</span><br><span class=\"line\">  -DLLVM_ENABLE_SPHINX=ON\\</span><br><span class=\"line\">  -DLLVM_ENABLE_DOXYGEN=ON\\</span><br><span class=\"line\">  ../llvm</span><br><span class=\"line\">cmake --build . // 编译llvm、clang、libcxx</span><br><span class=\"line\">cmake --build . --target docs-llvm-html // 编译LLVM文档</span><br><span class=\"line\">cmake --build . --target doxygen-llvm // 编译LLVM API文档</span><br></pre></td></tr></table></figure>\n\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/GettingStarted.html\" target=\"_blank\" rel=\"noopener\">Getting Started with the LLVM System</a>：介绍了编译项目的基本步骤，常用参数</li>\n<li><a href=\"https://llvm.org/docs/CMake.html\" target=\"_blank\" rel=\"noopener\">Building LLVM with CMake</a>：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数</li>\n</ul>\n<h2 id=\"常用LLVM命令\"><a href=\"#常用LLVM命令\" class=\"headerlink\" title=\"常用LLVM命令\"></a>常用LLVM命令</h2><ul>\n<li>clang<ul>\n<li><code>clang -S -emit-llvm input.c -o out.ll</code>：生成人可读的LLVM IR</li>\n<li><code>clang -c -emit-llvm input.c -o out.bc</code>：生成二进制LLVM IR，也可以不加<code>-c</code>，默认编译为二进制IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/opt.html\" target=\"_blank\" rel=\"noopener\">opt</a><ul>\n<li><code>opt -load-pass-plugin=libHelloWorld.dylib -passes=&quot;hello-world&quot; a.ll</code>：使用HelloWorld Pass对<code>out.ll</code>进行处理。注意这是新的单独调用Pass的方式，老的方式为：<code>opt -load libHelloWorld.dylib -legacy-hello-world a.ll</code></li>\n<li><code>opt -analyze -view-cfg a.ll</code> 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-as.html\" target=\"_blank\" rel=\"noopener\">llvm-as</a>、<a href=\"https://llvm.org/docs/CommandGuide/llvm-dis.html\" target=\"_blank\" rel=\"noopener\">llvm-dis</a><ul>\n<li><code>llvm-as a.ll -o a.bc</code>：将人可读的LLVM IR编译为二进制LLVM IR</li>\n<li><code>llvm-dis a.bc -o a.ll</code>：将二进制LLVM IR反编译为人可读的LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llc.html\" target=\"_blank\" rel=\"noopener\">llc</a><ul>\n<li><code>llc a.ll -o a.out</code>：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/lli.html\" target=\"_blank\" rel=\"noopener\">lli</a><ul>\n<li><code>lli a.ll</code>：直接解释执行LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-link.html\" target=\"_blank\" rel=\"noopener\">llvm-link</a><ul>\n<li><code>llvm-link -S add.ll main.ll -o all.ll</code>：链接多个LLVM IR为一个LLVM IR文件，<code>-S</code>表示输出的为人可读的LLVM IR，默认为二进制LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-config.html\" target=\"_blank\" rel=\"noopener\">llvm-config</a>：使用<code>llvm-config --help</code>查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。<ul>\n<li><code>llvm-config --cxxflags</code>：生成编译时的头文件库参数，比如在我电脑上会输出<code>-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS</code></li>\n<li><code>llvm-config --ldflags</code>：生成链接时的LLVM库文件地址，比如在我电脑上会输出<code>-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names</code></li>\n<li><code>llvm-config --libs</code>：生成LLVM提供的库名称，结合<code>llvm-config --ldflags</code>，就可以让链接器找到对应的库文件。在<code>--libs</code>后面还可以添加各种组件名称，不添加表示所有组件。比如<code>--libs core native</code>，则只会输出core和native组件相关的库。通过下面的<code>llvm-config --components</code>命令可以列举出所有的LLVM组件列表</li>\n<li><code>llvm-config --components</code>：输出所有的LLVM组件</li>\n</ul>\n</li>\n</ul>\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/CommandGuide/index.html\" target=\"_blank\" rel=\"noopener\">LLVM Command Guide</a>：命令行工具使用说明</li>\n</ul>\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->"},{"title":"学习LLVM第1篇：官方入门教程","date":"2020-06-29T14:54:27.000Z","excerpt":"本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。","_content":"\n\n\n官方教程地址：https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\n\n\n## 简介\n\n这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。\n\n教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。\n\n如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。\n\n\n\n## 每个章节详解\n\n下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。\n\n### 第1、2章\n\n实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。\n\n词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。\n\n语法解析部分使用了自顶向下的递归下降语法分析方法（[Recursive Descent Parsing](http://en.wikipedia.org/wiki/Recursive_descent_parser)），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。\n\n不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（[Operator-Precedence Parsing](http://en.wikipedia.org/wiki/Operator-precedence_parser)）。具体的原理大概是这样子的，比如对于`a + b * c`表达式，`+`的优先级为10，`*`的优先级为20。在解析到`+`号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后在解析`+`号。具体到这个例子，`*`号的优先级比`+`号的高，所以在解析到`a + b`的时候，并不是先解析成表达式之后在继续解析后面的，而是继续判断后面的`*`号是否优先级更好。因为`*`号的优先级较高，所以会让`a +`先等着，先解析`b * c`，得到一个表达式后作为一个操作数，然后回来解析`a + expr`。\n\n语言BNF定义如下：\n\n```\nProgram \t\t\t-> FunDef | ExternFun | TopLevelExpr\nFunDef \t\t\t\t-> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\nExternFun \t\t-> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs \t\t-> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr \t\t\t\t\t-> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\nOp \t\t\t\t\t\t-> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs \t\t-> ε | ident | ident \",\" ActualArgs\nident \t\t\t\t-> [a-zA-Z][a-zA-Z0-9]*\nnum \t\t\t\t\t-> [0-9.]+\ncomment \t\t\t-> \"#\" [^\\n\\r]*\n```\n\n示例代码：\n\n```\nextern sin(arg); # 外部函数\nsin(1);\n\ndef f (a b c)\n  a + (b * c);\nadd(1, 2, 3);\n```\n\n\n\n### 第3章\n\n这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。\n\n\n\n## 遇到的问题\n\n- 第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给`--libs`增加`orcjit`参数\n  - 原来：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native`\n  - 改为：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit` \n  - 或者直接改为`all`：`llvm-config --cxxflags --ldflags --system-libs --libs all`\n\n","source":"_drafts/llvm-1.md","raw":"---\ntitle: 学习LLVM第1篇：官方入门教程\ndate: 2020-06-29 22:54:27\ncategories:\n- llvm\ntags:\n- llvm\nexcerpt: 本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。\n---\n\n\n\n官方教程地址：https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\n\n\n## 简介\n\n这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。\n\n教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。\n\n如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。\n\n\n\n## 每个章节详解\n\n下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。\n\n### 第1、2章\n\n实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。\n\n词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。\n\n语法解析部分使用了自顶向下的递归下降语法分析方法（[Recursive Descent Parsing](http://en.wikipedia.org/wiki/Recursive_descent_parser)），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。\n\n不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（[Operator-Precedence Parsing](http://en.wikipedia.org/wiki/Operator-precedence_parser)）。具体的原理大概是这样子的，比如对于`a + b * c`表达式，`+`的优先级为10，`*`的优先级为20。在解析到`+`号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后在解析`+`号。具体到这个例子，`*`号的优先级比`+`号的高，所以在解析到`a + b`的时候，并不是先解析成表达式之后在继续解析后面的，而是继续判断后面的`*`号是否优先级更好。因为`*`号的优先级较高，所以会让`a +`先等着，先解析`b * c`，得到一个表达式后作为一个操作数，然后回来解析`a + expr`。\n\n语言BNF定义如下：\n\n```\nProgram \t\t\t-> FunDef | ExternFun | TopLevelExpr\nFunDef \t\t\t\t-> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\nExternFun \t\t-> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs \t\t-> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr \t\t\t\t\t-> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\nOp \t\t\t\t\t\t-> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs \t\t-> ε | ident | ident \",\" ActualArgs\nident \t\t\t\t-> [a-zA-Z][a-zA-Z0-9]*\nnum \t\t\t\t\t-> [0-9.]+\ncomment \t\t\t-> \"#\" [^\\n\\r]*\n```\n\n示例代码：\n\n```\nextern sin(arg); # 外部函数\nsin(1);\n\ndef f (a b c)\n  a + (b * c);\nadd(1, 2, 3);\n```\n\n\n\n### 第3章\n\n这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。\n\n\n\n## 遇到的问题\n\n- 第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给`--libs`增加`orcjit`参数\n  - 原来：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native`\n  - 改为：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit` \n  - 或者直接改为`all`：`llvm-config --cxxflags --ldflags --system-libs --libs all`\n\n","slug":"llvm-1","published":0,"updated":"2020-06-30T15:50:41.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc6f139100044njkcbvy0iuo","content":"<p>官方教程地址：<a href=\"https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\" target=\"_blank\" rel=\"noopener\">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。</p>\n<p>教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。</p>\n<p>如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。</p>\n<h2 id=\"每个章节详解\"><a href=\"#每个章节详解\" class=\"headerlink\" title=\"每个章节详解\"></a>每个章节详解</h2><p>下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。</p>\n<h3 id=\"第1、2章\"><a href=\"#第1、2章\" class=\"headerlink\" title=\"第1、2章\"></a>第1、2章</h3><p>实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。</p>\n<p>词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。</p>\n<p>语法解析部分使用了自顶向下的递归下降语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Recursive_descent_parser\" target=\"_blank\" rel=\"noopener\">Recursive Descent Parsing</a>），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。</p>\n<p>不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Operator-precedence_parser\" target=\"_blank\" rel=\"noopener\">Operator-Precedence Parsing</a>）。具体的原理大概是这样子的，比如对于<code>a + b * c</code>表达式，<code>+</code>的优先级为10，<code>*</code>的优先级为20。在解析到<code>+</code>号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后在解析<code>+</code>号。具体到这个例子，<code>*</code>号的优先级比<code>+</code>号的高，所以在解析到<code>a + b</code>的时候，并不是先解析成表达式之后在继续解析后面的，而是继续判断后面的<code>*</code>号是否优先级更好。因为<code>*</code>号的优先级较高，所以会让<code>a +</code>先等着，先解析<code>b * c</code>，得到一个表达式后作为一个操作数，然后回来解析<code>a + expr</code>。</p>\n<p>语言BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program \t\t\t-&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef \t\t\t\t-&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">ExternFun \t\t-&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs \t\t-&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr \t\t\t\t\t-&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">Op \t\t\t\t\t\t-&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs \t\t-&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident \t\t\t\t-&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num \t\t\t\t\t-&gt; [0-9.]+</span><br><span class=\"line\">comment \t\t\t-&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern sin(arg); # 外部函数</span><br><span class=\"line\">sin(1);</span><br><span class=\"line\"></span><br><span class=\"line\">def f (a b c)</span><br><span class=\"line\">  a + (b * c);</span><br><span class=\"line\">add(1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第3章\"><a href=\"#第3章\" class=\"headerlink\" title=\"第3章\"></a>第3章</h3><p>这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给<code>--libs</code>增加<code>orcjit</code>参数<ul>\n<li>原来：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native</code></li>\n<li>改为：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit</code> </li>\n<li>或者直接改为<code>all</code>：<code>llvm-config --cxxflags --ldflags --system-libs --libs all</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"more":"<p>官方教程地址：<a href=\"https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\" target=\"_blank\" rel=\"noopener\">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。</p>\n<p>教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。</p>\n<p>如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。</p>\n<h2 id=\"每个章节详解\"><a href=\"#每个章节详解\" class=\"headerlink\" title=\"每个章节详解\"></a>每个章节详解</h2><p>下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。</p>\n<h3 id=\"第1、2章\"><a href=\"#第1、2章\" class=\"headerlink\" title=\"第1、2章\"></a>第1、2章</h3><p>实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。</p>\n<p>词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。</p>\n<p>语法解析部分使用了自顶向下的递归下降语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Recursive_descent_parser\" target=\"_blank\" rel=\"noopener\">Recursive Descent Parsing</a>），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。</p>\n<p>不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Operator-precedence_parser\" target=\"_blank\" rel=\"noopener\">Operator-Precedence Parsing</a>）。具体的原理大概是这样子的，比如对于<code>a + b * c</code>表达式，<code>+</code>的优先级为10，<code>*</code>的优先级为20。在解析到<code>+</code>号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后在解析<code>+</code>号。具体到这个例子，<code>*</code>号的优先级比<code>+</code>号的高，所以在解析到<code>a + b</code>的时候，并不是先解析成表达式之后在继续解析后面的，而是继续判断后面的<code>*</code>号是否优先级更好。因为<code>*</code>号的优先级较高，所以会让<code>a +</code>先等着，先解析<code>b * c</code>，得到一个表达式后作为一个操作数，然后回来解析<code>a + expr</code>。</p>\n<p>语言BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program \t\t\t-&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef \t\t\t\t-&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">ExternFun \t\t-&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs \t\t-&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr \t\t\t\t\t-&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">Op \t\t\t\t\t\t-&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs \t\t-&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident \t\t\t\t-&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num \t\t\t\t\t-&gt; [0-9.]+</span><br><span class=\"line\">comment \t\t\t-&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern sin(arg); # 外部函数</span><br><span class=\"line\">sin(1);</span><br><span class=\"line\"></span><br><span class=\"line\">def f (a b c)</span><br><span class=\"line\">  a + (b * c);</span><br><span class=\"line\">add(1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第3章\"><a href=\"#第3章\" class=\"headerlink\" title=\"第3章\"></a>第3章</h3><p>这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给<code>--libs</code>增加<code>orcjit</code>参数<ul>\n<li>原来：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native</code></li>\n<li>改为：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit</code> </li>\n<li>或者直接改为<code>all</code>：<code>llvm-config --cxxflags --ldflags --system-libs --libs all</code></li>\n</ul>\n</li>\n</ul>\n"},{"title":"6月7日在OSDT线上技术讨论会上的分享视频","date":"2020-07-02T05:03:13.000Z","excerpt":"按：我在6月7日报名参加了OSDT线上技术讨论会，做了以《QuickJS架构及源代码分析》为主题的直播分享。本文用于记录一下相关的资源，包括分享视频、PPT、代码注释和笔记等。","_content":"\n- 分享视频B站地址：\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=1 （重新录的，时长48分钟）\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=2 （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）\n- 对QuickJS做的一些代码注释、笔记、流程图等资料：https://gitee.com/lhtin/quickjs\n- 分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\n\n","source":"_posts/quickjs.md","raw":"---\ntitle: 6月7日在OSDT线上技术讨论会上的分享视频\ndate: 2020-07-02 13:03:13\ncategories:\n- js\ntags:\n- js\n- quickjs\nexcerpt: 按：我在6月7日报名参加了OSDT线上技术讨论会，做了以《QuickJS架构及源代码分析》为主题的直播分享。本文用于记录一下相关的资源，包括分享视频、PPT、代码注释和笔记等。\n---\n\n- 分享视频B站地址：\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=1 （重新录的，时长48分钟）\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=2 （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）\n- 对QuickJS做的一些代码注释、笔记、流程图等资料：https://gitee.com/lhtin/quickjs\n- 分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\n\n","slug":"quickjs","published":1,"updated":"2020-07-02T15:48:28.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc6f139s000f4njkehjlgfgu","content":"<ul>\n<li>分享视频B站地址：<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=1\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=1</a> （重新录的，时长48分钟）</li>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=2\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=2</a> （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）</li>\n</ul>\n</li>\n<li>对QuickJS做的一些代码注释、笔记、流程图等资料：<a href=\"https://gitee.com/lhtin/quickjs\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs</a></li>\n<li>分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：<a href=\"https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf</a></li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li>分享视频B站地址：<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=1\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=1</a> （重新录的，时长48分钟）</li>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=2\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=2</a> （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）</li>\n</ul>\n</li>\n<li>对QuickJS做的一些代码注释、笔记、流程图等资料：<a href=\"https://gitee.com/lhtin/quickjs\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs</a></li>\n<li>分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：<a href=\"https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf</a></li>\n</ul>\n"},{"title":"本站建造过程记录","comments":1,"date":"2020-06-13T16:00:00.000Z","excerpt":"本文详细记录了使用Hexo创建静态博客的过程。","_content":"\n本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。\n\n## 使用Gitee Pages服务\n\n在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是[lhtin](https://gitee.com/lhtin)，仓库名也为[lhtin](https://gitee.com/lhtin/lhtin)，这样就可以直接通过 https://lhtin.gitee.io 访问，而不需要加上仓库的名称作为访问的路径（ https://lhtin.gitee.io/lhtin ）。\n\n创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考[官方指南](https://gitee.com/help/articles/4136)。这样静态服务器就有了。\n\n## 使用Hexo博客框架\n\n为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。\n\n### 初始化博客项目\n\n首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：\n\n```shell\nnpm install -g hexo-cli\n\nhexo init <name>\n\ncd <name>\nnpm install\n```\n\n执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：\n\n```shell\nnpm run server // 启动本地server\nnpm run build // 将项目打包成静态文件，存放在public目录\nnpm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置\n\nhexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中\n```\n\n更多指南请前往[Hexo官方文档](https://hexo.io/zh-cn/docs)。\n\n### 根据需要修改配置\n\n在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见[官方文档-配置](https://hexo.io/zh-cn/docs/configuration)）：\n\n```yml\n# 项目根目录下的_config.yml文件\ntitle: 01的世界\nsubtitle: 计算机的世界没有秘密\ndescription: 这里有关于计算机的方方面面\nkeywords: 01的世界\nauthor: 钉子哥\nlanguage: zh-CN # 会影响主题中的语言选择\ntimezone: Asia/Shanghai\n\n// 本博客部署的地址\nurl: https://lhtin.gitee.io\nroot: /\n```\n\n然后还需要根据我自己的要求，修改默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的部分内容。所有修改的内容可以参见我fork出来的[仓库](https://gitee.com/lhtin/hexo-theme-landscape)。这里我列出主要的修改：\n\n- 将一些英文翻译为中文，比如Home -> 首页，Read More -> 阅读全文\n- 去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag\n- 添加百度统计，并和Google统计合并到一个ejs文件\n- 去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期\n- 去掉右上角的导航，固定展示为“首页”\n- 修改首页展示文章摘抄的样式\n\n### 构建和部署\n\n当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的[ejs模版](https://ejs.co)，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。\n\n生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。\n\n```yml\n# 项目根目录下的_config.yml文件\ndeploy:\n  type: git\n  repo: https://gitee.com/lhtin/lhtin.git\n  branch: page\n```\n\n构建和部署的命令如下：\n\n```\nnpm run build\nnpm install --save-dev hexo-deployer-git\nnpm run deploy\n```\n\n因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：\n\n```json\n{\n  \"scripts\": {\n    \"d\": \"npm run clean && npm run build && npm run deploy\"\n  }\n}\n```\n\n这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。~~或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。~~目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加[gitee](https://www.npmjs.com/package/gitee)这个npm模块。","source":"_posts/hexo-guide.md","raw":"---\ntitle: 本站建造过程记录\ncomments: true\ndate: 2020/06/14\ntag:\n- guide\ncategory:\n- guide\nexcerpt: 本文详细记录了使用Hexo创建静态博客的过程。\n---\n\n本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。\n\n## 使用Gitee Pages服务\n\n在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是[lhtin](https://gitee.com/lhtin)，仓库名也为[lhtin](https://gitee.com/lhtin/lhtin)，这样就可以直接通过 https://lhtin.gitee.io 访问，而不需要加上仓库的名称作为访问的路径（ https://lhtin.gitee.io/lhtin ）。\n\n创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考[官方指南](https://gitee.com/help/articles/4136)。这样静态服务器就有了。\n\n## 使用Hexo博客框架\n\n为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。\n\n### 初始化博客项目\n\n首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：\n\n```shell\nnpm install -g hexo-cli\n\nhexo init <name>\n\ncd <name>\nnpm install\n```\n\n执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：\n\n```shell\nnpm run server // 启动本地server\nnpm run build // 将项目打包成静态文件，存放在public目录\nnpm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置\n\nhexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中\n```\n\n更多指南请前往[Hexo官方文档](https://hexo.io/zh-cn/docs)。\n\n### 根据需要修改配置\n\n在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见[官方文档-配置](https://hexo.io/zh-cn/docs/configuration)）：\n\n```yml\n# 项目根目录下的_config.yml文件\ntitle: 01的世界\nsubtitle: 计算机的世界没有秘密\ndescription: 这里有关于计算机的方方面面\nkeywords: 01的世界\nauthor: 钉子哥\nlanguage: zh-CN # 会影响主题中的语言选择\ntimezone: Asia/Shanghai\n\n// 本博客部署的地址\nurl: https://lhtin.gitee.io\nroot: /\n```\n\n然后还需要根据我自己的要求，修改默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的部分内容。所有修改的内容可以参见我fork出来的[仓库](https://gitee.com/lhtin/hexo-theme-landscape)。这里我列出主要的修改：\n\n- 将一些英文翻译为中文，比如Home -> 首页，Read More -> 阅读全文\n- 去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag\n- 添加百度统计，并和Google统计合并到一个ejs文件\n- 去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期\n- 去掉右上角的导航，固定展示为“首页”\n- 修改首页展示文章摘抄的样式\n\n### 构建和部署\n\n当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的[ejs模版](https://ejs.co)，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。\n\n生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。\n\n```yml\n# 项目根目录下的_config.yml文件\ndeploy:\n  type: git\n  repo: https://gitee.com/lhtin/lhtin.git\n  branch: page\n```\n\n构建和部署的命令如下：\n\n```\nnpm run build\nnpm install --save-dev hexo-deployer-git\nnpm run deploy\n```\n\n因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：\n\n```json\n{\n  \"scripts\": {\n    \"d\": \"npm run clean && npm run build && npm run deploy\"\n  }\n}\n```\n\n这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。~~或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。~~目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加[gitee](https://www.npmjs.com/package/gitee)这个npm模块。","slug":"hexo-guide","published":1,"updated":"2020-06-29T17:10:10.214Z","layout":"post","photos":[],"link":"","_id":"ckc6f139u000g4njk95c3c7z1","content":"<p>本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。</p>\n<h2 id=\"使用Gitee-Pages服务\"><a href=\"#使用Gitee-Pages服务\" class=\"headerlink\" title=\"使用Gitee Pages服务\"></a>使用Gitee Pages服务</h2><p>在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是<a href=\"https://gitee.com/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，仓库名也为<a href=\"https://gitee.com/lhtin/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，这样就可以直接通过 <a href=\"https://lhtin.gitee.io\">https://lhtin.gitee.io</a> 访问，而不需要加上仓库的名称作为访问的路径（ <a href=\"https://lhtin.gitee.io/lhtin\">https://lhtin.gitee.io/lhtin</a> ）。</p>\n<p>创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考<a href=\"https://gitee.com/help/articles/4136\" target=\"_blank\" rel=\"noopener\">官方指南</a>。这样静态服务器就有了。</p>\n<h2 id=\"使用Hexo博客框架\"><a href=\"#使用Hexo博客框架\" class=\"headerlink\" title=\"使用Hexo博客框架\"></a>使用Hexo博客框架</h2><p>为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。</p>\n<h3 id=\"初始化博客项目\"><a href=\"#初始化博客项目\" class=\"headerlink\" title=\"初始化博客项目\"></a>初始化博客项目</h3><p>首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cd &lt;name&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run server // 启动本地server</span><br><span class=\"line\">npm run build // 将项目打包成静态文件，存放在public目录</span><br><span class=\"line\">npm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中</span><br></pre></td></tr></table></figure>\n\n<p>更多指南请前往<a href=\"https://hexo.io/zh-cn/docs\" target=\"_blank\" rel=\"noopener\">Hexo官方文档</a>。</p>\n<h3 id=\"根据需要修改配置\"><a href=\"#根据需要修改配置\" class=\"headerlink\" title=\"根据需要修改配置\"></a>根据需要修改配置</h3><p>在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">官方文档-配置</a>）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">计算机的世界没有秘密</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">这里有关于计算机的方方面面</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">钉子哥</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span> <span class=\"comment\"># 会影响主题中的语言选择</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span> <span class=\"string\">本博客部署的地址</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://lhtin.gitee.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>然后还需要根据我自己的要求，修改默认主题<a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">landscape</a>的部分内容。所有修改的内容可以参见我fork出来的<a href=\"https://gitee.com/lhtin/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">仓库</a>。这里我列出主要的修改：</p>\n<ul>\n<li>将一些英文翻译为中文，比如Home -&gt; 首页，Read More -&gt; 阅读全文</li>\n<li>去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag</li>\n<li>添加百度统计，并和Google统计合并到一个ejs文件</li>\n<li>去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期</li>\n<li>去掉右上角的导航，固定展示为“首页”</li>\n<li>修改首页展示文章摘抄的样式</li>\n</ul>\n<h3 id=\"构建和部署\"><a href=\"#构建和部署\" class=\"headerlink\" title=\"构建和部署\"></a>构建和部署</h3><p>当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的<a href=\"https://ejs.co\" target=\"_blank\" rel=\"noopener\">ejs模版</a>，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。</p>\n<p>生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gitee.com/lhtin/lhtin.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">page</span></span><br></pre></td></tr></table></figure>\n\n<p>构建和部署的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br><span class=\"line\">npm install --save-dev hexo-deployer-git</span><br><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"d\"</span>: <span class=\"string\">\"npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。<del>或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。</del>目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加<a href=\"https://www.npmjs.com/package/gitee\" target=\"_blank\" rel=\"noopener\">gitee</a>这个npm模块。</p>\n","site":{"data":{}},"more":"<p>本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。</p>\n<h2 id=\"使用Gitee-Pages服务\"><a href=\"#使用Gitee-Pages服务\" class=\"headerlink\" title=\"使用Gitee Pages服务\"></a>使用Gitee Pages服务</h2><p>在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是<a href=\"https://gitee.com/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，仓库名也为<a href=\"https://gitee.com/lhtin/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，这样就可以直接通过 <a href=\"https://lhtin.gitee.io\">https://lhtin.gitee.io</a> 访问，而不需要加上仓库的名称作为访问的路径（ <a href=\"https://lhtin.gitee.io/lhtin\">https://lhtin.gitee.io/lhtin</a> ）。</p>\n<p>创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考<a href=\"https://gitee.com/help/articles/4136\" target=\"_blank\" rel=\"noopener\">官方指南</a>。这样静态服务器就有了。</p>\n<h2 id=\"使用Hexo博客框架\"><a href=\"#使用Hexo博客框架\" class=\"headerlink\" title=\"使用Hexo博客框架\"></a>使用Hexo博客框架</h2><p>为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。</p>\n<h3 id=\"初始化博客项目\"><a href=\"#初始化博客项目\" class=\"headerlink\" title=\"初始化博客项目\"></a>初始化博客项目</h3><p>首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cd &lt;name&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run server // 启动本地server</span><br><span class=\"line\">npm run build // 将项目打包成静态文件，存放在public目录</span><br><span class=\"line\">npm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中</span><br></pre></td></tr></table></figure>\n\n<p>更多指南请前往<a href=\"https://hexo.io/zh-cn/docs\" target=\"_blank\" rel=\"noopener\">Hexo官方文档</a>。</p>\n<h3 id=\"根据需要修改配置\"><a href=\"#根据需要修改配置\" class=\"headerlink\" title=\"根据需要修改配置\"></a>根据需要修改配置</h3><p>在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">官方文档-配置</a>）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">计算机的世界没有秘密</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">这里有关于计算机的方方面面</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">钉子哥</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span> <span class=\"comment\"># 会影响主题中的语言选择</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span> <span class=\"string\">本博客部署的地址</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://lhtin.gitee.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>然后还需要根据我自己的要求，修改默认主题<a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">landscape</a>的部分内容。所有修改的内容可以参见我fork出来的<a href=\"https://gitee.com/lhtin/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">仓库</a>。这里我列出主要的修改：</p>\n<ul>\n<li>将一些英文翻译为中文，比如Home -&gt; 首页，Read More -&gt; 阅读全文</li>\n<li>去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag</li>\n<li>添加百度统计，并和Google统计合并到一个ejs文件</li>\n<li>去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期</li>\n<li>去掉右上角的导航，固定展示为“首页”</li>\n<li>修改首页展示文章摘抄的样式</li>\n</ul>\n<h3 id=\"构建和部署\"><a href=\"#构建和部署\" class=\"headerlink\" title=\"构建和部署\"></a>构建和部署</h3><p>当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的<a href=\"https://ejs.co\" target=\"_blank\" rel=\"noopener\">ejs模版</a>，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。</p>\n<p>生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gitee.com/lhtin/lhtin.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">page</span></span><br></pre></td></tr></table></figure>\n\n<p>构建和部署的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br><span class=\"line\">npm install --save-dev hexo-deployer-git</span><br><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"d\"</span>: <span class=\"string\">\"npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。<del>或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。</del>目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加<a href=\"https://www.npmjs.com/package/gitee\" target=\"_blank\" rel=\"noopener\">gitee</a>这个npm模块。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckc6f138r00004njkdk7d2gp5","category_id":"ckc6f138z00024njkbb6h2i3p","_id":"ckc6f139500084njk1otncmth"},{"post_id":"ckc6f138x00014njk595w1z4n","category_id":"ckc6f139300054njk1nur8zqj","_id":"ckc6f1398000c4njk6hyf9a4h"},{"post_id":"ckc6f139100044njkcbvy0iuo","category_id":"ckc6f139300054njk1nur8zqj","_id":"ckc6f1398000e4njkejrsg7wv"},{"post_id":"ckc6f139s000f4njkehjlgfgu","category_id":"ckc6f139w000h4njk9aie5i4o","_id":"ckc6f13a2000l4njk9pr9gacz"},{"post_id":"ckc6f139u000g4njk95c3c7z1","category_id":"ckc6f139z000j4njk4eaw41c9","_id":"ckc6f13a3000p4njkdws30l2e"}],"PostTag":[{"post_id":"ckc6f138r00004njkdk7d2gp5","tag_id":"ckc6f139000034njkd7628yow","_id":"ckc6f139500074njk6ssta7wr"},{"post_id":"ckc6f138x00014njk595w1z4n","tag_id":"ckc6f139400064njk9stzdoc3","_id":"ckc6f1397000b4njkhj45cqcg"},{"post_id":"ckc6f139100044njkcbvy0iuo","tag_id":"ckc6f139400064njk9stzdoc3","_id":"ckc6f1398000d4njk7ifs1od7"},{"post_id":"ckc6f139s000f4njkehjlgfgu","tag_id":"ckc6f139w000i4njk8tbxeceu","_id":"ckc6f13a3000n4njkeq9r1jzf"},{"post_id":"ckc6f139s000f4njkehjlgfgu","tag_id":"ckc6f13a0000k4njk8r1x7bic","_id":"ckc6f13a3000o4njkb4qo2510"},{"post_id":"ckc6f139u000g4njk95c3c7z1","tag_id":"ckc6f13a2000m4njkdv1t8otp","_id":"ckc6f13a4000q4njk14js794u"}],"Tag":[{"name":"software","_id":"ckc6f139000034njkd7628yow"},{"name":"llvm","_id":"ckc6f139400064njk9stzdoc3"},{"name":"js","_id":"ckc6f139w000i4njk8tbxeceu"},{"name":"quickjs","_id":"ckc6f13a0000k4njk8r1x7bic"},{"name":"guide","_id":"ckc6f13a2000m4njkdv1t8otp"}]}}