{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":1,"renderable":0},{"_id":"source/images/nand2tetris-1/CPU.png","path":"images/nand2tetris-1/CPU.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"source/images/llvm-1/Expr.png","path":"images/llvm-1/Expr.png","modified":1,"renderable":0},{"_id":"source/images/llvm-1/FuncDef.png","path":"images/llvm-1/FuncDef.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"source/images/llvm-1/AST.png","path":"images/llvm-1/AST.png","modified":1,"renderable":0},{"_id":"source/images/llvm-1/AST-v2.png","path":"images/llvm-1/AST-v2.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"a9572525c1f1d3173570809d540c4bb882ad0f8c","modified":1593793457050},{"_id":"source/.DS_Store","hash":"ed0806f41fce0f18e9b077e913b7ef8c6f0ce47e","modified":1595086412730},{"_id":"themes/hexo-theme-landscape/.gitignore","hash":"4c78c751a5bbca6b54ad06922947573c967d51c8","modified":1593793457501},{"_id":"themes/hexo-theme-landscape/.travis.yml","hash":"0f850b4da6ba203ddc399bd7ffd675ca4e3da791","modified":1593793457501},{"_id":"themes/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1593793457501},{"_id":"themes/hexo-theme-landscape/README.md","hash":"f723575f1243852b8bec9ba05004500b943e20f1","modified":1593793457502},{"_id":"themes/hexo-theme-landscape/_config.yml","hash":"33a60bb6efd5e8d61e25b893e5da145f34931a05","modified":1593793457502},{"_id":"themes/hexo-theme-landscape/package.json","hash":"c35345c642b4ec5287728d3a9e76f5fbeeb8b81c","modified":1593793457517},{"_id":"source/_drafts/homebrew.md","hash":"96e1252945cee7832bcd753a45f0af26b96e71c3","modified":1593793457051},{"_id":"source/_drafts/keyword.md","hash":"fef0d92d077845331747db4b51d66200de07f441","modified":1594911171043},{"_id":"source/_posts/hexo-guide.md","hash":"7b7a07b29ce2825383d1d74ebb265bc3a5941087","modified":1594910115668},{"_id":"source/_posts/llvm-0.md","hash":"5a2c53f42f4d93cf0784bf46836f6e6c6d958767","modified":1593793457053},{"_id":"source/_posts/nand2tetris-1.md","hash":"cfdbe07df57a37cb5e4f31f972f65bc4034cf77b","modified":1595131604159},{"_id":"source/_posts/llvm-1.md","hash":"8b4f84b34eafaf15034e546ab6950a815a5d5d27","modified":1595064707155},{"_id":"source/_posts/quickjs.md","hash":"1ab847357a7d28f1b0eaa8ae9a9be57d89d850ec","modified":1593793457054},{"_id":"source/images/.DS_Store","hash":"cb034886226ae5a4cb4be74d2943ddf33b474ef0","modified":1595087444573},{"_id":"source/images/logo.jpg","hash":"576d1ad1ad886e33802a1071f678ca8af6575823","modified":1593793457054},{"_id":"themes/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1593793457503},{"_id":"themes/hexo-theme-landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1593793457503},{"_id":"themes/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1593793457503},{"_id":"themes/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1593793457503},{"_id":"themes/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1593793457504},{"_id":"themes/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1593793457504},{"_id":"themes/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1593793457504},{"_id":"themes/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1593793457505},{"_id":"themes/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1593793457505},{"_id":"themes/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1593793457505},{"_id":"themes/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1593793457505},{"_id":"themes/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1593793457506},{"_id":"themes/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1593793457506},{"_id":"themes/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1593793457506},{"_id":"themes/hexo-theme-landscape/languages/zh-CN.yml","hash":"88c5beedec7042d388755278e3cd9f4296a6ed93","modified":1593793457507},{"_id":"themes/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1593793457507},{"_id":"themes/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1593793457515},{"_id":"themes/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1593793457515},{"_id":"themes/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1593793457516},{"_id":"themes/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1593793457516},{"_id":"themes/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1593793457516},{"_id":"themes/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1593793457516},{"_id":"themes/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1593793457517},{"_id":"themes/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1593793457517},{"_id":"source/images/llvm-1/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1594012165404},{"_id":"source/images/nand2tetris-1/CPU.png","hash":"b9927effbf9978ebdeba813eb8263a3daca7ffd6","modified":1595087570394},{"_id":"themes/hexo-theme-landscape/layout/_partial/analytics.ejs","hash":"76b5b8caba94e6e9e5b876497d0874367908f388","modified":1593793457508},{"_id":"themes/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1593793457508},{"_id":"themes/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1593793457508},{"_id":"themes/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1593793457508},{"_id":"themes/hexo-theme-landscape/layout/_partial/article.ejs","hash":"bddc9ad29f14f2e729c383cb49eb1f84885e7a84","modified":1593877719880},{"_id":"themes/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"8488955d4a8e1459aff71eb6747f647663774b42","modified":1593793457509},{"_id":"themes/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1593793457510},{"_id":"themes/hexo-theme-landscape/layout/_partial/head.ejs","hash":"7c7c17e58292bd3e463a489b7ca70b7ae66242d3","modified":1593793457510},{"_id":"themes/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1593793457510},{"_id":"themes/hexo-theme-landscape/layout/_partial/header.ejs","hash":"b33c990e3949c04a034aafd85726e7a3dddde7e4","modified":1593793974356},{"_id":"themes/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1593794274118},{"_id":"themes/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"3397d75a403b26ca26fa3842735f25093059f362","modified":1593797197265},{"_id":"themes/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1593793457514},{"_id":"themes/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1593793457515},{"_id":"themes/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1593793457515},{"_id":"themes/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1593793457515},{"_id":"themes/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1593793457518},{"_id":"themes/hexo-theme-landscape/source/css/_variables.styl","hash":"7fda3cc85720b15b2a8fd60d1cf1af73c83f7266","modified":1593877719883},{"_id":"themes/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1593793457552},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1593793457557},{"_id":"themes/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1593793457562},{"_id":"source/images/llvm-1/Expr.png","hash":"adf1665e19ede9566372fdaba3ede07faea70af2","modified":1593940407695},{"_id":"source/images/llvm-1/FuncDef.png","hash":"b143a92571c35bffc93a79190d464ae5c2f9059c","modified":1593940390897},{"_id":"themes/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1593793457559},{"_id":"themes/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1593793457562},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1593793457511},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1593793457511},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1593793457511},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1593793457512},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1593793457512},{"_id":"themes/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"d5be458fa978cfacf095e668916ed7305808715a","modified":1593877719881},{"_id":"themes/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1593793457518},{"_id":"themes/hexo-theme-landscape/source/css/_partial/article.styl","hash":"13dcb488b7ae25241afa4b57fac6535194cc2f73","modified":1593877719882},{"_id":"themes/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1593793457519},{"_id":"themes/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"b45dcda3db2daf4389a300c5865976e085bc938b","modified":1593793457519},{"_id":"themes/hexo-theme-landscape/source/css/_partial/header.styl","hash":"e74194d4aa2ed7350894fc69d204e5dfa1839aed","modified":1593793457519},{"_id":"themes/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1593793457519},{"_id":"themes/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1593793457520},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1593793457520},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1593793457521},{"_id":"themes/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1593793457521},{"_id":"themes/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1593793457522},{"_id":"themes/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1593793457522},{"_id":"source/images/llvm-1/AST.png","hash":"54d56189987065bdcf2ed33df853a379fb0b4d0e","modified":1593939419352},{"_id":"source/images/llvm-1/AST-v2.png","hash":"201fd40968318ff6bb32bbd211d36c4552cbf3df","modified":1593965129475},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1593793457538},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1593793457539},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1593793457529},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1593793457537},{"_id":"themes/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1593793457525},{"_id":"themes/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1593793457551},{"_id":"themes/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1593793457534},{"_id":"public/2020/07/17/nand2tetris-1/index.html","hash":"c786feb6be113adad3ee69ed411d36a59d9622f6","modified":1595131608314},{"_id":"public/2020/07/09/llvm-1/index.html","hash":"91a7b1acfb9d1c2759b1338f3141e079295cf94c","modified":1595131608314},{"_id":"public/2020/07/02/quickjs/index.html","hash":"60da1769f7ee8f57a28f341c8ac438c95009a545","modified":1595131608314},{"_id":"public/2020/06/25/llvm-0/index.html","hash":"415928278de949567db72c4a77fda4fde9d4dee7","modified":1595131608314},{"_id":"public/2020/06/14/hexo-guide/index.html","hash":"e1f6ee57fb3ba494540f7f28baf5dfe539e6ab33","modified":1595131608314},{"_id":"public/archives/index.html","hash":"b3ea6fec9d0c04765d5f1fdb5c38ae020b776bfb","modified":1595131608314},{"_id":"public/archives/page/2/index.html","hash":"eb3be1c1417eefe35e1ffdcd7c46eab9bb6fde31","modified":1595131608314},{"_id":"public/archives/page/3/index.html","hash":"ea680810dc392d5a23e7b881dd0ecb4063955adf","modified":1595131608314},{"_id":"public/archives/2020/index.html","hash":"e05b5ece343782f4234a95ded6a51c5403454e35","modified":1595131608314},{"_id":"public/archives/2020/page/2/index.html","hash":"d266828372f3382bca6a5f40df9075a4eea98287","modified":1595131608314},{"_id":"public/archives/2020/page/3/index.html","hash":"32ffd28ab7ffce2e0de1d11f8c1405967795e138","modified":1595131608314},{"_id":"public/archives/2020/06/index.html","hash":"bfb373ea01d9dd4b3b9fb455d453d1153f16109d","modified":1595131608314},{"_id":"public/archives/2020/07/index.html","hash":"08234c0bf7dff2b47720efcb55178ffeed841bd1","modified":1595131608314},{"_id":"public/archives/2020/07/page/2/index.html","hash":"fd35703cc74a0e974f028416eee5abc90f03e89d","modified":1595131608314},{"_id":"public/categories/guide/index.html","hash":"083774493e5d726c9b2d2cae291ba496be2e3b91","modified":1595131608314},{"_id":"public/categories/llvm/index.html","hash":"2c88525ba2d99e01179dee5ec3b390a62f4204fd","modified":1595131608314},{"_id":"public/categories/笔记/index.html","hash":"8f9f0bc0e8d9dd8bd0a59448977b20c178d69e49","modified":1595131608314},{"_id":"public/categories/js/index.html","hash":"d332e46e8d6f30b4cc78fc3052cb384f87159bcd","modified":1595131608314},{"_id":"public/index.html","hash":"ee3cb56fdfd75719dcde0aa9c3bb231385d4ba9d","modified":1595131608314},{"_id":"public/tags/guide/index.html","hash":"4a0c195c75227394203a804d30a7cda3073321a9","modified":1595131608314},{"_id":"public/tags/llvm/index.html","hash":"5c83dc8f7aaad60dd42f7995b087935b7e79760f","modified":1595131608314},{"_id":"public/tags/笔记/index.html","hash":"3d0eaf596c28dce78465ab725d40cbb8e02b5fb8","modified":1595131608314},{"_id":"public/tags/js/index.html","hash":"3f87bf86e53ed822f9971aeaf1e44312d520245c","modified":1595131608314},{"_id":"public/tags/quickjs/index.html","hash":"415531fb1f36ba47f5276b59337e14a7df682507","modified":1595131608314},{"_id":"public/CNAME","hash":"a9572525c1f1d3173570809d540c4bb882ad0f8c","modified":1595131608314},{"_id":"public/images/logo.jpg","hash":"576d1ad1ad886e33802a1071f678ca8af6575823","modified":1595131608314},{"_id":"public/images/nand2tetris-1/CPU.png","hash":"b9927effbf9978ebdeba813eb8263a3daca7ffd6","modified":1595131608314},{"_id":"public/images/llvm-1/Expr.png","hash":"adf1665e19ede9566372fdaba3ede07faea70af2","modified":1595131608314},{"_id":"public/images/llvm-1/FuncDef.png","hash":"b143a92571c35bffc93a79190d464ae5c2f9059c","modified":1595131608314},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1595131608314},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1595131608314},{"_id":"public/css/style.css","hash":"55aa62fcc0dd8f756966352087b45cb68b0aad21","modified":1595131608314},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1595131608314},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1595131608314},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1595131608314},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1595131608314},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1595131608314},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1595131608314},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1595131608314},{"_id":"public/images/llvm-1/AST.png","hash":"54d56189987065bdcf2ed33df853a379fb0b4d0e","modified":1595131608314},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1595131608314},{"_id":"public/images/llvm-1/AST-v2.png","hash":"201fd40968318ff6bb32bbd211d36c4552cbf3df","modified":1595131608314},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1595131608314}],"Category":[{"name":"software","_id":"ckcsk6ave0002nujkfcmk51tw"},{"name":"guide","_id":"ckcsk6avr0007nujkhwxu4w0e"},{"name":"llvm","_id":"ckcsk6avw000dnujkfzc9bn9v"},{"name":"笔记","_id":"ckcsk6aw2000hnujkemvreia5"},{"name":"js","_id":"ckcsk6aw9000lnujkc32i577b"}],"Data":[],"Page":[],"Post":[{"title":"homebrew国内安装指南","date":"2020-06-17T02:30:39.000Z","_content":"\n[Homebrew](https://brew.sh)是一款Mac上的包管理器，可以很方便的安装各种软件。\n\nfishshell:\n\n```\n# 安装brew\n/bin/bash -c (curl -fsSL https://gitee.com/lhtin/brew-install/raw/master/install.sh)\n\n# 修改源为gitee\ncd (brew --repo)\ngit remote set-url origin https://gitee.com/lhtin/brew.git\n\ncd (brew --repo)/Library/Taps/homebrew/homebrew-core\ngit remote set-url origin https://gitee.com/lhtin/homebrew-core.git\n\n# 安装了cask才有\ncd (brew --repo)/Library/Taps/homebrew/homebrew-cask\ngit remote set-url origin https://gitee.com/lhtin/homebrew-cask.git\n\n# 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址\n\n# 修改Bottles源\n## 中科大源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.ustc.edu.cn/homebrew-bottles\n## 清华源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\n```\n","source":"_drafts/homebrew.md","raw":"---\ntitle: homebrew国内安装指南\ndate: 2020-06-17 10:30:39\ncategories:\n- software\ntags:\n- software\n---\n\n[Homebrew](https://brew.sh)是一款Mac上的包管理器，可以很方便的安装各种软件。\n\nfishshell:\n\n```\n# 安装brew\n/bin/bash -c (curl -fsSL https://gitee.com/lhtin/brew-install/raw/master/install.sh)\n\n# 修改源为gitee\ncd (brew --repo)\ngit remote set-url origin https://gitee.com/lhtin/brew.git\n\ncd (brew --repo)/Library/Taps/homebrew/homebrew-core\ngit remote set-url origin https://gitee.com/lhtin/homebrew-core.git\n\n# 安装了cask才有\ncd (brew --repo)/Library/Taps/homebrew/homebrew-cask\ngit remote set-url origin https://gitee.com/lhtin/homebrew-cask.git\n\n# 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址\n\n# 修改Bottles源\n## 中科大源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.ustc.edu.cn/homebrew-bottles\n## 清华源\nset --export HOMEBREW_BOTTLE_DOMAIN https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\n```\n","slug":"homebrew","published":0,"updated":"2020-07-03T16:24:17.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcsk6aux0000nujk14tdcexp","content":"<p><a href=\"https://brew.sh\" target=\"_blank\" rel=\"noopener\">Homebrew</a>是一款Mac上的包管理器，可以很方便的安装各种软件。</p>\n<p>fishshell:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装brew</span><br><span class=\"line\">&#x2F;bin&#x2F;bash -c (curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew-install&#x2F;raw&#x2F;master&#x2F;install.sh)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改源为gitee</span><br><span class=\"line\">cd (brew --repo)</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-core.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装了cask才有</span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-cask.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改Bottles源</span><br><span class=\"line\">## 中科大源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles</span><br><span class=\"line\">## 清华源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;homebrew-bottles</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://brew.sh\" target=\"_blank\" rel=\"noopener\">Homebrew</a>是一款Mac上的包管理器，可以很方便的安装各种软件。</p>\n<p>fishshell:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装brew</span><br><span class=\"line\">&#x2F;bin&#x2F;bash -c (curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew-install&#x2F;raw&#x2F;master&#x2F;install.sh)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改源为gitee</span><br><span class=\"line\">cd (brew --repo)</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;brew.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-core.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装了cask才有</span><br><span class=\"line\">cd (brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask</span><br><span class=\"line\">git remote set-url origin https:&#x2F;&#x2F;gitee.com&#x2F;lhtin&#x2F;homebrew-cask.git</span><br><span class=\"line\"></span><br><span class=\"line\"># 如还有其他源，也可以使用Gitee导入Github上的仓库，然后改为Gitee上的仓库地址</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改Bottles源</span><br><span class=\"line\">## 中科大源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles</span><br><span class=\"line\">## 清华源</span><br><span class=\"line\">set --export HOMEBREW_BOTTLE_DOMAIN https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;homebrew-bottles</span><br></pre></td></tr></table></figure>\n"},{"_content":"- router 读音不对","source":"_drafts/keyword.md","raw":"- router 读音不对","slug":"keyword","published":0,"date":"2020-07-16T14:52:24.205Z","updated":"2020-07-16T14:52:51.043Z","title":"keyword","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcsk6ava0001nujk6fwp7tgn","content":"<ul>\n<li>router 读音不对</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>router 读音不对</li>\n</ul>\n"},{"title":"本站建造过程记录","date":"2020-06-13T16:00:00.000Z","excerpt":"本文详细记录了使用Hexo创建静态博客的过程。","_content":"\n本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。\n\n## 使用Gitee Pages服务\n\n在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是[lhtin](https://gitee.com/lhtin)，仓库名也为[lhtin](https://gitee.com/lhtin/lhtin)，这样就可以直接通过 https://lhtin.gitee.io 访问，而不需要加上仓库的名称作为访问的路径（ https://lhtin.gitee.io/lhtin ）。\n\n创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考[官方指南](https://gitee.com/help/articles/4136)。这样静态服务器就有了。\n\n## 使用Hexo博客框架\n\n为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。\n\n### 初始化博客项目\n\n首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：\n\n```shell\nnpm install -g hexo-cli\n\nhexo init <name>\n\ncd <name>\nnpm install\n```\n\n执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：\n\n```shell\nnpm run server // 启动本地server\nnpm run build // 将项目打包成静态文件，存放在public目录\nnpm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置\n\nhexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中\n```\n\n更多指南请前往[Hexo官方文档](https://hexo.io/zh-cn/docs)。\n\n### 根据需要修改配置\n\n在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见[官方文档-配置](https://hexo.io/zh-cn/docs/configuration)）：\n\n```yml\n# 项目根目录下的_config.yml文件\ntitle: 01的世界\nsubtitle: 计算机的世界没有秘密\ndescription: 这里有关于计算机的方方面面\nkeywords: 01的世界\nauthor: 钉子哥\nlanguage: zh-CN # 会影响主题中的语言选择\ntimezone: Asia/Shanghai\n\n// 本博客部署的地址\nurl: https://lhtin.gitee.io\nroot: /\n```\n\n然后还需要根据我自己的要求，修改默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的部分内容。所有修改的内容可以参见我fork出来的[仓库](https://gitee.com/lhtin/hexo-theme-landscape)。这里我列出主要的修改：\n\n- 将一些英文翻译为中文，比如Home -> 首页，Read More -> 阅读全文\n- 去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag\n- 添加百度统计，并和Google统计合并到一个ejs文件\n- 去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期\n- 去掉右上角的导航，固定展示为“首页”\n- 修改首页展示文章摘抄的样式\n\n### 构建和部署\n\n当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的[ejs模版](https://ejs.co)，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。\n\n生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。\n\n```yml\n# 项目根目录下的_config.yml文件\ndeploy:\n  type: git\n  repo: https://gitee.com/lhtin/lhtin.git\n  branch: page\n```\n\n构建和部署的命令如下：\n\n```\nnpm run build\nnpm install --save-dev hexo-deployer-git\nnpm run deploy\n```\n\n因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：\n\n```json\n{\n  \"scripts\": {\n    \"d\": \"npm run clean && npm run build && npm run deploy\"\n  }\n}\n```\n\n这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。~~或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。~~目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加[gitee](https://www.npmjs.com/package/gitee)这个npm模块。","source":"_posts/hexo-guide.md","raw":"---\ntitle: 本站建造过程记录\ndate: 2020/06/14\ntag:\n- guide\ncategory:\n- guide\nexcerpt: 本文详细记录了使用Hexo创建静态博客的过程。\n---\n\n本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。\n\n## 使用Gitee Pages服务\n\n在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是[lhtin](https://gitee.com/lhtin)，仓库名也为[lhtin](https://gitee.com/lhtin/lhtin)，这样就可以直接通过 https://lhtin.gitee.io 访问，而不需要加上仓库的名称作为访问的路径（ https://lhtin.gitee.io/lhtin ）。\n\n创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考[官方指南](https://gitee.com/help/articles/4136)。这样静态服务器就有了。\n\n## 使用Hexo博客框架\n\n为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。\n\n### 初始化博客项目\n\n首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：\n\n```shell\nnpm install -g hexo-cli\n\nhexo init <name>\n\ncd <name>\nnpm install\n```\n\n执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：\n\n```shell\nnpm run server // 启动本地server\nnpm run build // 将项目打包成静态文件，存放在public目录\nnpm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置\n\nhexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中\n```\n\n更多指南请前往[Hexo官方文档](https://hexo.io/zh-cn/docs)。\n\n### 根据需要修改配置\n\n在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见[官方文档-配置](https://hexo.io/zh-cn/docs/configuration)）：\n\n```yml\n# 项目根目录下的_config.yml文件\ntitle: 01的世界\nsubtitle: 计算机的世界没有秘密\ndescription: 这里有关于计算机的方方面面\nkeywords: 01的世界\nauthor: 钉子哥\nlanguage: zh-CN # 会影响主题中的语言选择\ntimezone: Asia/Shanghai\n\n// 本博客部署的地址\nurl: https://lhtin.gitee.io\nroot: /\n```\n\n然后还需要根据我自己的要求，修改默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的部分内容。所有修改的内容可以参见我fork出来的[仓库](https://gitee.com/lhtin/hexo-theme-landscape)。这里我列出主要的修改：\n\n- 将一些英文翻译为中文，比如Home -> 首页，Read More -> 阅读全文\n- 去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag\n- 添加百度统计，并和Google统计合并到一个ejs文件\n- 去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期\n- 去掉右上角的导航，固定展示为“首页”\n- 修改首页展示文章摘抄的样式\n\n### 构建和部署\n\n当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的[ejs模版](https://ejs.co)，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。\n\n生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。\n\n```yml\n# 项目根目录下的_config.yml文件\ndeploy:\n  type: git\n  repo: https://gitee.com/lhtin/lhtin.git\n  branch: page\n```\n\n构建和部署的命令如下：\n\n```\nnpm run build\nnpm install --save-dev hexo-deployer-git\nnpm run deploy\n```\n\n因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：\n\n```json\n{\n  \"scripts\": {\n    \"d\": \"npm run clean && npm run build && npm run deploy\"\n  }\n}\n```\n\n这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。~~或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。~~目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加[gitee](https://www.npmjs.com/package/gitee)这个npm模块。","slug":"hexo-guide","published":1,"updated":"2020-07-16T14:35:15.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcsk6avg0004nujk1za36c7k","content":"<p>本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。</p>\n<h2 id=\"使用Gitee-Pages服务\"><a href=\"#使用Gitee-Pages服务\" class=\"headerlink\" title=\"使用Gitee Pages服务\"></a>使用Gitee Pages服务</h2><p>在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是<a href=\"https://gitee.com/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，仓库名也为<a href=\"https://gitee.com/lhtin/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，这样就可以直接通过 <a href=\"https://lhtin.gitee.io\" target=\"_blank\" rel=\"noopener\">https://lhtin.gitee.io</a> 访问，而不需要加上仓库的名称作为访问的路径（ <a href=\"https://lhtin.gitee.io/lhtin\" target=\"_blank\" rel=\"noopener\">https://lhtin.gitee.io/lhtin</a> ）。</p>\n<p>创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考<a href=\"https://gitee.com/help/articles/4136\" target=\"_blank\" rel=\"noopener\">官方指南</a>。这样静态服务器就有了。</p>\n<h2 id=\"使用Hexo博客框架\"><a href=\"#使用Hexo博客框架\" class=\"headerlink\" title=\"使用Hexo博客框架\"></a>使用Hexo博客框架</h2><p>为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。</p>\n<h3 id=\"初始化博客项目\"><a href=\"#初始化博客项目\" class=\"headerlink\" title=\"初始化博客项目\"></a>初始化博客项目</h3><p>首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cd &lt;name&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run server // 启动本地server</span><br><span class=\"line\">npm run build // 将项目打包成静态文件，存放在public目录</span><br><span class=\"line\">npm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中</span><br></pre></td></tr></table></figure>\n\n<p>更多指南请前往<a href=\"https://hexo.io/zh-cn/docs\" target=\"_blank\" rel=\"noopener\">Hexo官方文档</a>。</p>\n<h3 id=\"根据需要修改配置\"><a href=\"#根据需要修改配置\" class=\"headerlink\" title=\"根据需要修改配置\"></a>根据需要修改配置</h3><p>在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">官方文档-配置</a>）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">计算机的世界没有秘密</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">这里有关于计算机的方方面面</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">钉子哥</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span> <span class=\"comment\"># 会影响主题中的语言选择</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span> <span class=\"string\">本博客部署的地址</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://lhtin.gitee.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>然后还需要根据我自己的要求，修改默认主题<a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">landscape</a>的部分内容。所有修改的内容可以参见我fork出来的<a href=\"https://gitee.com/lhtin/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">仓库</a>。这里我列出主要的修改：</p>\n<ul>\n<li>将一些英文翻译为中文，比如Home -&gt; 首页，Read More -&gt; 阅读全文</li>\n<li>去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag</li>\n<li>添加百度统计，并和Google统计合并到一个ejs文件</li>\n<li>去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期</li>\n<li>去掉右上角的导航，固定展示为“首页”</li>\n<li>修改首页展示文章摘抄的样式</li>\n</ul>\n<h3 id=\"构建和部署\"><a href=\"#构建和部署\" class=\"headerlink\" title=\"构建和部署\"></a>构建和部署</h3><p>当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的<a href=\"https://ejs.co\" target=\"_blank\" rel=\"noopener\">ejs模版</a>，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。</p>\n<p>生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gitee.com/lhtin/lhtin.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">page</span></span><br></pre></td></tr></table></figure>\n\n<p>构建和部署的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br><span class=\"line\">npm install --save-dev hexo-deployer-git</span><br><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"d\"</span>: <span class=\"string\">\"npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。<del>或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。</del>目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加<a href=\"https://www.npmjs.com/package/gitee\" target=\"_blank\" rel=\"noopener\">gitee</a>这个npm模块。</p>\n","site":{"data":{}},"more":"<p>本文记录了使用Hexo创建静态博客的过程。我的需求是为了学习的内容找一个地方系统的记录下来，并且可以很方便的查看，但是又不想自己去购买服务器。另外写作的语言要求为Markdown。我首先想到的是使用Gitee Pages服务，免费且在国内访问速度还不错。下面就来一一介绍这整个的过程。</p>\n<h2 id=\"使用Gitee-Pages服务\"><a href=\"#使用Gitee-Pages服务\" class=\"headerlink\" title=\"使用Gitee Pages服务\"></a>使用Gitee Pages服务</h2><p>在Gitee上创建一个账号，然后在创建一个名称跟账号同名的仓库。同名的作用是为了在访问时不需要指定仓库名称。比如说我的账户名是<a href=\"https://gitee.com/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，仓库名也为<a href=\"https://gitee.com/lhtin/lhtin\" target=\"_blank\" rel=\"noopener\">lhtin</a>，这样就可以直接通过 <a href=\"https://lhtin.gitee.io\" target=\"_blank\" rel=\"noopener\">https://lhtin.gitee.io</a> 访问，而不需要加上仓库的名称作为访问的路径（ <a href=\"https://lhtin.gitee.io/lhtin\" target=\"_blank\" rel=\"noopener\">https://lhtin.gitee.io/lhtin</a> ）。</p>\n<p>创建了仓库之后，就可以对仓库启动Pages服务了，具体设置方式请直接参考<a href=\"https://gitee.com/help/articles/4136\" target=\"_blank\" rel=\"noopener\">官方指南</a>。这样静态服务器就有了。</p>\n<h2 id=\"使用Hexo博客框架\"><a href=\"#使用Hexo博客框架\" class=\"headerlink\" title=\"使用Hexo博客框架\"></a>使用Hexo博客框架</h2><p>为了尽可能将时间花在写博客上面，我直接选择使用Hexo博客框架。这个框架非常灵活，除了基本的将Markdown编译为HTML能力之外，还提供了集中组织文章的方式。比如根据时间进行归档，根据标签和分类进行文章统计和检索。另外你也可以定义很多新的玩法，扩展性很好。下面介绍我的使用过程。</p>\n<h3 id=\"初始化博客项目\"><a href=\"#初始化博客项目\" class=\"headerlink\" title=\"初始化博客项目\"></a>初始化博客项目</h3><p>首先使用npm安装Hexo命令行工具，安装完之后初始化一个空的项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cd &lt;name&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>执行完了之后，项目默认使用landscape主题。初始化的项目中有以下几个脚本命名可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run server // 启动本地server</span><br><span class=\"line\">npm run build // 将项目打包成静态文件，存放在public目录</span><br><span class=\"line\">npm run deploy // 将public中的内容上传到指定的git仓库分支，需要在_config.yml中配置仓库信息，后面会介绍如何配置</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new post hexo-guide // 根据scaffolds中的post模版生成文章的基本结构，会自动设置title和日期，生成的文件会存放在source/_posts中</span><br></pre></td></tr></table></figure>\n\n<p>更多指南请前往<a href=\"https://hexo.io/zh-cn/docs\" target=\"_blank\" rel=\"noopener\">Hexo官方文档</a>。</p>\n<h3 id=\"根据需要修改配置\"><a href=\"#根据需要修改配置\" class=\"headerlink\" title=\"根据需要修改配置\"></a>根据需要修改配置</h3><p>在初始化完了项目之后，我做了一些修改，以满足我的需求。首先定义网站的相关信息（更多配置说明请参见<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">官方文档-配置</a>）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">计算机的世界没有秘密</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">这里有关于计算机的方方面面</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"number\">01</span><span class=\"string\">的世界</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">钉子哥</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span> <span class=\"comment\"># 会影响主题中的语言选择</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span> <span class=\"string\">本博客部署的地址</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">https://lhtin.gitee.io</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure>\n\n<p>然后还需要根据我自己的要求，修改默认主题<a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">landscape</a>的部分内容。所有修改的内容可以参见我fork出来的<a href=\"https://gitee.com/lhtin/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">仓库</a>。这里我列出主要的修改：</p>\n<ul>\n<li>将一些英文翻译为中文，比如Home -&gt; 首页，Read More -&gt; 阅读全文</li>\n<li>去掉tagcloud，调整widgets的顺序，打开展示分类和标签中对应的文章数量的flag</li>\n<li>添加百度统计，并和Google统计合并到一个ejs文件</li>\n<li>去掉文章头部的日期和分类展示。让文章标题居中展示，并且在文章下面展示文章作者和日期</li>\n<li>去掉右上角的导航，固定展示为“首页”</li>\n<li>修改首页展示文章摘抄的样式</li>\n</ul>\n<h3 id=\"构建和部署\"><a href=\"#构建和部署\" class=\"headerlink\" title=\"构建和部署\"></a>构建和部署</h3><p>当你写好了一篇博客文章之后，就需要构建成静态文件，以便上传到Gitee Pages上。Hexo在构建时，是根据所选主题中对应的<a href=\"https://ejs.co\" target=\"_blank\" rel=\"noopener\">ejs模版</a>，填充所需参数（大部分来自yml文件和Markdown文件头部信息）和文章内容之后，就会生成HTML文件。</p>\n<p>生成HTML文件后，可以通过使用部署插件hexo-deployer-git，将生成的public目录中的文件自动上传到指定的git上，上传之前需要先在_config.yml中配置Git相关信息。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目根目录下的_config.yml文件</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">https://gitee.com/lhtin/lhtin.git</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">page</span></span><br></pre></td></tr></table></figure>\n\n<p>构建和部署的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br><span class=\"line\">npm install --save-dev hexo-deployer-git</span><br><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>因为build和deploy经常一起用，于是我将两个命令整合成一个，取名d：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"d\"</span>: <span class=\"string\">\"npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了博客的构建和上传。上传完之后需要注意下，Gitee Pages并不支持自动更新你上传的内容，你需要手动进到项目中的Pages服务，点击更新进行手动更新。<del>或许可以直接集成到d命令中，push完之后直接调用Pages的更新接口。这个等以后有时间了再来折腾下。</del>目前已经可以通过命令行触发Pages自动部署了，更多内容可以参加<a href=\"https://www.npmjs.com/package/gitee\" target=\"_blank\" rel=\"noopener\">gitee</a>这个npm模块。</p>\n"},{"title":"学习LLVM第0篇：LLVM项目介绍","date":"2020-06-25T13:55:21.000Z","excerpt":"本文学习LLVM的第0篇文章，介绍LLVM项目的一些内容，包括如何构建命令行工具和本地文档、常用LLVM命令的使用。目的是为了后续研究LLVM作准备。","_content":"\n更全面的内容请直接参考[官方文档](https://llvm.org/docs)，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。\n\n\n\n## 编译项目\n\n1. 安装[CMake](https://cmake.org)、[Ninja](https://ninja-build.org)构建工具。\n   \n   这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。\n   \n2. 克隆LLVM仓库：`git clone https://github.com/llvm/llvm-project`\n\n   如果国内clone太慢，也可以使用Gitee提供的镜像仓库`https://gitee.com/mirrors/LLVM`（注意：镜像仓库目前每天同步一次，所以内容会有延后）\n\n3. 创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：`mkdir build`，然后进到构建目录： `cd build`\n\n4. 生成构建系统：`cmake -G Ninja -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\" ../llvm`\n\n   常用参数：\n\n   - `LLVM_ENABLE_PROJECTS`：比如`\"clang;libcxx\"`。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如`clang`、`clang-tools-extra`、`libcxx`、`libc`等。\n\n     小提示：所有支持的项目可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_PROJECTS`变量的内容。当前的内容为：`clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl`\n\n   - `LLVM_TARGETS_TO_BUILD`：比如`\"X86;RISCV\"`。指定LLVM后端支持的目标架构，比如`X86`、`ARM`、`RISCV`、`WebAssembly`\n\n     小提示：所有支持的目标架构可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_TARGETS`变量的内容。当前的内容为：`AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore`\n\n   - `LLVM_ENABLE_SPHINX`：是否编译LLVM文档。`ON`表示启动。依赖[Sphinx](https://www.sphinx-doc.org)\n\n   - `LLVM_ENABLE_DOXYGEN`：是否编译LLVM API文档。`ON`表示启动。依赖[Doxygen](https://www.doxygen.nl)\n\n5. 进行构建：\n\n   - `cmake --build .` 表示编译默认目标包括LLVM和`LLVM_ENABLE_PROJECTS`指定的项目\n\n   - `cmake --build . --target docs-llvm-html` 表示只编译LLVM文档\n\n     小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：`llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef`，这是一个警告，但是因为编译的时候指定了`-W`，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报`llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info`。目前我的解决办法是去掉`-W`之后单独执行：`sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html`。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。\n\n     更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。\n\n   - `cmake --build . --target doxygen-llvm` 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。\n   \n   小提示：1. 想要查看有哪些target可以去查看生成的`build/CMakeFiles/TargetDirectories.txt`文件。像这里的`doxygen-llvm`我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。\n\n将前面的命令放在一起方便拷贝：\n\n```shell\ngit clone https://github.com/llvm/llvm-project\n// Gitee源：git clone https://gitee.com/mirrors/LLVM\ncd llvm-project && mkdir build && cd build\ncmake -G Ninja\\\n  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\\n  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\\n  -DLLVM_ENABLE_SPHINX=ON\\\n  -DLLVM_ENABLE_DOXYGEN=ON\\\n  ../llvm\ncmake --build . // 编译llvm、clang、libcxx\ncmake --build . --target docs-llvm-html // 编译LLVM文档\ncmake --build . --target doxygen-llvm // 编译LLVM API文档\n```\n\n官方文档参考：\n\n- [Getting Started with the LLVM System](https://llvm.org/docs/GettingStarted.html)：介绍了编译项目的基本步骤，常用参数\n- [Building LLVM with CMake](https://llvm.org/docs/CMake.html)：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数\n\n\n\n## 常用LLVM命令\n\n- clang\n  - `clang -S -emit-llvm input.c -o out.ll`：生成人可读的LLVM IR\n  - `clang -c -emit-llvm input.c -o out.bc`：生成二进制LLVM IR，也可以不加`-c`，默认编译为二进制IR\n- [opt](https://llvm.org/docs/CommandGuide/opt.html)\n  - `opt -load-pass-plugin=libHelloWorld.dylib -passes=\"hello-world\" a.ll`：使用HelloWorld Pass对`out.ll`进行处理。注意这是新的单独调用Pass的方式，老的方式为：`opt -load libHelloWorld.dylib -legacy-hello-world a.ll`\n  - `opt -analyze -view-cfg a.ll` 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。\n- [llvm-as](https://llvm.org/docs/CommandGuide/llvm-as.html)、[llvm-dis](https://llvm.org/docs/CommandGuide/llvm-dis.html)\n  - `llvm-as a.ll -o a.bc`：将人可读的LLVM IR编译为二进制LLVM IR\n  - `llvm-dis a.bc -o a.ll`：将二进制LLVM IR反编译为人可读的LLVM IR\n- [llc](https://llvm.org/docs/CommandGuide/llc.html)\n  - `llc a.ll -o a.out`：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件\n- [lli](https://llvm.org/docs/CommandGuide/lli.html)\n  - `lli a.ll`：直接解释执行LLVM IR\n- [llvm-link](https://llvm.org/docs/CommandGuide/llvm-link.html)\n  - `llvm-link -S add.ll main.ll -o all.ll`：链接多个LLVM IR为一个LLVM IR文件，`-S`表示输出的为人可读的LLVM IR，默认为二进制LLVM IR\n- [llvm-config](https://llvm.org/docs/CommandGuide/llvm-config.html)：使用`llvm-config --help`查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。\n  - `llvm-config --cxxflags`：生成编译时的头文件库参数，比如在我电脑上会输出`-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS`\n  - `llvm-config --ldflags`：生成链接时的LLVM库文件地址，比如在我电脑上会输出`-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names`\n  - `llvm-config --libs`：生成LLVM提供的库名称，结合`llvm-config --ldflags`，就可以让链接器找到对应的库文件。在`--libs`后面还可以添加各种组件名称，不添加表示所有组件。比如`--libs core native`，则只会输出core和native组件相关的库。通过下面的`llvm-config --components`命令可以列举出所有的LLVM组件列表\n  - `llvm-config --components`：输出所有的LLVM组件\n\n官方文档参考：\n\n- [LLVM Command Guide](https://llvm.org/docs/CommandGuide/index.html)：命令行工具使用说明\n\n\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->","source":"_posts/llvm-0.md","raw":"---\ntitle: 学习LLVM第0篇：LLVM项目介绍\ndate: 2020-06-25 21:55:21\ncategories:\n- llvm\ntags:\n- llvm\nexcerpt: 本文学习LLVM的第0篇文章，介绍LLVM项目的一些内容，包括如何构建命令行工具和本地文档、常用LLVM命令的使用。目的是为了后续研究LLVM作准备。\n---\n\n更全面的内容请直接参考[官方文档](https://llvm.org/docs)，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。\n\n\n\n## 编译项目\n\n1. 安装[CMake](https://cmake.org)、[Ninja](https://ninja-build.org)构建工具。\n   \n   这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。\n   \n2. 克隆LLVM仓库：`git clone https://github.com/llvm/llvm-project`\n\n   如果国内clone太慢，也可以使用Gitee提供的镜像仓库`https://gitee.com/mirrors/LLVM`（注意：镜像仓库目前每天同步一次，所以内容会有延后）\n\n3. 创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：`mkdir build`，然后进到构建目录： `cd build`\n\n4. 生成构建系统：`cmake -G Ninja -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\" ../llvm`\n\n   常用参数：\n\n   - `LLVM_ENABLE_PROJECTS`：比如`\"clang;libcxx\"`。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如`clang`、`clang-tools-extra`、`libcxx`、`libc`等。\n\n     小提示：所有支持的项目可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_PROJECTS`变量的内容。当前的内容为：`clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl`\n\n   - `LLVM_TARGETS_TO_BUILD`：比如`\"X86;RISCV\"`。指定LLVM后端支持的目标架构，比如`X86`、`ARM`、`RISCV`、`WebAssembly`\n\n     小提示：所有支持的目标架构可以去看`llvm/CMakeLists.txt`文件中的`LLVM_ALL_TARGETS`变量的内容。当前的内容为：`AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore`\n\n   - `LLVM_ENABLE_SPHINX`：是否编译LLVM文档。`ON`表示启动。依赖[Sphinx](https://www.sphinx-doc.org)\n\n   - `LLVM_ENABLE_DOXYGEN`：是否编译LLVM API文档。`ON`表示启动。依赖[Doxygen](https://www.doxygen.nl)\n\n5. 进行构建：\n\n   - `cmake --build .` 表示编译默认目标包括LLVM和`LLVM_ENABLE_PROJECTS`指定的项目\n\n   - `cmake --build . --target docs-llvm-html` 表示只编译LLVM文档\n\n     小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：`llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef`，这是一个警告，但是因为编译的时候指定了`-W`，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报`llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info`。目前我的解决办法是去掉`-W`之后单独执行：`sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html`。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。\n\n     更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。\n\n   - `cmake --build . --target doxygen-llvm` 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。\n   \n   小提示：1. 想要查看有哪些target可以去查看生成的`build/CMakeFiles/TargetDirectories.txt`文件。像这里的`doxygen-llvm`我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。\n\n将前面的命令放在一起方便拷贝：\n\n```shell\ngit clone https://github.com/llvm/llvm-project\n// Gitee源：git clone https://gitee.com/mirrors/LLVM\ncd llvm-project && mkdir build && cd build\ncmake -G Ninja\\\n  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\\n  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\\n  -DLLVM_ENABLE_SPHINX=ON\\\n  -DLLVM_ENABLE_DOXYGEN=ON\\\n  ../llvm\ncmake --build . // 编译llvm、clang、libcxx\ncmake --build . --target docs-llvm-html // 编译LLVM文档\ncmake --build . --target doxygen-llvm // 编译LLVM API文档\n```\n\n官方文档参考：\n\n- [Getting Started with the LLVM System](https://llvm.org/docs/GettingStarted.html)：介绍了编译项目的基本步骤，常用参数\n- [Building LLVM with CMake](https://llvm.org/docs/CMake.html)：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数\n\n\n\n## 常用LLVM命令\n\n- clang\n  - `clang -S -emit-llvm input.c -o out.ll`：生成人可读的LLVM IR\n  - `clang -c -emit-llvm input.c -o out.bc`：生成二进制LLVM IR，也可以不加`-c`，默认编译为二进制IR\n- [opt](https://llvm.org/docs/CommandGuide/opt.html)\n  - `opt -load-pass-plugin=libHelloWorld.dylib -passes=\"hello-world\" a.ll`：使用HelloWorld Pass对`out.ll`进行处理。注意这是新的单独调用Pass的方式，老的方式为：`opt -load libHelloWorld.dylib -legacy-hello-world a.ll`\n  - `opt -analyze -view-cfg a.ll` 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。\n- [llvm-as](https://llvm.org/docs/CommandGuide/llvm-as.html)、[llvm-dis](https://llvm.org/docs/CommandGuide/llvm-dis.html)\n  - `llvm-as a.ll -o a.bc`：将人可读的LLVM IR编译为二进制LLVM IR\n  - `llvm-dis a.bc -o a.ll`：将二进制LLVM IR反编译为人可读的LLVM IR\n- [llc](https://llvm.org/docs/CommandGuide/llc.html)\n  - `llc a.ll -o a.out`：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件\n- [lli](https://llvm.org/docs/CommandGuide/lli.html)\n  - `lli a.ll`：直接解释执行LLVM IR\n- [llvm-link](https://llvm.org/docs/CommandGuide/llvm-link.html)\n  - `llvm-link -S add.ll main.ll -o all.ll`：链接多个LLVM IR为一个LLVM IR文件，`-S`表示输出的为人可读的LLVM IR，默认为二进制LLVM IR\n- [llvm-config](https://llvm.org/docs/CommandGuide/llvm-config.html)：使用`llvm-config --help`查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。\n  - `llvm-config --cxxflags`：生成编译时的头文件库参数，比如在我电脑上会输出`-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS`\n  - `llvm-config --ldflags`：生成链接时的LLVM库文件地址，比如在我电脑上会输出`-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names`\n  - `llvm-config --libs`：生成LLVM提供的库名称，结合`llvm-config --ldflags`，就可以让链接器找到对应的库文件。在`--libs`后面还可以添加各种组件名称，不添加表示所有组件。比如`--libs core native`，则只会输出core和native组件相关的库。通过下面的`llvm-config --components`命令可以列举出所有的LLVM组件列表\n  - `llvm-config --components`：输出所有的LLVM组件\n\n官方文档参考：\n\n- [LLVM Command Guide](https://llvm.org/docs/CommandGuide/index.html)：命令行工具使用说明\n\n\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->","slug":"llvm-0","published":1,"updated":"2020-07-03T16:24:17.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcsk6avn0005nujk1oc0g28x","content":"<p>更全面的内容请直接参考<a href=\"https://llvm.org/docs\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。</p>\n<h2 id=\"编译项目\"><a href=\"#编译项目\" class=\"headerlink\" title=\"编译项目\"></a>编译项目</h2><ol>\n<li><p>安装<a href=\"https://cmake.org\" target=\"_blank\" rel=\"noopener\">CMake</a>、<a href=\"https://ninja-build.org\" target=\"_blank\" rel=\"noopener\">Ninja</a>构建工具。</p>\n<p>这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。</p>\n</li>\n<li><p>克隆LLVM仓库：<code>git clone https://github.com/llvm/llvm-project</code></p>\n<p>如果国内clone太慢，也可以使用Gitee提供的镜像仓库<code>https://gitee.com/mirrors/LLVM</code>（注意：镜像仓库目前每天同步一次，所以内容会有延后）</p>\n</li>\n<li><p>创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：<code>mkdir build</code>，然后进到构建目录： <code>cd build</code></p>\n</li>\n<li><p>生成构建系统：<code>cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot; ../llvm</code></p>\n<p>常用参数：</p>\n<ul>\n<li><p><code>LLVM_ENABLE_PROJECTS</code>：比如<code>&quot;clang;libcxx&quot;</code>。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如<code>clang</code>、<code>clang-tools-extra</code>、<code>libcxx</code>、<code>libc</code>等。</p>\n<p>小提示：所有支持的项目可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_PROJECTS</code>变量的内容。当前的内容为：<code>clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl</code></p>\n</li>\n<li><p><code>LLVM_TARGETS_TO_BUILD</code>：比如<code>&quot;X86;RISCV&quot;</code>。指定LLVM后端支持的目标架构，比如<code>X86</code>、<code>ARM</code>、<code>RISCV</code>、<code>WebAssembly</code></p>\n<p>小提示：所有支持的目标架构可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_TARGETS</code>变量的内容。当前的内容为：<code>AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore</code></p>\n</li>\n<li><p><code>LLVM_ENABLE_SPHINX</code>：是否编译LLVM文档。<code>ON</code>表示启动。依赖<a href=\"https://www.sphinx-doc.org\" target=\"_blank\" rel=\"noopener\">Sphinx</a></p>\n</li>\n<li><p><code>LLVM_ENABLE_DOXYGEN</code>：是否编译LLVM API文档。<code>ON</code>表示启动。依赖<a href=\"https://www.doxygen.nl\" target=\"_blank\" rel=\"noopener\">Doxygen</a></p>\n</li>\n</ul>\n</li>\n<li><p>进行构建：</p>\n<ul>\n<li><p><code>cmake --build .</code> 表示编译默认目标包括LLVM和<code>LLVM_ENABLE_PROJECTS</code>指定的项目</p>\n</li>\n<li><p><code>cmake --build . --target docs-llvm-html</code> 表示只编译LLVM文档</p>\n<p>小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：<code>llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef</code>，这是一个警告，但是因为编译的时候指定了<code>-W</code>，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报<code>llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info</code>。目前我的解决办法是去掉<code>-W</code>之后单独执行：<code>sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html</code>。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。</p>\n<p>更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。</p>\n</li>\n<li><p><code>cmake --build . --target doxygen-llvm</code> 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。</p>\n</li>\n</ul>\n<p>小提示：1. 想要查看有哪些target可以去查看生成的<code>build/CMakeFiles/TargetDirectories.txt</code>文件。像这里的<code>doxygen-llvm</code>我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。</p>\n</li>\n</ol>\n<p>将前面的命令放在一起方便拷贝：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/llvm/llvm-project</span><br><span class=\"line\">// Gitee源：git clone https://gitee.com/mirrors/LLVM</span><br><span class=\"line\">cd llvm-project &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class=\"line\">cmake -G Ninja\\</span><br><span class=\"line\">  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\</span><br><span class=\"line\">  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\</span><br><span class=\"line\">  -DLLVM_ENABLE_SPHINX=ON\\</span><br><span class=\"line\">  -DLLVM_ENABLE_DOXYGEN=ON\\</span><br><span class=\"line\">  ../llvm</span><br><span class=\"line\">cmake --build . // 编译llvm、clang、libcxx</span><br><span class=\"line\">cmake --build . --target docs-llvm-html // 编译LLVM文档</span><br><span class=\"line\">cmake --build . --target doxygen-llvm // 编译LLVM API文档</span><br></pre></td></tr></table></figure>\n\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/GettingStarted.html\" target=\"_blank\" rel=\"noopener\">Getting Started with the LLVM System</a>：介绍了编译项目的基本步骤，常用参数</li>\n<li><a href=\"https://llvm.org/docs/CMake.html\" target=\"_blank\" rel=\"noopener\">Building LLVM with CMake</a>：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数</li>\n</ul>\n<h2 id=\"常用LLVM命令\"><a href=\"#常用LLVM命令\" class=\"headerlink\" title=\"常用LLVM命令\"></a>常用LLVM命令</h2><ul>\n<li>clang<ul>\n<li><code>clang -S -emit-llvm input.c -o out.ll</code>：生成人可读的LLVM IR</li>\n<li><code>clang -c -emit-llvm input.c -o out.bc</code>：生成二进制LLVM IR，也可以不加<code>-c</code>，默认编译为二进制IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/opt.html\" target=\"_blank\" rel=\"noopener\">opt</a><ul>\n<li><code>opt -load-pass-plugin=libHelloWorld.dylib -passes=&quot;hello-world&quot; a.ll</code>：使用HelloWorld Pass对<code>out.ll</code>进行处理。注意这是新的单独调用Pass的方式，老的方式为：<code>opt -load libHelloWorld.dylib -legacy-hello-world a.ll</code></li>\n<li><code>opt -analyze -view-cfg a.ll</code> 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-as.html\" target=\"_blank\" rel=\"noopener\">llvm-as</a>、<a href=\"https://llvm.org/docs/CommandGuide/llvm-dis.html\" target=\"_blank\" rel=\"noopener\">llvm-dis</a><ul>\n<li><code>llvm-as a.ll -o a.bc</code>：将人可读的LLVM IR编译为二进制LLVM IR</li>\n<li><code>llvm-dis a.bc -o a.ll</code>：将二进制LLVM IR反编译为人可读的LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llc.html\" target=\"_blank\" rel=\"noopener\">llc</a><ul>\n<li><code>llc a.ll -o a.out</code>：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/lli.html\" target=\"_blank\" rel=\"noopener\">lli</a><ul>\n<li><code>lli a.ll</code>：直接解释执行LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-link.html\" target=\"_blank\" rel=\"noopener\">llvm-link</a><ul>\n<li><code>llvm-link -S add.ll main.ll -o all.ll</code>：链接多个LLVM IR为一个LLVM IR文件，<code>-S</code>表示输出的为人可读的LLVM IR，默认为二进制LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-config.html\" target=\"_blank\" rel=\"noopener\">llvm-config</a>：使用<code>llvm-config --help</code>查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。<ul>\n<li><code>llvm-config --cxxflags</code>：生成编译时的头文件库参数，比如在我电脑上会输出<code>-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS</code></li>\n<li><code>llvm-config --ldflags</code>：生成链接时的LLVM库文件地址，比如在我电脑上会输出<code>-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names</code></li>\n<li><code>llvm-config --libs</code>：生成LLVM提供的库名称，结合<code>llvm-config --ldflags</code>，就可以让链接器找到对应的库文件。在<code>--libs</code>后面还可以添加各种组件名称，不添加表示所有组件。比如<code>--libs core native</code>，则只会输出core和native组件相关的库。通过下面的<code>llvm-config --components</code>命令可以列举出所有的LLVM组件列表</li>\n<li><code>llvm-config --components</code>：输出所有的LLVM组件</li>\n</ul>\n</li>\n</ul>\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/CommandGuide/index.html\" target=\"_blank\" rel=\"noopener\">LLVM Command Guide</a>：命令行工具使用说明</li>\n</ul>\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->","site":{"data":{}},"more":"<p>更全面的内容请直接参考<a href=\"https://llvm.org/docs\" target=\"_blank\" rel=\"noopener\">官方文档</a>，这里仅列出我在学习LLVM时用到的一些编译命令及遇到的问题，还会有些文档中没有提到的内容。</p>\n<h2 id=\"编译项目\"><a href=\"#编译项目\" class=\"headerlink\" title=\"编译项目\"></a>编译项目</h2><ol>\n<li><p>安装<a href=\"https://cmake.org\" target=\"_blank\" rel=\"noopener\">CMake</a>、<a href=\"https://ninja-build.org\" target=\"_blank\" rel=\"noopener\">Ninja</a>构建工具。</p>\n<p>这里除了Ninja构建系统，其实也可以选择其他的，比如Unix Makefiles。其中CMake可以理解为给开发者使用的构建工具接口，至于实际的构建系统，开发者可以显式指定让CMake去使用，比如下面在生成实际的构建系统时，就用了Ninja（默认为Unix Makefiles）。</p>\n</li>\n<li><p>克隆LLVM仓库：<code>git clone https://github.com/llvm/llvm-project</code></p>\n<p>如果国内clone太慢，也可以使用Gitee提供的镜像仓库<code>https://gitee.com/mirrors/LLVM</code>（注意：镜像仓库目前每天同步一次，所以内容会有延后）</p>\n</li>\n<li><p>创建构建目录，用于存放构建系统文件和构建出来的东西，比如在项目的根目录创建：<code>mkdir build</code>，然后进到构建目录： <code>cd build</code></p>\n</li>\n<li><p>生成构建系统：<code>cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx&quot; ../llvm</code></p>\n<p>常用参数：</p>\n<ul>\n<li><p><code>LLVM_ENABLE_PROJECTS</code>：比如<code>&quot;clang;libcxx&quot;</code>。打算编译的项目列表，默认会编译LLVM，这里可以指定除LLVM之外的项目，比如<code>clang</code>、<code>clang-tools-extra</code>、<code>libcxx</code>、<code>libc</code>等。</p>\n<p>小提示：所有支持的项目可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_PROJECTS</code>变量的内容。当前的内容为：<code>clang;clang-tools-extra;compiler-rt;debuginfo-tests;libc;libclc;libcxx;libcxxabi;libunwind;lld;lldb;mlir;openmp;parallel-libs;polly;pstl</code></p>\n</li>\n<li><p><code>LLVM_TARGETS_TO_BUILD</code>：比如<code>&quot;X86;RISCV&quot;</code>。指定LLVM后端支持的目标架构，比如<code>X86</code>、<code>ARM</code>、<code>RISCV</code>、<code>WebAssembly</code></p>\n<p>小提示：所有支持的目标架构可以去看<code>llvm/CMakeLists.txt</code>文件中的<code>LLVM_ALL_TARGETS</code>变量的内容。当前的内容为：<code>AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86;XCore</code></p>\n</li>\n<li><p><code>LLVM_ENABLE_SPHINX</code>：是否编译LLVM文档。<code>ON</code>表示启动。依赖<a href=\"https://www.sphinx-doc.org\" target=\"_blank\" rel=\"noopener\">Sphinx</a></p>\n</li>\n<li><p><code>LLVM_ENABLE_DOXYGEN</code>：是否编译LLVM API文档。<code>ON</code>表示启动。依赖<a href=\"https://www.doxygen.nl\" target=\"_blank\" rel=\"noopener\">Doxygen</a></p>\n</li>\n</ul>\n</li>\n<li><p>进行构建：</p>\n<ul>\n<li><p><code>cmake --build .</code> 表示编译默认目标包括LLVM和<code>LLVM_ENABLE_PROJECTS</code>指定的项目</p>\n</li>\n<li><p><code>cmake --build . --target docs-llvm-html</code> 表示只编译LLVM文档</p>\n<p>小提示：一开始我用的最新的3.1.1的Sphinx，运行这条命令会报错，在master分支上编译会提示：<code>llvm/docs/TableGen/LangRef.rst:270:duplicate token description of SimpleValue, other instance in TableGen/LangRef</code>，这是一个警告，但是因为编译的时候指定了<code>-W</code>，会将警告当作错误来对待，所以会直接退出。如果使用官方文档所用的Sphinx版本1.8.5（从文档的右下角可以看到），则会报<code>llvm/docs/CommandGuide/llvm-dwarfdump.rst:40:unknown option: --debug-info</code>。目前我的解决办法是去掉<code>-W</code>之后单独执行：<code>sphinx-build -b html -d docs/_doctrees-llvm-html -q ../llvm/docs docs/html</code>。不过打开生成的文档发现样式有点问题，每个文档的标题下面是一大块空白的，是CSS写的有问题。</p>\n<p>更新（2020-06-26）：后面又试了下，如果去当前最新的release/10.x分支，使用Sphinx 1.8.5编译，则可以编译通过。所以需要编译Sphinx文档，建议使用1.8.5版本的Sphinx，并且编译的是release/10.x分支。</p>\n</li>\n<li><p><code>cmake --build . --target doxygen-llvm</code> 表示只编译LLVM API文档，试了下发现编译需要非常长的时间，做好心理准备。官方用的Doxygen版本是1.8.13，我用的1.8.18编译目前没有发现问题。</p>\n</li>\n</ul>\n<p>小提示：1. 想要查看有哪些target可以去查看生成的<code>build/CMakeFiles/TargetDirectories.txt</code>文件。像这里的<code>doxygen-llvm</code>我就是通过这种方式找到的，文档上一直没有找到。2. 通过在本地编译文档，可以很方便后面学习LLVM时使用，在线的文档没有本地文档访问快。并且也可以添加一些中文注解，方便理解。</p>\n</li>\n</ol>\n<p>将前面的命令放在一起方便拷贝：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/llvm/llvm-project</span><br><span class=\"line\">// Gitee源：git clone https://gitee.com/mirrors/LLVM</span><br><span class=\"line\">cd llvm-project &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class=\"line\">cmake -G Ninja\\</span><br><span class=\"line\">  -DLLVM_ENABLE_PROJECTS=\"clang;libcxx\"\\</span><br><span class=\"line\">  -DLLVM_TARGETS_TO_BUILD=\"X86\"\\</span><br><span class=\"line\">  -DLLVM_ENABLE_SPHINX=ON\\</span><br><span class=\"line\">  -DLLVM_ENABLE_DOXYGEN=ON\\</span><br><span class=\"line\">  ../llvm</span><br><span class=\"line\">cmake --build . // 编译llvm、clang、libcxx</span><br><span class=\"line\">cmake --build . --target docs-llvm-html // 编译LLVM文档</span><br><span class=\"line\">cmake --build . --target doxygen-llvm // 编译LLVM API文档</span><br></pre></td></tr></table></figure>\n\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/GettingStarted.html\" target=\"_blank\" rel=\"noopener\">Getting Started with the LLVM System</a>：介绍了编译项目的基本步骤，常用参数</li>\n<li><a href=\"https://llvm.org/docs/CMake.html\" target=\"_blank\" rel=\"noopener\">Building LLVM with CMake</a>：更详细的介绍了CMake构建系统，包括CMake的基本使用和所有支持的参数</li>\n</ul>\n<h2 id=\"常用LLVM命令\"><a href=\"#常用LLVM命令\" class=\"headerlink\" title=\"常用LLVM命令\"></a>常用LLVM命令</h2><ul>\n<li>clang<ul>\n<li><code>clang -S -emit-llvm input.c -o out.ll</code>：生成人可读的LLVM IR</li>\n<li><code>clang -c -emit-llvm input.c -o out.bc</code>：生成二进制LLVM IR，也可以不加<code>-c</code>，默认编译为二进制IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/opt.html\" target=\"_blank\" rel=\"noopener\">opt</a><ul>\n<li><code>opt -load-pass-plugin=libHelloWorld.dylib -passes=&quot;hello-world&quot; a.ll</code>：使用HelloWorld Pass对<code>out.ll</code>进行处理。注意这是新的单独调用Pass的方式，老的方式为：<code>opt -load libHelloWorld.dylib -legacy-hello-world a.ll</code></li>\n<li><code>opt -analyze -view-cfg a.ll</code> 生成控制流程图（Control-flow graph），可以很方便的查看函数中的各种BB及BB直接的跳转。</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-as.html\" target=\"_blank\" rel=\"noopener\">llvm-as</a>、<a href=\"https://llvm.org/docs/CommandGuide/llvm-dis.html\" target=\"_blank\" rel=\"noopener\">llvm-dis</a><ul>\n<li><code>llvm-as a.ll -o a.bc</code>：将人可读的LLVM IR编译为二进制LLVM IR</li>\n<li><code>llvm-dis a.bc -o a.ll</code>：将二进制LLVM IR反编译为人可读的LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llc.html\" target=\"_blank\" rel=\"noopener\">llc</a><ul>\n<li><code>llc a.ll -o a.out</code>：将LLVM IR编译为汇编代码，进而可以使用原生汇编器编译为可执行文件</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/lli.html\" target=\"_blank\" rel=\"noopener\">lli</a><ul>\n<li><code>lli a.ll</code>：直接解释执行LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-link.html\" target=\"_blank\" rel=\"noopener\">llvm-link</a><ul>\n<li><code>llvm-link -S add.ll main.ll -o all.ll</code>：链接多个LLVM IR为一个LLVM IR文件，<code>-S</code>表示输出的为人可读的LLVM IR，默认为二进制LLVM IR</li>\n</ul>\n</li>\n<li><a href=\"https://llvm.org/docs/CommandGuide/llvm-config.html\" target=\"_blank\" rel=\"noopener\">llvm-config</a>：使用<code>llvm-config --help</code>查看帮助。给依赖LLVM的项目提供支持，输出LLVM库的头文件地址、库文件地址、库列表。<ul>\n<li><code>llvm-config --cxxflags</code>：生成编译时的头文件库参数，比如在我电脑上会输出<code>-I/usr/local/Cellar/llvm/10.0.0_3/include -std=c++14 -stdlib=libc++  -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS</code></li>\n<li><code>llvm-config --ldflags</code>：生成链接时的LLVM库文件地址，比如在我电脑上会输出<code>-L/usr/local/Cellar/llvm/10.0.0_3/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names</code></li>\n<li><code>llvm-config --libs</code>：生成LLVM提供的库名称，结合<code>llvm-config --ldflags</code>，就可以让链接器找到对应的库文件。在<code>--libs</code>后面还可以添加各种组件名称，不添加表示所有组件。比如<code>--libs core native</code>，则只会输出core和native组件相关的库。通过下面的<code>llvm-config --components</code>命令可以列举出所有的LLVM组件列表</li>\n<li><code>llvm-config --components</code>：输出所有的LLVM组件</li>\n</ul>\n</li>\n</ul>\n<p>官方文档参考：</p>\n<ul>\n<li><a href=\"https://llvm.org/docs/CommandGuide/index.html\" target=\"_blank\" rel=\"noopener\">LLVM Command Guide</a>：命令行工具使用说明</li>\n</ul>\n<!--\n## LLVM项目结构简介\n\n// TODO\n-->"},{"title":"Nand2Tetris Part 1 课程总结","date":"2020-07-16T16:00:00.000Z","excerpt":"按：本文记录我在学习完Coursera上的 Nand2Tetris Part 1 课程之后的总结与思考。","_content":"\n\n\n今天完成了Coursera上的 [Nand2Tetris Part 1](https://www.coursera.org/learn/build-a-computer) 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在[这里](https://gitee.com/lhtin/Nand2TetrisLabs)可以看到我完成的答案。\n\n每个Project完成情况如下：\n\n- 7-10 完成 [Project1](https://www.nand2tetris.org/project01)\n- 7-11 完成 [Project2](https://www.nand2tetris.org/project02)\n- 7-12 完成 [Project3](https://www.nand2tetris.org/project03)\n- 7-13 完成 [Project4](https://www.nand2tetris.org/project04)\n- 7-15 完成 [Project5](https://www.nand2tetris.org/project05)\n- 7-16 完成 [Project6](https://www.nand2tetris.org/project06)\n\n完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。\n\n**在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）**\n\n\n\n### 项目总结\n\n整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。\n\nProject1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。\n\n选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。\n\n下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：\n\n```\nNand(a, b) = 如果a和b同时为1，则结果为0，否则结果为1\n\n// Not(0)的情况返回1，Not(1)返回0\nNot(in) = Nand(in, in)\n\n// And(1,1)的情况返回1，其他情况返回0\nAnd(a, b) = Not(Nand(a, b))\n\n// Or(0,0)的情况返回0，其他情况返回1\nOr(a, b) = Nand(Not(a), Not(b))\n\n// 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0\nXor(a, b) = Or(And(Not(a), b), And(a, Not(b)))\n```\n\n\n\nProject2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。\n\nHack ALU支持的运算如下：\n\n```\nALU(x, y) = 0 | 1 | -1 | x | y | !x | !y | -x | -y\n          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x\n          | x&y | x|y\n```\n\n\n\nProject3引入一种新类型的电路，[时序逻辑电路](https://en.wikipedia.org/wiki/Sequential_logic)，而前面构建的都是[组合逻辑电路](https://en.wikipedia.org/wiki/Combinational_logic)。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。\n\n**话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。**\n\n\n\nProject4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。\n\n\n\nProject5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是`@123`指令，则表示将123设置到A寄存器中。\n\n完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：\n\n![](/images/nand2tetris-1/CPU.png)\n\n在设计CPU时，需要注意几点：\n\n1. A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。\n2. 根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。\n3. **每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。**\n\n\n\nProject6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。\n\nHack汇编语言BNF描述如下：\n\n```\nProgram -> Stats\nStats   -> Stat Stats\n        |  ε\nState \t-> A-Inst | C-Inst | Branch | Comment\nA-Inst \t-> \"@\" num | '@' Symbol\nC-Inst \t-> Dest comp Jump\nBranch  -> \"(\" symbol \")\"\nComment -> \"//\" [^\\n]+\n\nSymbol  -> \"R0\" | ... | \"R15\" \n        |  \"SP\" | \"LCL\" | \"ARG\" | \"THIS\" | \"THAT\" | \"SCREEN\" | \"KBD\" \n        |  symbol\nDest    -> dest \"=\"\n        |  ε\nJump    -> \";\" jump\n        |  ε\n\ndest    -> \"A\" | \"D\" | \"M\" | \"AD\" | \"AM\" | \"MD\" | \"AMD\"\ncomp    -> \"0\" | \"1\" | \"-1\" | \"D\" | \"A\" | \"!D\" | \"!A\" | \"-D\" | \"-A\"\n        | \"D+1\" | \"A+1\" | \"D-1\" | \"A-1\" | \"D+A\" | \"D-A\" | \"A-D\" | \"D&A\" | \"D|A\" \n        | \"M\" | \"!M\" | \"-M\" | \"M+1\" | \"M-1\" | \"D+M\" | \"D-M\" | \"M-D\" | \"D&M\" | \"D|M\"\njump    -> \"JGT\" | \"JEG\" | \"JGE\" | \"JLT\" | \"JNE\" | \"JLE\" | \"JMP\"\nnum     -> [0-9]+\nsymbol  -> [a-zA-Z_.$:][a-zA-Z_.$:0-9]+\n```\n\n示例程序：\n\n```\n// Computes R2 = max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])\n\n   @R0\n   D=M              // D = first number\n   @R1\n   D=D-M            // D = first number - second number\n   @OUTPUT_FIRST\n   D;JGT            // if D>0 (first is greater) goto output_first\n   @R1\n   D=M              // D = second number\n   @OUTPUT_D\n   0;JMP            // goto output_d\n(OUTPUT_FIRST)\n   @R0             \n   D=M              // D = first number\n(OUTPUT_D)\n   @R2\n   M=D              // M[2] = D (greatest number)\n(INFINITE_LOOP)\n   @INFINITE_LOOP\n   0;JMP            // infinite loop\n```\n\n","source":"_posts/nand2tetris-1.md","raw":"---\ntitle: Nand2Tetris Part 1 课程总结\ndate: 2020/07/17\ntag:\n- 笔记\ncategory:\n- 笔记\nexcerpt: 按：本文记录我在学习完Coursera上的 Nand2Tetris Part 1 课程之后的总结与思考。\n---\n\n\n\n今天完成了Coursera上的 [Nand2Tetris Part 1](https://www.coursera.org/learn/build-a-computer) 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在[这里](https://gitee.com/lhtin/Nand2TetrisLabs)可以看到我完成的答案。\n\n每个Project完成情况如下：\n\n- 7-10 完成 [Project1](https://www.nand2tetris.org/project01)\n- 7-11 完成 [Project2](https://www.nand2tetris.org/project02)\n- 7-12 完成 [Project3](https://www.nand2tetris.org/project03)\n- 7-13 完成 [Project4](https://www.nand2tetris.org/project04)\n- 7-15 完成 [Project5](https://www.nand2tetris.org/project05)\n- 7-16 完成 [Project6](https://www.nand2tetris.org/project06)\n\n完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。\n\n**在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）**\n\n\n\n### 项目总结\n\n整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。\n\nProject1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。\n\n选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。\n\n下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：\n\n```\nNand(a, b) = 如果a和b同时为1，则结果为0，否则结果为1\n\n// Not(0)的情况返回1，Not(1)返回0\nNot(in) = Nand(in, in)\n\n// And(1,1)的情况返回1，其他情况返回0\nAnd(a, b) = Not(Nand(a, b))\n\n// Or(0,0)的情况返回0，其他情况返回1\nOr(a, b) = Nand(Not(a), Not(b))\n\n// 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0\nXor(a, b) = Or(And(Not(a), b), And(a, Not(b)))\n```\n\n\n\nProject2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。\n\nHack ALU支持的运算如下：\n\n```\nALU(x, y) = 0 | 1 | -1 | x | y | !x | !y | -x | -y\n          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x\n          | x&y | x|y\n```\n\n\n\nProject3引入一种新类型的电路，[时序逻辑电路](https://en.wikipedia.org/wiki/Sequential_logic)，而前面构建的都是[组合逻辑电路](https://en.wikipedia.org/wiki/Combinational_logic)。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。\n\n**话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。**\n\n\n\nProject4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。\n\n\n\nProject5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是`@123`指令，则表示将123设置到A寄存器中。\n\n完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：\n\n![](/images/nand2tetris-1/CPU.png)\n\n在设计CPU时，需要注意几点：\n\n1. A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。\n2. 根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。\n3. **每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。**\n\n\n\nProject6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。\n\nHack汇编语言BNF描述如下：\n\n```\nProgram -> Stats\nStats   -> Stat Stats\n        |  ε\nState \t-> A-Inst | C-Inst | Branch | Comment\nA-Inst \t-> \"@\" num | '@' Symbol\nC-Inst \t-> Dest comp Jump\nBranch  -> \"(\" symbol \")\"\nComment -> \"//\" [^\\n]+\n\nSymbol  -> \"R0\" | ... | \"R15\" \n        |  \"SP\" | \"LCL\" | \"ARG\" | \"THIS\" | \"THAT\" | \"SCREEN\" | \"KBD\" \n        |  symbol\nDest    -> dest \"=\"\n        |  ε\nJump    -> \";\" jump\n        |  ε\n\ndest    -> \"A\" | \"D\" | \"M\" | \"AD\" | \"AM\" | \"MD\" | \"AMD\"\ncomp    -> \"0\" | \"1\" | \"-1\" | \"D\" | \"A\" | \"!D\" | \"!A\" | \"-D\" | \"-A\"\n        | \"D+1\" | \"A+1\" | \"D-1\" | \"A-1\" | \"D+A\" | \"D-A\" | \"A-D\" | \"D&A\" | \"D|A\" \n        | \"M\" | \"!M\" | \"-M\" | \"M+1\" | \"M-1\" | \"D+M\" | \"D-M\" | \"M-D\" | \"D&M\" | \"D|M\"\njump    -> \"JGT\" | \"JEG\" | \"JGE\" | \"JLT\" | \"JNE\" | \"JLE\" | \"JMP\"\nnum     -> [0-9]+\nsymbol  -> [a-zA-Z_.$:][a-zA-Z_.$:0-9]+\n```\n\n示例程序：\n\n```\n// Computes R2 = max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])\n\n   @R0\n   D=M              // D = first number\n   @R1\n   D=D-M            // D = first number - second number\n   @OUTPUT_FIRST\n   D;JGT            // if D>0 (first is greater) goto output_first\n   @R1\n   D=M              // D = second number\n   @OUTPUT_D\n   0;JMP            // goto output_d\n(OUTPUT_FIRST)\n   @R0             \n   D=M              // D = first number\n(OUTPUT_D)\n   @R2\n   M=D              // M[2] = D (greatest number)\n(INFINITE_LOOP)\n   @INFINITE_LOOP\n   0;JMP            // infinite loop\n```\n\n","slug":"nand2tetris-1","published":1,"updated":"2020-07-19T04:06:44.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcsk6avp0006nujkf5q6fmi0","content":"<p>今天完成了Coursera上的 <a href=\"https://www.coursera.org/learn/build-a-computer\" target=\"_blank\" rel=\"noopener\">Nand2Tetris Part 1</a> 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在<a href=\"https://gitee.com/lhtin/Nand2TetrisLabs\" target=\"_blank\" rel=\"noopener\">这里</a>可以看到我完成的答案。</p>\n<p>每个Project完成情况如下：</p>\n<ul>\n<li>7-10 完成 <a href=\"https://www.nand2tetris.org/project01\" target=\"_blank\" rel=\"noopener\">Project1</a></li>\n<li>7-11 完成 <a href=\"https://www.nand2tetris.org/project02\" target=\"_blank\" rel=\"noopener\">Project2</a></li>\n<li>7-12 完成 <a href=\"https://www.nand2tetris.org/project03\" target=\"_blank\" rel=\"noopener\">Project3</a></li>\n<li>7-13 完成 <a href=\"https://www.nand2tetris.org/project04\" target=\"_blank\" rel=\"noopener\">Project4</a></li>\n<li>7-15 完成 <a href=\"https://www.nand2tetris.org/project05\" target=\"_blank\" rel=\"noopener\">Project5</a></li>\n<li>7-16 完成 <a href=\"https://www.nand2tetris.org/project06\" target=\"_blank\" rel=\"noopener\">Project6</a></li>\n</ul>\n<p>完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。</p>\n<p><strong>在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）</strong></p>\n<h3 id=\"项目总结\"><a href=\"#项目总结\" class=\"headerlink\" title=\"项目总结\"></a>项目总结</h3><p>整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。</p>\n<p>Project1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。</p>\n<p>选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。</p>\n<p>下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nand(a, b) &#x3D; 如果a和b同时为1，则结果为0，否则结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Not(0)的情况返回1，Not(1)返回0</span><br><span class=\"line\">Not(in) &#x3D; Nand(in, in)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; And(1,1)的情况返回1，其他情况返回0</span><br><span class=\"line\">And(a, b) &#x3D; Not(Nand(a, b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Or(0,0)的情况返回0，其他情况返回1</span><br><span class=\"line\">Or(a, b) &#x3D; Nand(Not(a), Not(b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0</span><br><span class=\"line\">Xor(a, b) &#x3D; Or(And(Not(a), b), And(a, Not(b)))</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。</p>\n<p>Hack ALU支持的运算如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALU(x, y) &#x3D; 0 | 1 | -1 | x | y | !x | !y | -x | -y</span><br><span class=\"line\">          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x</span><br><span class=\"line\">          | x&amp;y | x|y</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project3引入一种新类型的电路，<a href=\"https://en.wikipedia.org/wiki/Sequential_logic\" target=\"_blank\" rel=\"noopener\">时序逻辑电路</a>，而前面构建的都是<a href=\"https://en.wikipedia.org/wiki/Combinational_logic\" target=\"_blank\" rel=\"noopener\">组合逻辑电路</a>。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。</p>\n<p><strong>话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。</strong></p>\n<p>Project4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。</p>\n<p>Project5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是<code>@123</code>指令，则表示将123设置到A寄存器中。</p>\n<p>完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：</p>\n<p><img src=\"/images/nand2tetris-1/CPU.png\" alt=\"\"></p>\n<p>在设计CPU时，需要注意几点：</p>\n<ol>\n<li>A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。</li>\n<li>根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。</li>\n<li><strong>每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。</strong></li>\n</ol>\n<p>Project6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。</p>\n<p>Hack汇编语言BNF描述如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program -&gt; Stats</span><br><span class=\"line\">Stats   -&gt; Stat Stats</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">State \t-&gt; A-Inst | C-Inst | Branch | Comment</span><br><span class=\"line\">A-Inst \t-&gt; &quot;@&quot; num | &#39;@&#39; Symbol</span><br><span class=\"line\">C-Inst \t-&gt; Dest comp Jump</span><br><span class=\"line\">Branch  -&gt; &quot;(&quot; symbol &quot;)&quot;</span><br><span class=\"line\">Comment -&gt; &quot;&#x2F;&#x2F;&quot; [^\\n]+</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol  -&gt; &quot;R0&quot; | ... | &quot;R15&quot; </span><br><span class=\"line\">        |  &quot;SP&quot; | &quot;LCL&quot; | &quot;ARG&quot; | &quot;THIS&quot; | &quot;THAT&quot; | &quot;SCREEN&quot; | &quot;KBD&quot; </span><br><span class=\"line\">        |  symbol</span><br><span class=\"line\">Dest    -&gt; dest &quot;&#x3D;&quot;</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">Jump    -&gt; &quot;;&quot; jump</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\"></span><br><span class=\"line\">dest    -&gt; &quot;A&quot; | &quot;D&quot; | &quot;M&quot; | &quot;AD&quot; | &quot;AM&quot; | &quot;MD&quot; | &quot;AMD&quot;</span><br><span class=\"line\">comp    -&gt; &quot;0&quot; | &quot;1&quot; | &quot;-1&quot; | &quot;D&quot; | &quot;A&quot; | &quot;!D&quot; | &quot;!A&quot; | &quot;-D&quot; | &quot;-A&quot;</span><br><span class=\"line\">        | &quot;D+1&quot; | &quot;A+1&quot; | &quot;D-1&quot; | &quot;A-1&quot; | &quot;D+A&quot; | &quot;D-A&quot; | &quot;A-D&quot; | &quot;D&amp;A&quot; | &quot;D|A&quot; </span><br><span class=\"line\">        | &quot;M&quot; | &quot;!M&quot; | &quot;-M&quot; | &quot;M+1&quot; | &quot;M-1&quot; | &quot;D+M&quot; | &quot;D-M&quot; | &quot;M-D&quot; | &quot;D&amp;M&quot; | &quot;D|M&quot;</span><br><span class=\"line\">jump    -&gt; &quot;JGT&quot; | &quot;JEG&quot; | &quot;JGE&quot; | &quot;JLT&quot; | &quot;JNE&quot; | &quot;JLE&quot; | &quot;JMP&quot;</span><br><span class=\"line\">num     -&gt; [0-9]+</span><br><span class=\"line\">symbol  -&gt; [a-zA-Z_.$:][a-zA-Z_.$:0-9]+</span><br></pre></td></tr></table></figure>\n\n<p>示例程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Computes R2 &#x3D; max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])</span><br><span class=\"line\"></span><br><span class=\"line\">   @R0</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;D-M            &#x2F;&#x2F; D &#x3D; first number - second number</span><br><span class=\"line\">   @OUTPUT_FIRST</span><br><span class=\"line\">   D;JGT            &#x2F;&#x2F; if D&gt;0 (first is greater) goto output_first</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; second number</span><br><span class=\"line\">   @OUTPUT_D</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; goto output_d</span><br><span class=\"line\">(OUTPUT_FIRST)</span><br><span class=\"line\">   @R0             </span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">(OUTPUT_D)</span><br><span class=\"line\">   @R2</span><br><span class=\"line\">   M&#x3D;D              &#x2F;&#x2F; M[2] &#x3D; D (greatest number)</span><br><span class=\"line\">(INFINITE_LOOP)</span><br><span class=\"line\">   @INFINITE_LOOP</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; infinite loop</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"more":"<p>今天完成了Coursera上的 <a href=\"https://www.coursera.org/learn/build-a-computer\" target=\"_blank\" rel=\"noopener\">Nand2Tetris Part 1</a> 课程，写一篇文章总结一下。这次学习的速度非常快，从7月10开始完成第一个Project，到7月16完成最后一个Project。前后一周时间，其中Project5制作CPU和Computer花了两天时间，其余都是用一天时间完成。其中7月11和7月12是周末，花的时间比较多。工作日的话，会在上下班通勤过程中看电子教程，然后晚上回家会花大概2、3个小时。合计总耗时大概在30个小时左右。在<a href=\"https://gitee.com/lhtin/Nand2TetrisLabs\" target=\"_blank\" rel=\"noopener\">这里</a>可以看到我完成的答案。</p>\n<p>每个Project完成情况如下：</p>\n<ul>\n<li>7-10 完成 <a href=\"https://www.nand2tetris.org/project01\" target=\"_blank\" rel=\"noopener\">Project1</a></li>\n<li>7-11 完成 <a href=\"https://www.nand2tetris.org/project02\" target=\"_blank\" rel=\"noopener\">Project2</a></li>\n<li>7-12 完成 <a href=\"https://www.nand2tetris.org/project03\" target=\"_blank\" rel=\"noopener\">Project3</a></li>\n<li>7-13 完成 <a href=\"https://www.nand2tetris.org/project04\" target=\"_blank\" rel=\"noopener\">Project4</a></li>\n<li>7-15 完成 <a href=\"https://www.nand2tetris.org/project05\" target=\"_blank\" rel=\"noopener\">Project5</a></li>\n<li>7-16 完成 <a href=\"https://www.nand2tetris.org/project06\" target=\"_blank\" rel=\"noopener\">Project6</a></li>\n</ul>\n<p>完成了所有Project之后，我感觉自己需要慢下来做一次总结，加深理解。先回顾每个Project做的事情，整体思考下计算机硬件的组成原理。然后重点总结下CPU的原理，这是我花时间最多的地方。</p>\n<p><strong>在数字电路的设计过程中，发现很多时候会多做一些事件。比如根据条件做计算。因为事先并不知道会进入哪一个计算，所以在数字电路中实际上会两个计算都做，然后根据条件选择对应的计算结果，而不是说不去执行没有选中的那个计算。（更新7月19：最近又想了下，即使不对没有用到的计算做实际计算，其实这部分电路依然需要执行，只是执行的东西是任意的，没有意义而已）</strong></p>\n<h3 id=\"项目总结\"><a href=\"#项目总结\" class=\"headerlink\" title=\"项目总结\"></a>项目总结</h3><p>整个课程，除了Project6是开发汇编器，其余的都是跟硬件相关。</p>\n<p>Project1使用最原始的与非门（Nand），使用硬件描述语言（HDL）开发非门（Not、Not16）、与门（And、And16）、或门（Or、Or16、Or8Way）、异或门（Xor）、选择器（Mux、Mux16、Mux4Way16、Mux8Way16）、分配器（DMux、DMux4Way、DMux8Way）。只要了解每个电路的功能（也就是布尔运算规则），实现这些电路就不难了，可以通过在纸上写出真值表来尝试各种可能。</p>\n<p>选择与非门的一个重要原因是因为其他的电路都可以通过它来实现，但如果选或门或者与门就没法实现。当时开发时不理解为什么要扩展成这些电路，其他电路不行吗。做到后面的Project时就明白了，因为后面都会用到。所以有时候我在想，老师是怎么知道恰好需要这些电路的呢？我怀疑老师是先假设需要实现某种电脑规范，然后通过一层一层分解，最终推出所需要的电路，然后安排在Project中去完成。这也挺有意思的，老师的设计思路跟上课的内容刚好相反。所以即使我能够完成所有的Project，如果让我自己来设计一台电脑，大概率是没法设计出来。</p>\n<p>下面列举下非门、与门、或门和异或门是如何构建的，非常的巧妙（注意实际的项目中是使用一种HDL语言来描述）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nand(a, b) &#x3D; 如果a和b同时为1，则结果为0，否则结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Not(0)的情况返回1，Not(1)返回0</span><br><span class=\"line\">Not(in) &#x3D; Nand(in, in)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; And(1,1)的情况返回1，其他情况返回0</span><br><span class=\"line\">And(a, b) &#x3D; Not(Nand(a, b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Or(0,0)的情况返回0，其他情况返回1</span><br><span class=\"line\">Or(a, b) &#x3D; Nand(Not(a), Not(b))</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让Xor(0,1)或者Xor(1,0)的情况返回1，其他情况返回0</span><br><span class=\"line\">Xor(a, b) &#x3D; Or(And(Not(a), b), And(a, Not(b)))</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project2使用Project1构建的各种电路构建加法器（HalfAdder、FullAdder、Add16、Inc16）和CPU中的算数逻辑单元（ALU）。本项目中的ALU功能比较简单，只包含基本的加减运算，不包括乘法和除法运算。从最基本的2个bit相加开始构建加法器比较简单，稍微困难点的是构建ALU。基本的解决思路是先计算出某个控制位控制的两种运算，然后让选择器根据控制位最终去选择所需要的结果。在整个的开发过程中，可以充分利用课程提供的Hardware Simulator工具和测试脚本进行验证。通过观察具体是什么语句出错，可以很容易找到问题并解决。</p>\n<p>Hack ALU支持的运算如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALU(x, y) &#x3D; 0 | 1 | -1 | x | y | !x | !y | -x | -y</span><br><span class=\"line\">          | x+1 | y+1 | x-1 | y-1 | x+y | x-y | y-x</span><br><span class=\"line\">          | x&amp;y | x|y</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Project3引入一种新类型的电路，<a href=\"https://en.wikipedia.org/wiki/Sequential_logic\" target=\"_blank\" rel=\"noopener\">时序逻辑电路</a>，而前面构建的都是<a href=\"https://en.wikipedia.org/wiki/Combinational_logic\" target=\"_blank\" rel=\"noopener\">组合逻辑电路</a>。在时序逻辑电路中，物理时间会被切分成一个一个的离散时间，即时钟周期。时序逻辑电路的特点是其输出跟时间有关系，也就是说T时钟周期的输出，跟T-1时钟周期的输入有关系。Project3提供了内置的DFF触发器，功能是将T-1时钟周期的输入，在T时钟周期输出，即将输入延后一个时钟周期输出。在结合前面制作的组合逻辑电路，就可以制造出本项目中的所有电路，包括Bit（1位存储器）、Register（16位存储器）、RAM系列（RAM8、RAM64、RAM512、RAM4K、RAM16K）、PC（程序计数器）。</p>\n<p><strong>话说为什么要引入时序逻辑电路呢？如果我需要执行的计算能够完全通过组合逻辑电路瞬间完成，且不是很香？我想，引入时序逻辑电路应该是一种用时间换取空间的策略。比如假设我需要执行a+b+c这个动作，如果我设计一个组合逻辑电路，那需要设计2个加法器才行，第一个加法器将a和b相加，第二个加法器将第一个加法器的结果加上c，得出最终的结果。但如果使用时序逻辑电路，其实我们只需要一个加法器，在第二次做加法的时候，将第一次做加法的结果作为输入重新传给加法器。这样，不管有多少次加法运算，我们都只需要一个加法器电路，只要保证每次加法运算在时间上错开进行。进一步，不管我们的程序多复杂，只需要设计一个能执行每一种指令的CPU即可，然后按照时间顺序一条一条执行，而不需要设计一个跟我们的程序等价的组合逻辑电路。这样的电路非常复杂，而且这种电路一点都不通用。</strong></p>\n<p>Project4介绍Hack计算机的机器语言规范，包括机器语言和对应的汇编语言。类似x86汇编，但是简单很多。先来简单介绍下Hack计算机，Hack计算机包含了一个CPU和两个寄存器（A和D）。其中A中的值可以当成数据来用，也可以当成RAM中的内存地址来用。当成内存地址用时，M会代表地址中的值。D用于存储数据。此外还提供了存储指令的ROM和存储数据的RAM。在RAM中，有一块区域代表显示器内存，通过修改该区域的内容，就可以控制屏幕的显示内容（项目中只支持显示黑白两种颜色）。还有另外一个区域，表示当前键盘按下的键值，通过读取该区域的值，就可以知道当前用户按的键。最后，Hack计算机还包含一个PC程序计数器，可以输出下一条指令所处的ROM地址。</p>\n<p>Project5根据Project1-3中的电路，实现一个支持Project4所描述的功能的计算机硬件。主要包括指令存储器ROM、内存RAM和CPU，其中最难实现的要属CPU（我认为这也是整个课程最难的部分了）。项目中已经提供了CPU的基本电路图，需要我们做的是根据指令，生成各个电路的控制内容。比如如果是<code>@123</code>指令，则表示将123设置到A寄存器中。</p>\n<p>完整的CPU电路图如下（红色部分即为缺失的，需要我们完成的逻辑）：</p>\n<p><img src=\"/images/nand2tetris-1/CPU.png\" alt=\"\"></p>\n<p>在设计CPU时，需要注意几点：</p>\n<ol>\n<li>A类指令和C类指令，控制的位置不一样，A类指令控制A寄存器的读写，C类指令控制的是ALU的计算，以及计算完是否将结果写入A寄存器和D寄存器。</li>\n<li>根据C类指令和ALU的计算结果，设置PC电路的各个输入，从而输出下一条指令的ROM地址。</li>\n<li><strong>每条指令都是执行一个时钟周期（这点非常重要）。这点决定了在处理C类指令时，是直接将指令中的控制位传给ALU等对应的位置。而不是想成先经过A寄存器（一个时钟周期），然后经过ALU运算，才设置D寄存器和A寄存器（又是一个时钟周期）。一开始这样子想导致我当时将控制位也进行延后一个时钟周期处理。这一点我是通过CPU的测试文件看出来的。测试中在设置了指令之后，就调用Tick Tock一次，所以是一个时钟周期。</strong></li>\n</ol>\n<p>Project6是实现一个汇编器程序，将Hack汇编语言转化为Hack机器语言。我使用JS实现，相对来说比较简单。为了方便调试程序的问题，我将我自己写的汇编器程序所生成的机器码和课程提供了汇编器生成的机器码做文件级别的diff比较，这样会比较容易看出是哪行代码翻译的问题。为了方便查找转化后的行数对应到源码中的指令，我会在汇编过程中输出仅移除源码中的符号、注释和空格之后的源代码文件。</p>\n<p>Hack汇编语言BNF描述如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program -&gt; Stats</span><br><span class=\"line\">Stats   -&gt; Stat Stats</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">State \t-&gt; A-Inst | C-Inst | Branch | Comment</span><br><span class=\"line\">A-Inst \t-&gt; &quot;@&quot; num | &#39;@&#39; Symbol</span><br><span class=\"line\">C-Inst \t-&gt; Dest comp Jump</span><br><span class=\"line\">Branch  -&gt; &quot;(&quot; symbol &quot;)&quot;</span><br><span class=\"line\">Comment -&gt; &quot;&#x2F;&#x2F;&quot; [^\\n]+</span><br><span class=\"line\"></span><br><span class=\"line\">Symbol  -&gt; &quot;R0&quot; | ... | &quot;R15&quot; </span><br><span class=\"line\">        |  &quot;SP&quot; | &quot;LCL&quot; | &quot;ARG&quot; | &quot;THIS&quot; | &quot;THAT&quot; | &quot;SCREEN&quot; | &quot;KBD&quot; </span><br><span class=\"line\">        |  symbol</span><br><span class=\"line\">Dest    -&gt; dest &quot;&#x3D;&quot;</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\">Jump    -&gt; &quot;;&quot; jump</span><br><span class=\"line\">        |  ε</span><br><span class=\"line\"></span><br><span class=\"line\">dest    -&gt; &quot;A&quot; | &quot;D&quot; | &quot;M&quot; | &quot;AD&quot; | &quot;AM&quot; | &quot;MD&quot; | &quot;AMD&quot;</span><br><span class=\"line\">comp    -&gt; &quot;0&quot; | &quot;1&quot; | &quot;-1&quot; | &quot;D&quot; | &quot;A&quot; | &quot;!D&quot; | &quot;!A&quot; | &quot;-D&quot; | &quot;-A&quot;</span><br><span class=\"line\">        | &quot;D+1&quot; | &quot;A+1&quot; | &quot;D-1&quot; | &quot;A-1&quot; | &quot;D+A&quot; | &quot;D-A&quot; | &quot;A-D&quot; | &quot;D&amp;A&quot; | &quot;D|A&quot; </span><br><span class=\"line\">        | &quot;M&quot; | &quot;!M&quot; | &quot;-M&quot; | &quot;M+1&quot; | &quot;M-1&quot; | &quot;D+M&quot; | &quot;D-M&quot; | &quot;M-D&quot; | &quot;D&amp;M&quot; | &quot;D|M&quot;</span><br><span class=\"line\">jump    -&gt; &quot;JGT&quot; | &quot;JEG&quot; | &quot;JGE&quot; | &quot;JLT&quot; | &quot;JNE&quot; | &quot;JLE&quot; | &quot;JMP&quot;</span><br><span class=\"line\">num     -&gt; [0-9]+</span><br><span class=\"line\">symbol  -&gt; [a-zA-Z_.$:][a-zA-Z_.$:0-9]+</span><br></pre></td></tr></table></figure>\n\n<p>示例程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Computes R2 &#x3D; max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])</span><br><span class=\"line\"></span><br><span class=\"line\">   @R0</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;D-M            &#x2F;&#x2F; D &#x3D; first number - second number</span><br><span class=\"line\">   @OUTPUT_FIRST</span><br><span class=\"line\">   D;JGT            &#x2F;&#x2F; if D&gt;0 (first is greater) goto output_first</span><br><span class=\"line\">   @R1</span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; second number</span><br><span class=\"line\">   @OUTPUT_D</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; goto output_d</span><br><span class=\"line\">(OUTPUT_FIRST)</span><br><span class=\"line\">   @R0             </span><br><span class=\"line\">   D&#x3D;M              &#x2F;&#x2F; D &#x3D; first number</span><br><span class=\"line\">(OUTPUT_D)</span><br><span class=\"line\">   @R2</span><br><span class=\"line\">   M&#x3D;D              &#x2F;&#x2F; M[2] &#x3D; D (greatest number)</span><br><span class=\"line\">(INFINITE_LOOP)</span><br><span class=\"line\">   @INFINITE_LOOP</span><br><span class=\"line\">   0;JMP            &#x2F;&#x2F; infinite loop</span><br></pre></td></tr></table></figure>\n\n"},{"title":"6月7日在OSDT线上技术讨论会上的分享视频","date":"2020-07-02T05:03:13.000Z","excerpt":"按：我在6月7日报名参加了OSDT线上技术讨论会，做了以《QuickJS架构及源代码分析》为主题的直播分享。本文用于记录一下相关的资源，包括分享视频、PPT、代码注释和笔记等。","_content":"\n- 分享视频B站地址：\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=1 （重新录的，时长48分钟）\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=2 （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）\n- 对QuickJS做的一些代码注释、笔记、流程图等资料：https://gitee.com/lhtin/quickjs\n- 分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\n\n","source":"_posts/quickjs.md","raw":"---\ntitle: 6月7日在OSDT线上技术讨论会上的分享视频\ndate: 2020-07-02 13:03:13\ncategories:\n- js\ntags:\n- js\n- quickjs\nexcerpt: 按：我在6月7日报名参加了OSDT线上技术讨论会，做了以《QuickJS架构及源代码分析》为主题的直播分享。本文用于记录一下相关的资源，包括分享视频、PPT、代码注释和笔记等。\n---\n\n- 分享视频B站地址：\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=1 （重新录的，时长48分钟）\n  - https://www.bilibili.com/video/BV1bt4y1y79L?p=2 （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）\n- 对QuickJS做的一些代码注释、笔记、流程图等资料：https://gitee.com/lhtin/quickjs\n- 分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\n\n","slug":"quickjs","published":1,"updated":"2020-07-03T16:24:17.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcsk6avt000anujk6avmbnfj","content":"<ul>\n<li>分享视频B站地址：<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=1\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=1</a> （重新录的，时长48分钟）</li>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=2\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=2</a> （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）</li>\n</ul>\n</li>\n<li>对QuickJS做的一些代码注释、笔记、流程图等资料：<a href=\"https://gitee.com/lhtin/quickjs\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs</a></li>\n<li>分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：<a href=\"https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf</a></li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li>分享视频B站地址：<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=1\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=1</a> （重新录的，时长48分钟）</li>\n<li><a href=\"https://www.bilibili.com/video/BV1bt4y1y79L?p=2\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1bt4y1y79L?p=2</a> （直播录的，因为直播卡顿没录全，视频和声音不同步，时长21分钟，建议直接看重新录播的）</li>\n</ul>\n</li>\n<li>对QuickJS做的一些代码注释、笔记、流程图等资料：<a href=\"https://gitee.com/lhtin/quickjs\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs</a></li>\n<li>分享的PPT：可以在quickjs项目的tin目录下找到key和pdf两个格式的文件，这里给出pdf版的链接：<a href=\"https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf\" target=\"_blank\" rel=\"noopener\">https://gitee.com/lhtin/quickjs/raw/master/tin/QuickJS架构及源代码分析-分享用.pdf</a></li>\n</ul>\n"},{"title":"学习LLVM第1篇：官方入门教程笔记","date":"2020-07-08T16:18:02.000Z","excerpt":"按：本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。","_content":"\n官方教程地址：https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\n\n\n\n## 简介\n\n这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。\n\n教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。\n\n如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。\n\n\n\n## 每个章节详解\n\n下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。\n\n\n\n### 第1、2章\n\n实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。\n\n词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。\n\n语法解析部分使用了自顶向下的递归下降语法分析方法（[Recursive Descent Parsing](http://en.wikipedia.org/wiki/Recursive_descent_parser)），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。\n\n不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（[Operator-Precedence Parsing](http://en.wikipedia.org/wiki/Operator-precedence_parser)）。具体的原理大概是这样子的，比如对于`a + b * c`表达式，`+`的优先级为10，`*`的优先级为20。在解析到`+`号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析`+`号。具体到这个例子，`*`号的优先级比`+`号的高，所以在解析到`a + b`的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的`*`号是否优先级更高。因为`*`号的优先级较高，所以会让`a +`先等着，先解析`b * c`。得到一个表达式后作为一个完整的操作数（作为`+`号的第二个操作数），并回来解析`a +`。\n\n语言BNF定义如下：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n示例代码：\n\n```\nextern sin(arg); # 外部函数\nsin(1);\n\ndef f(a b c)\n  a + (b * c);\nf(1, 2, 3);\n```\n\n\n\n### 第3章\n\n这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：\n\n![](/images/llvm-1/AST.png)\n\n接下来我们来看两个示例，看下他们对应的AST的样子：\n\n1. 函数定义示例\n\n   ```\n   def add (a b)\n     a + b;\n   ```\n\n   ![](/images/llvm-1/FuncDef.png)\n\n2. 表达式示例\n\n   ```\n   add(1, 2);\n   ```\n\n   ![](/images/llvm-1/Expr.png)\n\n有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用`ConstantFP::get(TheContext, APFloat(Val))`即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：\n\n```c++\n// NumExpr:\nConstantFP::get(TheContext, APFloat(Val));\n\n// VariableExpr:\n// 根据名称从NamedValues Map中获取对应的Value\nValue *V = NamedValues[Name];\n\n// CallExpr:\n// 1. 根据函数名称获取前面定义了的函数实例\nFunction *CalleeF = TheModule->getFunction(Callee);\n// 2. 确定每个参数的Value\nstd::vector<Value *> ArgsV;\nfor (unsigned i = 0, e = Args.size(); i != e; ++i) {\n  ArgsV.push_back(Args[i]->codegen());\n  if (!ArgsV.back())\n    return nullptr;\n}\n// 3. 创建Call指令\nBuilder.CreateCall(CalleeF, ArgsV, \"calltmp\");\n\n// BinaryExpr:\n// 1. 确定左右操作数的Value\nValue *L = LHS->codegen();\nValue *R = RHS->codegen();\n// 2. 根据操作符，创建对应的操作\nswitch (Op) {\n  case '+':\n    return Builder.CreateFAdd(L, R, \"addtmp\");\n  case '-':\n    return Builder.CreateFSub(L, R, \"subtmp\");\n  case '*':\n    return Builder.CreateFMul(L, R, \"multmp\");\n  case '<':\n    L = Builder.CreateFCmpULT(L, R, \"cmptmp\");\n    // Convert bool 0/1 to double 0.0 or 1.0\n    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), \"booltmp\");\n}\n\n// FuncProto:\n// 创建参数列表的类型\nstd::vector<Type *> Doubles(Args.size(), Type::getDoubleTy(TheContext));\n// 函数原型\nFunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);\n// 生成函数实例\nFunction *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());\n\n// FuncDef:\nFunction *TheFunction = Proto->codegen();\n// 收集参数变量，用于body中的访问\nNamedValues.clear();\nfor (auto &Arg : TheFunction->args()) {\n  NamedValues[Arg.getName()] = &Arg;\n}\n// 创建函数的body BB，并设置指令插入的位置为底部\nBasicBlock *BB = BasicBlock::Create(TheContext, \"entry\", TheFunction);\nBuilder.SetInsertPoint(BB);\nValue *RetVal = Body->codegen();\n// 设置返回指定，指定返回的内容\nBuilder.CreateRet(RetVal);\n```\n\n在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：\n\n```\nextern foo(a);\ndef foo(b) b; // 两个函数原型的参数名称不一样\n```\n\n下面给出我的解决方法：\n\n```c++\nFunction *TheFunction = TheModule->getFunction(Proto->getName());\nif (!TheFunction) {\n  TheFunction = Proto->codegen();\n} else {\n  // 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了\n  unsigned idx = 0;\n  for (auto &Arg : TheFunction->args()) {\n    // getArgName是新增的根据idx获取参数名称的方法\n    Arg.setName(Proto->getArgName(idx++));\n  }\n}\n```\n\n\n\n### 第4章\n\n讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。\n\n关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：\n\n```c++\nvoid InitializeModuleAndPassManager(void) {\n  TheModule = std::make_unique<Module>(\"my cool jit\", TheContext);\n  TheFPM = std::make_unique<FunctionPassManager>(TheModule.get());\n\n  // 优化一：Do simple \"peephole\" optimizations and bit-twiddling optzns.\n  TheFPM->add(createInstructionCombiningPass());\n  // 优化二：Reassociate expressions.\n  TheFPM->add(createReassociatePass());\n  // 优化三：Eliminate Common SubExpressions.\n  TheFPM->add(createGVNPass());\n  // 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).\n  TheFPM->add(createCFGSimplificationPass());\n\n  TheFPM->doInitialization();\n}\n```\n\n对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：\n\n```c++\n  if (auto FnAST = ParseTopLevelExpr()) {\n    if (FnAST->codegen()) {\n      // 将TopLevelExpr所在的模块添加到JIT实例中\n      auto H = TheJIT->addModule(std::move(TheModule));\n      InitializeModuleAndPassManager();\n\n      // 编译万之后找到__anon_expr的内存地址\n      auto ExprSymbol = TheJIT->findSymbol(\"__anon_expr\");\n      // 转化为函数指针后进行调用\n      double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();\n      fprintf(stderr, \"Evaluated to %f\\n\", FP());\n      // 执行完之后删除\n      TheJIT->removeModule(H);\n    }\n```\n\n另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。\n\n\n\n### 第5章\n\n本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。\n\n扩展后语言的BNF定义如下：\n\n```\n...\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n...\n```\n\n示例代码：\n\n```\n# If语句\nif 1 < 2 \nthen 3\nelse f(1, 2, 3);\n\n# For语句，1.00增长步伐可以省略\nfor i = 0, i < 100, 1.00 in\n  f(1, 2, i);\n```\n\nIR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。\n\n生成条件语句的LLVM IR：\n\n```c++\nValue *CondV = Cond->codegen();\nCondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(TheContext, APFloat(0.0)), \"ifcond\");\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *ThenBB = BasicBlock::Create(TheContext, \"then\", TheFunction); // 自动加到函数中\nBasicBlock *ElseBB = BasicBlock::Create(TheContext, \"else\");\nBasicBlock *MergeBB = BasicBlock::Create(TheContext, \"ifcont\");\n\nBuilder.CreateCondBr(CondV, ThenBB, ElseBB); // 插入条件分支语句的指令\n\n// Then语句处理\nBuilder.SetInsertPoint(ThenBB);\nValue *ThenV = Then->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nThenBB = Builder.GetInsertBlock(); // 获取Then语句的出口\n\n// Else语句处理\nTheFunction->getBasicBlockList().push_back(ElseBB); // 添加到函数中去\nBuilder.SetInsertPoint(ElseBB);\nValue *ElseV = Else->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nElseBB = Builder.GetInsertBlock(); // 获取Else语句的出口\n\n// PHI指令的生成\nTheFunction->getBasicBlockList().push_back(MergeBB);\nBuilder.SetInsertPoint(MergeBB);\nPHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, \"iftmp\");\nPN->addIncoming(ThenV, ThenBB);\nPN->addIncoming(ElseV, ElseBB);\n```\n\n生成For语句的LLVM IR：\n\n```c++\nValue *StartVal = Start->codegen();\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *PreheaderBB = Builder.GetInsertBlock();\nBasicBlock *LoopBB = BasicBlock::Create(TheContext, \"loop\", TheFunction);\nBuilder.CreateBr(LoopBB); // 跳转到Loop分支\n\nBuilder.SetInsertPoint(LoopBB);\n// 创建PHI节点\nPHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, VarName.c_str());\nVariable->addIncoming(StartVal, PreheaderBB);\nNamedValues[VarName] = Variable; // 将for定义的变量添加到作用域中\nBody->codegen();\nValue *StepVal = Step->codegen();\nValue *NextVar = Builder.CreateFAdd(Variable, StepVal, \"nextvar\");\nValue *EndCond = End->codegen();\nEndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(TheContext, APFloat(0.0)), \"loopcond\");\nBasicBlock *LoopEndBB = Builder.GetInsertBlock(); // 为啥不可以直接使用LoopBB，而是还要获取一次呢？\nBasicBlock *AfterBB = BasicBlock::Create(TheContext, \"afterloop\", TheFunction);\nBuilder.CreateCondBr(EndCond, LoopBB, AfterBB);\n\nBuilder.SetInsertPoint(AfterBB);\nVariable->addIncoming(NextVar, LoopEndBB);\n```\n\n\n\n### 第6章\n\n本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：\n\n```\n...\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\n...\n```\n\n示例代码：\n\n```\n# 取反\ndef unary ! (v)\n  if v then 0 else 1;\n\n# 或运算，5为二元操作符的优先级\ndef binary | 5 (LHS RHS)\n  if LHS then\n    1\n  else \n    if RHS then\n      1\n    else\n      0;\n```\n\n这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。\n\n\n\n### 第7章\n\n本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了`mem2reg`的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用`mem2reg`Pass进行转化即可。\n\n这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为`mem2reg`只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。\n\n语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n              |  ident \"=\" Expr\n              |  \"var\" VarDef [ \",\" VarDef ] \"in\" Expr\nVarDef        -> ident | ident \"=\" Expr\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n新增语法对应的示例代码：\n\n```\ndef binary : 1 (x y) y; # 取两个表达式中的后一个表达式\n\ndef fib(x)\n  var a = 1, b = 1, c in\n  (for i = 3, i < x in\n     c = a + b :\n     a = b :\n     b = c) :\n  b;\n\nfib(10);\n```\n\n\n\n### 第8章\n\n本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。\n\n```c++\nauto TargetTriple = sys::getDefaultTargetTriple();\nInitializeAllTargetInfos();\nInitializeAllTargets();\nInitializeAllTargetMCs();\nInitializeAllAsmParsers();\nInitializeAllAsmPrinters();\n// 获取当前平台相关的Target\nstd::string Error;\nauto Target = TargetRegistry::lookupTarget(TargetTriple, Error);\n// 生成TargetMatchine\nauto CPU = \"generic\";\nauto Features = \"\";\nTargetOptions opt;\nauto RM = Optional<Reloc::Model>();\nauto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, RM);\n// 生成目标代码\nauto Filename = \"output.o\";\nstd::error_code EC;\nraw_fd_ostream dest(Filename, EC, sys::fs::OF_None);\nlegacy::PassManager pass;\nauto FileType = CGFT_ObjectFile;\nTargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)\npass.run(*TheModule);\ndest.flush(); // 更新到磁盘\n```\n\n\n\n### 第9章\n\n本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是[DWARF](http://dwarfstd.org)标准格式的调试信息。\n\n具体的代码可以直接看对应的章节。\n\n\n\n### 第10章\n\n本章是最后的总结。\n\n首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。\n\n然后是讲了下LLVM的一些属性：\n\n- LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。\n- LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。\n- 编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass\n\n最后提到了两个避坑指令：\n\n- 关于`offset/sizeof`的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt)。\n\n- 关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt)\n\n\n\n## 遇到的问题\n\n- 第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给`--libs`增加`orcjit`参数\n  - 原来：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native`\n  - 需改为：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit` \n  - 或者直接改为`all`：`llvm-config --cxxflags --ldflags --system-libs --libs all`\n\n","source":"_posts/llvm-1.md","raw":"---\ntitle: 学习LLVM第1篇：官方入门教程笔记\ndate: 2020-07-09 00:18:02\ncategories:\n- llvm\ntags:\n- llvm\nexcerpt: 按：本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。\n---\n\n官方教程地址：https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\n\n\n\n## 简介\n\n这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。\n\n教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。\n\n如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。\n\n\n\n## 每个章节详解\n\n下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。\n\n\n\n### 第1、2章\n\n实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。\n\n词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。\n\n语法解析部分使用了自顶向下的递归下降语法分析方法（[Recursive Descent Parsing](http://en.wikipedia.org/wiki/Recursive_descent_parser)），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。\n\n不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（[Operator-Precedence Parsing](http://en.wikipedia.org/wiki/Operator-precedence_parser)）。具体的原理大概是这样子的，比如对于`a + b * c`表达式，`+`的优先级为10，`*`的优先级为20。在解析到`+`号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析`+`号。具体到这个例子，`*`号的优先级比`+`号的高，所以在解析到`a + b`的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的`*`号是否优先级更高。因为`*`号的优先级较高，所以会让`a +`先等着，先解析`b * c`。得到一个表达式后作为一个完整的操作数（作为`+`号的第二个操作数），并回来解析`a +`。\n\n语言BNF定义如下：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n示例代码：\n\n```\nextern sin(arg); # 外部函数\nsin(1);\n\ndef f(a b c)\n  a + (b * c);\nf(1, 2, 3);\n```\n\n\n\n### 第3章\n\n这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：\n\n![](/images/llvm-1/AST.png)\n\n接下来我们来看两个示例，看下他们对应的AST的样子：\n\n1. 函数定义示例\n\n   ```\n   def add (a b)\n     a + b;\n   ```\n\n   ![](/images/llvm-1/FuncDef.png)\n\n2. 表达式示例\n\n   ```\n   add(1, 2);\n   ```\n\n   ![](/images/llvm-1/Expr.png)\n\n有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用`ConstantFP::get(TheContext, APFloat(Val))`即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：\n\n```c++\n// NumExpr:\nConstantFP::get(TheContext, APFloat(Val));\n\n// VariableExpr:\n// 根据名称从NamedValues Map中获取对应的Value\nValue *V = NamedValues[Name];\n\n// CallExpr:\n// 1. 根据函数名称获取前面定义了的函数实例\nFunction *CalleeF = TheModule->getFunction(Callee);\n// 2. 确定每个参数的Value\nstd::vector<Value *> ArgsV;\nfor (unsigned i = 0, e = Args.size(); i != e; ++i) {\n  ArgsV.push_back(Args[i]->codegen());\n  if (!ArgsV.back())\n    return nullptr;\n}\n// 3. 创建Call指令\nBuilder.CreateCall(CalleeF, ArgsV, \"calltmp\");\n\n// BinaryExpr:\n// 1. 确定左右操作数的Value\nValue *L = LHS->codegen();\nValue *R = RHS->codegen();\n// 2. 根据操作符，创建对应的操作\nswitch (Op) {\n  case '+':\n    return Builder.CreateFAdd(L, R, \"addtmp\");\n  case '-':\n    return Builder.CreateFSub(L, R, \"subtmp\");\n  case '*':\n    return Builder.CreateFMul(L, R, \"multmp\");\n  case '<':\n    L = Builder.CreateFCmpULT(L, R, \"cmptmp\");\n    // Convert bool 0/1 to double 0.0 or 1.0\n    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), \"booltmp\");\n}\n\n// FuncProto:\n// 创建参数列表的类型\nstd::vector<Type *> Doubles(Args.size(), Type::getDoubleTy(TheContext));\n// 函数原型\nFunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);\n// 生成函数实例\nFunction *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());\n\n// FuncDef:\nFunction *TheFunction = Proto->codegen();\n// 收集参数变量，用于body中的访问\nNamedValues.clear();\nfor (auto &Arg : TheFunction->args()) {\n  NamedValues[Arg.getName()] = &Arg;\n}\n// 创建函数的body BB，并设置指令插入的位置为底部\nBasicBlock *BB = BasicBlock::Create(TheContext, \"entry\", TheFunction);\nBuilder.SetInsertPoint(BB);\nValue *RetVal = Body->codegen();\n// 设置返回指定，指定返回的内容\nBuilder.CreateRet(RetVal);\n```\n\n在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：\n\n```\nextern foo(a);\ndef foo(b) b; // 两个函数原型的参数名称不一样\n```\n\n下面给出我的解决方法：\n\n```c++\nFunction *TheFunction = TheModule->getFunction(Proto->getName());\nif (!TheFunction) {\n  TheFunction = Proto->codegen();\n} else {\n  // 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了\n  unsigned idx = 0;\n  for (auto &Arg : TheFunction->args()) {\n    // getArgName是新增的根据idx获取参数名称的方法\n    Arg.setName(Proto->getArgName(idx++));\n  }\n}\n```\n\n\n\n### 第4章\n\n讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。\n\n关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：\n\n```c++\nvoid InitializeModuleAndPassManager(void) {\n  TheModule = std::make_unique<Module>(\"my cool jit\", TheContext);\n  TheFPM = std::make_unique<FunctionPassManager>(TheModule.get());\n\n  // 优化一：Do simple \"peephole\" optimizations and bit-twiddling optzns.\n  TheFPM->add(createInstructionCombiningPass());\n  // 优化二：Reassociate expressions.\n  TheFPM->add(createReassociatePass());\n  // 优化三：Eliminate Common SubExpressions.\n  TheFPM->add(createGVNPass());\n  // 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).\n  TheFPM->add(createCFGSimplificationPass());\n\n  TheFPM->doInitialization();\n}\n```\n\n对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：\n\n```c++\n  if (auto FnAST = ParseTopLevelExpr()) {\n    if (FnAST->codegen()) {\n      // 将TopLevelExpr所在的模块添加到JIT实例中\n      auto H = TheJIT->addModule(std::move(TheModule));\n      InitializeModuleAndPassManager();\n\n      // 编译万之后找到__anon_expr的内存地址\n      auto ExprSymbol = TheJIT->findSymbol(\"__anon_expr\");\n      // 转化为函数指针后进行调用\n      double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();\n      fprintf(stderr, \"Evaluated to %f\\n\", FP());\n      // 执行完之后删除\n      TheJIT->removeModule(H);\n    }\n```\n\n另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。\n\n\n\n### 第5章\n\n本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。\n\n扩展后语言的BNF定义如下：\n\n```\n...\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n...\n```\n\n示例代码：\n\n```\n# If语句\nif 1 < 2 \nthen 3\nelse f(1, 2, 3);\n\n# For语句，1.00增长步伐可以省略\nfor i = 0, i < 100, 1.00 in\n  f(1, 2, i);\n```\n\nIR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。\n\n生成条件语句的LLVM IR：\n\n```c++\nValue *CondV = Cond->codegen();\nCondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(TheContext, APFloat(0.0)), \"ifcond\");\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *ThenBB = BasicBlock::Create(TheContext, \"then\", TheFunction); // 自动加到函数中\nBasicBlock *ElseBB = BasicBlock::Create(TheContext, \"else\");\nBasicBlock *MergeBB = BasicBlock::Create(TheContext, \"ifcont\");\n\nBuilder.CreateCondBr(CondV, ThenBB, ElseBB); // 插入条件分支语句的指令\n\n// Then语句处理\nBuilder.SetInsertPoint(ThenBB);\nValue *ThenV = Then->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nThenBB = Builder.GetInsertBlock(); // 获取Then语句的出口\n\n// Else语句处理\nTheFunction->getBasicBlockList().push_back(ElseBB); // 添加到函数中去\nBuilder.SetInsertPoint(ElseBB);\nValue *ElseV = Else->codegen();\nBuilder.CreateBr(MergeBB); // 插入跳转到Merge分支的指令\nElseBB = Builder.GetInsertBlock(); // 获取Else语句的出口\n\n// PHI指令的生成\nTheFunction->getBasicBlockList().push_back(MergeBB);\nBuilder.SetInsertPoint(MergeBB);\nPHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, \"iftmp\");\nPN->addIncoming(ThenV, ThenBB);\nPN->addIncoming(ElseV, ElseBB);\n```\n\n生成For语句的LLVM IR：\n\n```c++\nValue *StartVal = Start->codegen();\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *PreheaderBB = Builder.GetInsertBlock();\nBasicBlock *LoopBB = BasicBlock::Create(TheContext, \"loop\", TheFunction);\nBuilder.CreateBr(LoopBB); // 跳转到Loop分支\n\nBuilder.SetInsertPoint(LoopBB);\n// 创建PHI节点\nPHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, VarName.c_str());\nVariable->addIncoming(StartVal, PreheaderBB);\nNamedValues[VarName] = Variable; // 将for定义的变量添加到作用域中\nBody->codegen();\nValue *StepVal = Step->codegen();\nValue *NextVar = Builder.CreateFAdd(Variable, StepVal, \"nextvar\");\nValue *EndCond = End->codegen();\nEndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(TheContext, APFloat(0.0)), \"loopcond\");\nBasicBlock *LoopEndBB = Builder.GetInsertBlock(); // 为啥不可以直接使用LoopBB，而是还要获取一次呢？\nBasicBlock *AfterBB = BasicBlock::Create(TheContext, \"afterloop\", TheFunction);\nBuilder.CreateCondBr(EndCond, LoopBB, AfterBB);\n\nBuilder.SetInsertPoint(AfterBB);\nVariable->addIncoming(NextVar, LoopEndBB);\n```\n\n\n\n### 第6章\n\n本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：\n\n```\n...\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\n...\n```\n\n示例代码：\n\n```\n# 取反\ndef unary ! (v)\n  if v then 0 else 1;\n\n# 或运算，5为二元操作符的优先级\ndef binary | 5 (LHS RHS)\n  if LHS then\n    1\n  else \n    if RHS then\n      1\n    else\n      0;\n```\n\n这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。\n\n\n\n### 第7章\n\n本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了`mem2reg`的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用`mem2reg`Pass进行转化即可。\n\n这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为`mem2reg`只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。\n\n语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：\n\n```\nProgram       -> FunDef | ExternFun | TopLevelExpr\nFunDef        -> \"def\" ident \"(\" FormalArgs \")\" Expr \";\"\n              |  \"def\" \"unary\" CustomOp \"(\" Expr \")\" Expr \";\"\n              |  \"def\" \"binary\" CustomOp num \"(\" Expr Expr \")\" Expr \";\"\nCustomOp      -> [.]+\nExternFun     -> \"extern\" ident \"(\" FormalArgs \")\" \";\"\nFormalArgs    -> ε | ident | ident FormalArgs\nTopLevelExpr  -> Expr \";\"\nExpr          -> num | ident | ident \"(\" ActualArgs \")\" \n              |  Expr Op Expr | \"(\" Expr \")\"\n              |  \"if\" Expr \"then\" Expr \"else\" Expr\n              |  \"for\" ident \"=\" Expr \",\" Expr \",\" Expr \"in\"\n              |  \"for\" ident \"=\" Expr \",\" Expr \"in\"\n              |  ident \"=\" Expr\n              |  \"var\" VarDef [ \",\" VarDef ] \"in\" Expr\nVarDef        -> ident | ident \"=\" Expr\nOp            -> \"<\" | \"-\" | \"+\" | \"*\"\nActualArgs    -> ε | ident | ident \",\" ActualArgs\nident         -> [a-zA-Z][a-zA-Z0-9]*\nnum           -> [0-9.]+\ncomment       -> \"#\" [^\\n\\r]*\n```\n\n新增语法对应的示例代码：\n\n```\ndef binary : 1 (x y) y; # 取两个表达式中的后一个表达式\n\ndef fib(x)\n  var a = 1, b = 1, c in\n  (for i = 3, i < x in\n     c = a + b :\n     a = b :\n     b = c) :\n  b;\n\nfib(10);\n```\n\n\n\n### 第8章\n\n本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。\n\n```c++\nauto TargetTriple = sys::getDefaultTargetTriple();\nInitializeAllTargetInfos();\nInitializeAllTargets();\nInitializeAllTargetMCs();\nInitializeAllAsmParsers();\nInitializeAllAsmPrinters();\n// 获取当前平台相关的Target\nstd::string Error;\nauto Target = TargetRegistry::lookupTarget(TargetTriple, Error);\n// 生成TargetMatchine\nauto CPU = \"generic\";\nauto Features = \"\";\nTargetOptions opt;\nauto RM = Optional<Reloc::Model>();\nauto TargetMachine = Target->createTargetMachine(TargetTriple, CPU, Features, opt, RM);\n// 生成目标代码\nauto Filename = \"output.o\";\nstd::error_code EC;\nraw_fd_ostream dest(Filename, EC, sys::fs::OF_None);\nlegacy::PassManager pass;\nauto FileType = CGFT_ObjectFile;\nTargetMachine->addPassesToEmitFile(pass, dest, nullptr, FileType)\npass.run(*TheModule);\ndest.flush(); // 更新到磁盘\n```\n\n\n\n### 第9章\n\n本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是[DWARF](http://dwarfstd.org)标准格式的调试信息。\n\n具体的代码可以直接看对应的章节。\n\n\n\n### 第10章\n\n本章是最后的总结。\n\n首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。\n\n然后是讲了下LLVM的一些属性：\n\n- LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。\n- LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。\n- 编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass\n\n最后提到了两个避坑指令：\n\n- 关于`offset/sizeof`的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt)。\n\n- 关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考[这里](http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt)\n\n\n\n## 遇到的问题\n\n- 第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给`--libs`增加`orcjit`参数\n  - 原来：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native`\n  - 需改为：`llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit` \n  - 或者直接改为`all`：`llvm-config --cxxflags --ldflags --system-libs --libs all`\n\n","slug":"llvm-1","published":1,"updated":"2020-07-18T09:31:47.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcsk6avv000bnujkcnvuh0fl","content":"<p>官方教程地址：<a href=\"https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\" target=\"_blank\" rel=\"noopener\">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。</p>\n<p>教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。</p>\n<p>如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。</p>\n<h2 id=\"每个章节详解\"><a href=\"#每个章节详解\" class=\"headerlink\" title=\"每个章节详解\"></a>每个章节详解</h2><p>下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。</p>\n<h3 id=\"第1、2章\"><a href=\"#第1、2章\" class=\"headerlink\" title=\"第1、2章\"></a>第1、2章</h3><p>实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。</p>\n<p>词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。</p>\n<p>语法解析部分使用了自顶向下的递归下降语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Recursive_descent_parser\" target=\"_blank\" rel=\"noopener\">Recursive Descent Parsing</a>），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。</p>\n<p>不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Operator-precedence_parser\" target=\"_blank\" rel=\"noopener\">Operator-Precedence Parsing</a>）。具体的原理大概是这样子的，比如对于<code>a + b * c</code>表达式，<code>+</code>的优先级为10，<code>*</code>的优先级为20。在解析到<code>+</code>号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析<code>+</code>号。具体到这个例子，<code>*</code>号的优先级比<code>+</code>号的高，所以在解析到<code>a + b</code>的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的<code>*</code>号是否优先级更高。因为<code>*</code>号的优先级较高，所以会让<code>a +</code>先等着，先解析<code>b * c</code>。得到一个表达式后作为一个完整的操作数（作为<code>+</code>号的第二个操作数），并回来解析<code>a +</code>。</p>\n<p>语言BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern sin(arg); # 外部函数</span><br><span class=\"line\">sin(1);</span><br><span class=\"line\"></span><br><span class=\"line\">def f(a b c)</span><br><span class=\"line\">  a + (b * c);</span><br><span class=\"line\">f(1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第3章\"><a href=\"#第3章\" class=\"headerlink\" title=\"第3章\"></a>第3章</h3><p>这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：</p>\n<p><img src=\"/images/llvm-1/AST.png\" alt=\"\"></p>\n<p>接下来我们来看两个示例，看下他们对应的AST的样子：</p>\n<ol>\n<li><p>函数定义示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def add (a b)</span><br><span class=\"line\">  a + b;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/FuncDef.png\" alt=\"\"></p>\n</li>\n<li><p>表达式示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1, 2);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/Expr.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用<code>ConstantFP::get(TheContext, APFloat(Val))</code>即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NumExpr:</span></span><br><span class=\"line\">ConstantFP::<span class=\"built_in\">get</span>(TheContext, APFloat(Val));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VariableExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称从NamedValues Map中获取对应的Value</span></span><br><span class=\"line\">Value *V = NamedValues[Name];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CallExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 根据函数名称获取前面定义了的函数实例</span></span><br><span class=\"line\">Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class=\"line\"><span class=\"comment\">// 2. 确定每个参数的Value</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>, e = Args.<span class=\"built_in\">size</span>(); i != e; ++i) &#123;</span><br><span class=\"line\">  ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!ArgsV.back())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 3. 创建Call指令</span></span><br><span class=\"line\">Builder.CreateCall(CalleeF, ArgsV, <span class=\"string\">\"calltmp\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BinaryExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 确定左右操作数的Value</span></span><br><span class=\"line\">Value *L = LHS-&gt;codegen();</span><br><span class=\"line\">Value *R = RHS-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 2. 根据操作符，创建对应的操作</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (Op) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFAdd(L, R, <span class=\"string\">\"addtmp\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFSub(L, R, <span class=\"string\">\"subtmp\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFMul(L, R, <span class=\"string\">\"multmp\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</span><br><span class=\"line\">    L = Builder.CreateFCmpULT(L, R, <span class=\"string\">\"cmptmp\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class=\"string\">\"booltmp\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncProto:</span></span><br><span class=\"line\"><span class=\"comment\">// 创建参数列表的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Type *&gt; <span class=\"title\">Doubles</span><span class=\"params\">(Args.<span class=\"built_in\">size</span>(), Type::getDoubleTy(TheContext))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 函数原型</span></span><br><span class=\"line\">FunctionType *FT = FunctionType::<span class=\"built_in\">get</span>(Type::getDoubleTy(TheContext), Doubles, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 生成函数实例</span></span><br><span class=\"line\">Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncDef:</span></span><br><span class=\"line\">Function *TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 收集参数变量，用于body中的访问</span></span><br><span class=\"line\">NamedValues.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">  NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建函数的body BB，并设置指令插入的位置为底部</span></span><br><span class=\"line\">BasicBlock *BB = BasicBlock::Create(TheContext, <span class=\"string\">\"entry\"</span>, TheFunction);</span><br><span class=\"line\">Builder.SetInsertPoint(BB);</span><br><span class=\"line\">Value *RetVal = Body-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 设置返回指定，指定返回的内容</span></span><br><span class=\"line\">Builder.CreateRet(RetVal);</span><br></pre></td></tr></table></figure>\n\n<p>在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern foo(a);</span><br><span class=\"line\">def foo(b) b; &#x2F;&#x2F; 两个函数原型的参数名称不一样</span><br></pre></td></tr></table></figure>\n\n<p>下面给出我的解决方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!TheFunction) &#123;</span><br><span class=\"line\">  TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// getArgName是新增的根据idx获取参数名称的方法</span></span><br><span class=\"line\">    Arg.setName(Proto-&gt;getArgName(idx++));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><p>讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。</p>\n<p>关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitializeModuleAndPassManager</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  TheModule = <span class=\"built_in\">std</span>::make_unique&lt;Module&gt;(<span class=\"string\">\"my cool jit\"</span>, TheContext);</span><br><span class=\"line\">  TheFPM = <span class=\"built_in\">std</span>::make_unique&lt;FunctionPassManager&gt;(TheModule.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优化一：Do simple \"peephole\" optimizations and bit-twiddling optzns.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化二：Reassociate expressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createReassociatePass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化三：Eliminate Common SubExpressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createGVNPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class=\"line\">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class=\"line\"></span><br><span class=\"line\">  TheFPM-&gt;doInitialization();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将TopLevelExpr所在的模块添加到JIT实例中</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> H = TheJIT-&gt;addModule(<span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(TheModule));</span><br><span class=\"line\">    InitializeModuleAndPassManager();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 编译万之后找到__anon_expr的内存地址</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class=\"string\">\"__anon_expr\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 转化为函数指针后进行调用</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> (*FP)() = (<span class=\"keyword\">double</span> (*)())(<span class=\"keyword\">intptr_t</span>)ExprSymbol.getAddress();</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Evaluated to %f\\n\"</span>, FP());</span><br><span class=\"line\">    <span class=\"comment\">// 执行完之后删除</span></span><br><span class=\"line\">    TheJIT-&gt;removeModule(H);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。</p>\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><p>本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。</p>\n<p>扩展后语言的BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># If语句</span><br><span class=\"line\">if 1 &lt; 2 </span><br><span class=\"line\">then 3</span><br><span class=\"line\">else f(1, 2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\"># For语句，1.00增长步伐可以省略</span><br><span class=\"line\">for i &#x3D; 0, i &lt; 100, 1.00 in</span><br><span class=\"line\">  f(1, 2, i);</span><br></pre></td></tr></table></figure>\n\n<p>IR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。</p>\n<p>生成条件语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *CondV = Cond-&gt;codegen();</span><br><span class=\"line\">CondV = Builder.CreateFCmpONE(CondV, ConstantFP::<span class=\"built_in\">get</span>(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">\"ifcond\"</span>);</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class=\"string\">\"then\"</span>, TheFunction); <span class=\"comment\">// 自动加到函数中</span></span><br><span class=\"line\">BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class=\"string\">\"else\"</span>);</span><br><span class=\"line\">BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class=\"string\">\"ifcont\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.CreateCondBr(CondV, ThenBB, ElseBB); <span class=\"comment\">// 插入条件分支语句的指令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Then语句处理</span></span><br><span class=\"line\">Builder.SetInsertPoint(ThenBB);</span><br><span class=\"line\">Value *ThenV = Then-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ThenBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Then语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Else语句处理</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(ElseBB); <span class=\"comment\">// 添加到函数中去</span></span><br><span class=\"line\">Builder.SetInsertPoint(ElseBB);</span><br><span class=\"line\">Value *ElseV = Else-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ElseBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Else语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PHI指令的生成</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(MergeBB);</span><br><span class=\"line\">Builder.SetInsertPoint(MergeBB);</span><br><span class=\"line\">PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, <span class=\"string\">\"iftmp\"</span>);</span><br><span class=\"line\">PN-&gt;addIncoming(ThenV, ThenBB);</span><br><span class=\"line\">PN-&gt;addIncoming(ElseV, ElseBB);</span><br></pre></td></tr></table></figure>\n\n<p>生成For语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *StartVal = Start-&gt;codegen();</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *PreheaderBB = Builder.GetInsertBlock();</span><br><span class=\"line\">BasicBlock *LoopBB = BasicBlock::Create(TheContext, <span class=\"string\">\"loop\"</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateBr(LoopBB); <span class=\"comment\">// 跳转到Loop分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(LoopBB);</span><br><span class=\"line\"><span class=\"comment\">// 创建PHI节点</span></span><br><span class=\"line\">PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, VarName.c_str());</span><br><span class=\"line\">Variable-&gt;addIncoming(StartVal, PreheaderBB);</span><br><span class=\"line\">NamedValues[VarName] = Variable; <span class=\"comment\">// 将for定义的变量添加到作用域中</span></span><br><span class=\"line\">Body-&gt;codegen();</span><br><span class=\"line\">Value *StepVal = Step-&gt;codegen();</span><br><span class=\"line\">Value *NextVar = Builder.CreateFAdd(Variable, StepVal, <span class=\"string\">\"nextvar\"</span>);</span><br><span class=\"line\">Value *EndCond = End-&gt;codegen();</span><br><span class=\"line\">EndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::<span class=\"built_in\">get</span>(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">\"loopcond\"</span>);</span><br><span class=\"line\">BasicBlock *LoopEndBB = Builder.GetInsertBlock(); <span class=\"comment\">// 为啥不可以直接使用LoopBB，而是还要获取一次呢？</span></span><br><span class=\"line\">BasicBlock *AfterBB = BasicBlock::Create(TheContext, <span class=\"string\">\"afterloop\"</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(AfterBB);</span><br><span class=\"line\">Variable-&gt;addIncoming(NextVar, LoopEndBB);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><p>本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 取反</span><br><span class=\"line\">def unary ! (v)</span><br><span class=\"line\">  if v then 0 else 1;</span><br><span class=\"line\"></span><br><span class=\"line\"># 或运算，5为二元操作符的优先级</span><br><span class=\"line\">def binary | 5 (LHS RHS)</span><br><span class=\"line\">  if LHS then</span><br><span class=\"line\">    1</span><br><span class=\"line\">  else </span><br><span class=\"line\">    if RHS then</span><br><span class=\"line\">      1</span><br><span class=\"line\">    else</span><br><span class=\"line\">      0;</span><br></pre></td></tr></table></figure>\n\n<p>这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p>本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了<code>mem2reg</code>的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用<code>mem2reg</code>Pass进行转化即可。</p>\n<p>这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为<code>mem2reg</code>只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。</p>\n<p>语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">              |  &quot;var&quot; VarDef [ &quot;,&quot; VarDef ] &quot;in&quot; Expr</span><br><span class=\"line\">VarDef        -&gt; ident | ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>新增语法对应的示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary : 1 (x y) y; # 取两个表达式中的后一个表达式</span><br><span class=\"line\"></span><br><span class=\"line\">def fib(x)</span><br><span class=\"line\">  var a &#x3D; 1, b &#x3D; 1, c in</span><br><span class=\"line\">  (for i &#x3D; 3, i &lt; x in</span><br><span class=\"line\">     c &#x3D; a + b :</span><br><span class=\"line\">     a &#x3D; b :</span><br><span class=\"line\">     b &#x3D; c) :</span><br><span class=\"line\">  b;</span><br><span class=\"line\"></span><br><span class=\"line\">fib(10);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><p>本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> TargetTriple = sys::getDefaultTargetTriple();</span><br><span class=\"line\">InitializeAllTargetInfos();</span><br><span class=\"line\">InitializeAllTargets();</span><br><span class=\"line\">InitializeAllTargetMCs();</span><br><span class=\"line\">InitializeAllAsmParsers();</span><br><span class=\"line\">InitializeAllAsmPrinters();</span><br><span class=\"line\"><span class=\"comment\">// 获取当前平台相关的Target</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> Error;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Target = TargetRegistry::lookupTarget(TargetTriple, Error);</span><br><span class=\"line\"><span class=\"comment\">// 生成TargetMatchine</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> CPU = <span class=\"string\">\"generic\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Features = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">TargetOptions opt;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> RM = Optional&lt;Reloc::Model&gt;();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</span><br><span class=\"line\"><span class=\"comment\">// 生成目标代码</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> Filename = <span class=\"string\">\"output.o\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::error_code EC;</span><br><span class=\"line\"><span class=\"function\">raw_fd_ostream <span class=\"title\">dest</span><span class=\"params\">(Filename, EC, sys::fs::OF_None)</span></span>;</span><br><span class=\"line\">legacy::PassManager pass;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> FileType = CGFT_ObjectFile;</span><br><span class=\"line\">TargetMachine-&gt;addPassesToEmitFile(pass, dest, <span class=\"literal\">nullptr</span>, FileType)</span><br><span class=\"line\">pass.<span class=\"built_in\">run</span>(*TheModule);</span><br><span class=\"line\">dest.<span class=\"built_in\">flush</span>(); <span class=\"comment\">// 更新到磁盘</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第9章\"><a href=\"#第9章\" class=\"headerlink\" title=\"第9章\"></a>第9章</h3><p>本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是<a href=\"http://dwarfstd.org\" target=\"_blank\" rel=\"noopener\">DWARF</a>标准格式的调试信息。</p>\n<p>具体的代码可以直接看对应的章节。</p>\n<h3 id=\"第10章\"><a href=\"#第10章\" class=\"headerlink\" title=\"第10章\"></a>第10章</h3><p>本章是最后的总结。</p>\n<p>首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。</p>\n<p>然后是讲了下LLVM的一些属性：</p>\n<ul>\n<li>LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。</li>\n<li>LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。</li>\n<li>编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass</li>\n</ul>\n<p>最后提到了两个避坑指令：</p>\n<ul>\n<li><p>关于<code>offset/sizeof</code>的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n</li>\n<li><p>关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</li>\n</ul>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给<code>--libs</code>增加<code>orcjit</code>参数<ul>\n<li>原来：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native</code></li>\n<li>需改为：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit</code> </li>\n<li>或者直接改为<code>all</code>：<code>llvm-config --cxxflags --ldflags --system-libs --libs all</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"more":"<p>官方教程地址：<a href=\"https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html\" target=\"_blank\" rel=\"noopener\">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。</p>\n<p>教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。</p>\n<p>如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。</p>\n<h2 id=\"每个章节详解\"><a href=\"#每个章节详解\" class=\"headerlink\" title=\"每个章节详解\"></a>每个章节详解</h2><p>下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。</p>\n<h3 id=\"第1、2章\"><a href=\"#第1、2章\" class=\"headerlink\" title=\"第1、2章\"></a>第1、2章</h3><p>实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。</p>\n<p>词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。</p>\n<p>语法解析部分使用了自顶向下的递归下降语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Recursive_descent_parser\" target=\"_blank\" rel=\"noopener\">Recursive Descent Parsing</a>），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。</p>\n<p>不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（<a href=\"http://en.wikipedia.org/wiki/Operator-precedence_parser\" target=\"_blank\" rel=\"noopener\">Operator-Precedence Parsing</a>）。具体的原理大概是这样子的，比如对于<code>a + b * c</code>表达式，<code>+</code>的优先级为10，<code>*</code>的优先级为20。在解析到<code>+</code>号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析<code>+</code>号。具体到这个例子，<code>*</code>号的优先级比<code>+</code>号的高，所以在解析到<code>a + b</code>的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的<code>*</code>号是否优先级更高。因为<code>*</code>号的优先级较高，所以会让<code>a +</code>先等着，先解析<code>b * c</code>。得到一个表达式后作为一个完整的操作数（作为<code>+</code>号的第二个操作数），并回来解析<code>a +</code>。</p>\n<p>语言BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern sin(arg); # 外部函数</span><br><span class=\"line\">sin(1);</span><br><span class=\"line\"></span><br><span class=\"line\">def f(a b c)</span><br><span class=\"line\">  a + (b * c);</span><br><span class=\"line\">f(1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第3章\"><a href=\"#第3章\" class=\"headerlink\" title=\"第3章\"></a>第3章</h3><p>这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：</p>\n<p><img src=\"/images/llvm-1/AST.png\" alt=\"\"></p>\n<p>接下来我们来看两个示例，看下他们对应的AST的样子：</p>\n<ol>\n<li><p>函数定义示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def add (a b)</span><br><span class=\"line\">  a + b;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/FuncDef.png\" alt=\"\"></p>\n</li>\n<li><p>表达式示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(1, 2);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/llvm-1/Expr.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用<code>ConstantFP::get(TheContext, APFloat(Val))</code>即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NumExpr:</span></span><br><span class=\"line\">ConstantFP::<span class=\"built_in\">get</span>(TheContext, APFloat(Val));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VariableExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称从NamedValues Map中获取对应的Value</span></span><br><span class=\"line\">Value *V = NamedValues[Name];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CallExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 根据函数名称获取前面定义了的函数实例</span></span><br><span class=\"line\">Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class=\"line\"><span class=\"comment\">// 2. 确定每个参数的Value</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> i = <span class=\"number\">0</span>, e = Args.<span class=\"built_in\">size</span>(); i != e; ++i) &#123;</span><br><span class=\"line\">  ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!ArgsV.back())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 3. 创建Call指令</span></span><br><span class=\"line\">Builder.CreateCall(CalleeF, ArgsV, <span class=\"string\">\"calltmp\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BinaryExpr:</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 确定左右操作数的Value</span></span><br><span class=\"line\">Value *L = LHS-&gt;codegen();</span><br><span class=\"line\">Value *R = RHS-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 2. 根据操作符，创建对应的操作</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (Op) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFAdd(L, R, <span class=\"string\">\"addtmp\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFSub(L, R, <span class=\"string\">\"subtmp\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateFMul(L, R, <span class=\"string\">\"multmp\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</span><br><span class=\"line\">    L = Builder.CreateFCmpULT(L, R, <span class=\"string\">\"cmptmp\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class=\"string\">\"booltmp\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncProto:</span></span><br><span class=\"line\"><span class=\"comment\">// 创建参数列表的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Type *&gt; <span class=\"title\">Doubles</span><span class=\"params\">(Args.<span class=\"built_in\">size</span>(), Type::getDoubleTy(TheContext))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 函数原型</span></span><br><span class=\"line\">FunctionType *FT = FunctionType::<span class=\"built_in\">get</span>(Type::getDoubleTy(TheContext), Doubles, <span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 生成函数实例</span></span><br><span class=\"line\">Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FuncDef:</span></span><br><span class=\"line\">Function *TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 收集参数变量，用于body中的访问</span></span><br><span class=\"line\">NamedValues.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">  NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建函数的body BB，并设置指令插入的位置为底部</span></span><br><span class=\"line\">BasicBlock *BB = BasicBlock::Create(TheContext, <span class=\"string\">\"entry\"</span>, TheFunction);</span><br><span class=\"line\">Builder.SetInsertPoint(BB);</span><br><span class=\"line\">Value *RetVal = Body-&gt;codegen();</span><br><span class=\"line\"><span class=\"comment\">// 设置返回指定，指定返回的内容</span></span><br><span class=\"line\">Builder.CreateRet(RetVal);</span><br></pre></td></tr></table></figure>\n\n<p>在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern foo(a);</span><br><span class=\"line\">def foo(b) b; &#x2F;&#x2F; 两个函数原型的参数名称不一样</span><br></pre></td></tr></table></figure>\n\n<p>下面给出我的解决方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!TheFunction) &#123;</span><br><span class=\"line\">  TheFunction = Proto-&gt;codegen();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// getArgName是新增的根据idx获取参数名称的方法</span></span><br><span class=\"line\">    Arg.setName(Proto-&gt;getArgName(idx++));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><p>讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。</p>\n<p>关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitializeModuleAndPassManager</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  TheModule = <span class=\"built_in\">std</span>::make_unique&lt;Module&gt;(<span class=\"string\">\"my cool jit\"</span>, TheContext);</span><br><span class=\"line\">  TheFPM = <span class=\"built_in\">std</span>::make_unique&lt;FunctionPassManager&gt;(TheModule.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优化一：Do simple \"peephole\" optimizations and bit-twiddling optzns.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化二：Reassociate expressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createReassociatePass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化三：Eliminate Common SubExpressions.</span></span><br><span class=\"line\">  TheFPM-&gt;add(createGVNPass());</span><br><span class=\"line\">  <span class=\"comment\">// 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class=\"line\">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class=\"line\"></span><br><span class=\"line\">  TheFPM-&gt;doInitialization();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将TopLevelExpr所在的模块添加到JIT实例中</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> H = TheJIT-&gt;addModule(<span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(TheModule));</span><br><span class=\"line\">    InitializeModuleAndPassManager();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 编译万之后找到__anon_expr的内存地址</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class=\"string\">\"__anon_expr\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 转化为函数指针后进行调用</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> (*FP)() = (<span class=\"keyword\">double</span> (*)())(<span class=\"keyword\">intptr_t</span>)ExprSymbol.getAddress();</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Evaluated to %f\\n\"</span>, FP());</span><br><span class=\"line\">    <span class=\"comment\">// 执行完之后删除</span></span><br><span class=\"line\">    TheJIT-&gt;removeModule(H);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。</p>\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><p>本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。</p>\n<p>扩展后语言的BNF定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># If语句</span><br><span class=\"line\">if 1 &lt; 2 </span><br><span class=\"line\">then 3</span><br><span class=\"line\">else f(1, 2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\"># For语句，1.00增长步伐可以省略</span><br><span class=\"line\">for i &#x3D; 0, i &lt; 100, 1.00 in</span><br><span class=\"line\">  f(1, 2, i);</span><br></pre></td></tr></table></figure>\n\n<p>IR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。</p>\n<p>生成条件语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *CondV = Cond-&gt;codegen();</span><br><span class=\"line\">CondV = Builder.CreateFCmpONE(CondV, ConstantFP::<span class=\"built_in\">get</span>(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">\"ifcond\"</span>);</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class=\"string\">\"then\"</span>, TheFunction); <span class=\"comment\">// 自动加到函数中</span></span><br><span class=\"line\">BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class=\"string\">\"else\"</span>);</span><br><span class=\"line\">BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class=\"string\">\"ifcont\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.CreateCondBr(CondV, ThenBB, ElseBB); <span class=\"comment\">// 插入条件分支语句的指令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Then语句处理</span></span><br><span class=\"line\">Builder.SetInsertPoint(ThenBB);</span><br><span class=\"line\">Value *ThenV = Then-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ThenBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Then语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Else语句处理</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(ElseBB); <span class=\"comment\">// 添加到函数中去</span></span><br><span class=\"line\">Builder.SetInsertPoint(ElseBB);</span><br><span class=\"line\">Value *ElseV = Else-&gt;codegen();</span><br><span class=\"line\">Builder.CreateBr(MergeBB); <span class=\"comment\">// 插入跳转到Merge分支的指令</span></span><br><span class=\"line\">ElseBB = Builder.GetInsertBlock(); <span class=\"comment\">// 获取Else语句的出口</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PHI指令的生成</span></span><br><span class=\"line\">TheFunction-&gt;getBasicBlockList().push_back(MergeBB);</span><br><span class=\"line\">Builder.SetInsertPoint(MergeBB);</span><br><span class=\"line\">PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, <span class=\"string\">\"iftmp\"</span>);</span><br><span class=\"line\">PN-&gt;addIncoming(ThenV, ThenBB);</span><br><span class=\"line\">PN-&gt;addIncoming(ElseV, ElseBB);</span><br></pre></td></tr></table></figure>\n\n<p>生成For语句的LLVM IR：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value *StartVal = Start-&gt;codegen();</span><br><span class=\"line\">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class=\"line\">BasicBlock *PreheaderBB = Builder.GetInsertBlock();</span><br><span class=\"line\">BasicBlock *LoopBB = BasicBlock::Create(TheContext, <span class=\"string\">\"loop\"</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateBr(LoopBB); <span class=\"comment\">// 跳转到Loop分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(LoopBB);</span><br><span class=\"line\"><span class=\"comment\">// 创建PHI节点</span></span><br><span class=\"line\">PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class=\"number\">2</span>, VarName.c_str());</span><br><span class=\"line\">Variable-&gt;addIncoming(StartVal, PreheaderBB);</span><br><span class=\"line\">NamedValues[VarName] = Variable; <span class=\"comment\">// 将for定义的变量添加到作用域中</span></span><br><span class=\"line\">Body-&gt;codegen();</span><br><span class=\"line\">Value *StepVal = Step-&gt;codegen();</span><br><span class=\"line\">Value *NextVar = Builder.CreateFAdd(Variable, StepVal, <span class=\"string\">\"nextvar\"</span>);</span><br><span class=\"line\">Value *EndCond = End-&gt;codegen();</span><br><span class=\"line\">EndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::<span class=\"built_in\">get</span>(TheContext, APFloat(<span class=\"number\">0.0</span>)), <span class=\"string\">\"loopcond\"</span>);</span><br><span class=\"line\">BasicBlock *LoopEndBB = Builder.GetInsertBlock(); <span class=\"comment\">// 为啥不可以直接使用LoopBB，而是还要获取一次呢？</span></span><br><span class=\"line\">BasicBlock *AfterBB = BasicBlock::Create(TheContext, <span class=\"string\">\"afterloop\"</span>, TheFunction);</span><br><span class=\"line\">Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</span><br><span class=\"line\"></span><br><span class=\"line\">Builder.SetInsertPoint(AfterBB);</span><br><span class=\"line\">Variable-&gt;addIncoming(NextVar, LoopEndBB);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><p>本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 取反</span><br><span class=\"line\">def unary ! (v)</span><br><span class=\"line\">  if v then 0 else 1;</span><br><span class=\"line\"></span><br><span class=\"line\"># 或运算，5为二元操作符的优先级</span><br><span class=\"line\">def binary | 5 (LHS RHS)</span><br><span class=\"line\">  if LHS then</span><br><span class=\"line\">    1</span><br><span class=\"line\">  else </span><br><span class=\"line\">    if RHS then</span><br><span class=\"line\">      1</span><br><span class=\"line\">    else</span><br><span class=\"line\">      0;</span><br></pre></td></tr></table></figure>\n\n<p>这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p>本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了<code>mem2reg</code>的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用<code>mem2reg</code>Pass进行转化即可。</p>\n<p>这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为<code>mem2reg</code>只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。</p>\n<p>语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class=\"line\">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class=\"line\">CustomOp      -&gt; [.]+</span><br><span class=\"line\">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class=\"line\">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class=\"line\">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class=\"line\">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class=\"line\">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class=\"line\">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class=\"line\">              |  ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">              |  &quot;var&quot; VarDef [ &quot;,&quot; VarDef ] &quot;in&quot; Expr</span><br><span class=\"line\">VarDef        -&gt; ident | ident &quot;&#x3D;&quot; Expr</span><br><span class=\"line\">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class=\"line\">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class=\"line\">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class=\"line\">num           -&gt; [0-9.]+</span><br><span class=\"line\">comment       -&gt; &quot;#&quot; [^\\n\\r]*</span><br></pre></td></tr></table></figure>\n\n<p>新增语法对应的示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def binary : 1 (x y) y; # 取两个表达式中的后一个表达式</span><br><span class=\"line\"></span><br><span class=\"line\">def fib(x)</span><br><span class=\"line\">  var a &#x3D; 1, b &#x3D; 1, c in</span><br><span class=\"line\">  (for i &#x3D; 3, i &lt; x in</span><br><span class=\"line\">     c &#x3D; a + b :</span><br><span class=\"line\">     a &#x3D; b :</span><br><span class=\"line\">     b &#x3D; c) :</span><br><span class=\"line\">  b;</span><br><span class=\"line\"></span><br><span class=\"line\">fib(10);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><p>本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> TargetTriple = sys::getDefaultTargetTriple();</span><br><span class=\"line\">InitializeAllTargetInfos();</span><br><span class=\"line\">InitializeAllTargets();</span><br><span class=\"line\">InitializeAllTargetMCs();</span><br><span class=\"line\">InitializeAllAsmParsers();</span><br><span class=\"line\">InitializeAllAsmPrinters();</span><br><span class=\"line\"><span class=\"comment\">// 获取当前平台相关的Target</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> Error;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Target = TargetRegistry::lookupTarget(TargetTriple, Error);</span><br><span class=\"line\"><span class=\"comment\">// 生成TargetMatchine</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> CPU = <span class=\"string\">\"generic\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> Features = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">TargetOptions opt;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> RM = Optional&lt;Reloc::Model&gt;();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</span><br><span class=\"line\"><span class=\"comment\">// 生成目标代码</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> Filename = <span class=\"string\">\"output.o\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::error_code EC;</span><br><span class=\"line\"><span class=\"function\">raw_fd_ostream <span class=\"title\">dest</span><span class=\"params\">(Filename, EC, sys::fs::OF_None)</span></span>;</span><br><span class=\"line\">legacy::PassManager pass;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> FileType = CGFT_ObjectFile;</span><br><span class=\"line\">TargetMachine-&gt;addPassesToEmitFile(pass, dest, <span class=\"literal\">nullptr</span>, FileType)</span><br><span class=\"line\">pass.<span class=\"built_in\">run</span>(*TheModule);</span><br><span class=\"line\">dest.<span class=\"built_in\">flush</span>(); <span class=\"comment\">// 更新到磁盘</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第9章\"><a href=\"#第9章\" class=\"headerlink\" title=\"第9章\"></a>第9章</h3><p>本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是<a href=\"http://dwarfstd.org\" target=\"_blank\" rel=\"noopener\">DWARF</a>标准格式的调试信息。</p>\n<p>具体的代码可以直接看对应的章节。</p>\n<h3 id=\"第10章\"><a href=\"#第10章\" class=\"headerlink\" title=\"第10章\"></a>第10章</h3><p>本章是最后的总结。</p>\n<p>首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。</p>\n<p>然后是讲了下LLVM的一些属性：</p>\n<ul>\n<li>LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。</li>\n<li>LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。</li>\n<li>编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass</li>\n</ul>\n<p>最后提到了两个避坑指令：</p>\n<ul>\n<li><p>关于<code>offset/sizeof</code>的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n</li>\n<li><p>关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考<a href=\"http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</li>\n</ul>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ul>\n<li>第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给<code>--libs</code>增加<code>orcjit</code>参数<ul>\n<li>原来：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native</code></li>\n<li>需改为：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit</code> </li>\n<li>或者直接改为<code>all</code>：<code>llvm-config --cxxflags --ldflags --system-libs --libs all</code></li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckcsk6aux0000nujk14tdcexp","category_id":"ckcsk6ave0002nujkfcmk51tw","_id":"ckcsk6avv000cnujkdzvd44ez"},{"post_id":"ckcsk6avg0004nujk1za36c7k","category_id":"ckcsk6avr0007nujkhwxu4w0e","_id":"ckcsk6aw2000gnujk8w9r5s1v"},{"post_id":"ckcsk6avn0005nujk1oc0g28x","category_id":"ckcsk6avw000dnujkfzc9bn9v","_id":"ckcsk6aw8000knujkhm6n6afq"},{"post_id":"ckcsk6avp0006nujkf5q6fmi0","category_id":"ckcsk6aw2000hnujkemvreia5","_id":"ckcsk6awc000onujkcm54fksn"},{"post_id":"ckcsk6avt000anujk6avmbnfj","category_id":"ckcsk6aw9000lnujkc32i577b","_id":"ckcsk6awf000rnujkaqpl5w3g"},{"post_id":"ckcsk6avv000bnujkcnvuh0fl","category_id":"ckcsk6avw000dnujkfzc9bn9v","_id":"ckcsk6awj000unujkhzm6b1h0"}],"PostTag":[{"post_id":"ckcsk6aux0000nujk14tdcexp","tag_id":"ckcsk6avf0003nujk4uaf45e6","_id":"ckcsk6avt0009nujka1yf3vel"},{"post_id":"ckcsk6avg0004nujk1za36c7k","tag_id":"ckcsk6avs0008nujk9hwpgfrf","_id":"ckcsk6avx000fnujkhcao0tmu"},{"post_id":"ckcsk6avn0005nujk1oc0g28x","tag_id":"ckcsk6avw000enujkgslxee6a","_id":"ckcsk6aw6000jnujk0htz0uqw"},{"post_id":"ckcsk6avp0006nujkf5q6fmi0","tag_id":"ckcsk6aw4000inujk1sdy8onl","_id":"ckcsk6awb000nnujk31e4h9cf"},{"post_id":"ckcsk6avt000anujk6avmbnfj","tag_id":"ckcsk6awb000mnujkatx4dg3c","_id":"ckcsk6awi000tnujk3aqua78r"},{"post_id":"ckcsk6avt000anujk6avmbnfj","tag_id":"ckcsk6awc000qnujkaq78bh68","_id":"ckcsk6awj000vnujk393p6k7q"},{"post_id":"ckcsk6avv000bnujkcnvuh0fl","tag_id":"ckcsk6avw000enujkgslxee6a","_id":"ckcsk6awk000wnujk4wgraxsj"}],"Tag":[{"name":"software","_id":"ckcsk6avf0003nujk4uaf45e6"},{"name":"guide","_id":"ckcsk6avs0008nujk9hwpgfrf"},{"name":"llvm","_id":"ckcsk6avw000enujkgslxee6a"},{"name":"笔记","_id":"ckcsk6aw4000inujk1sdy8onl"},{"name":"js","_id":"ckcsk6awb000mnujkatx4dg3c"},{"name":"quickjs","_id":"ckcsk6awc000qnujkaq78bh68"}]}}