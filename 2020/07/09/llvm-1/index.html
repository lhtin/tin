<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2cdbc7958f6df4fec3751794de6e9c63";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>



  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-131906119-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-131906119-2');
  </script>



  
  <title>学习LLVM第1篇：官方入门教程笔记 | 01的世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="按：本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="学习LLVM第1篇：官方入门教程笔记">
<meta property="og:url" content="https://tintin.dev/2020/07/09/llvm-1/index.html">
<meta property="og:site_name" content="01的世界">
<meta property="og:description" content="按：本文是我学习LLVM官方教程My First Language Frontend with LLVM Tutorial时的一些笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tintin.dev/images/llvm-1/AST.png">
<meta property="og:image" content="https://tintin.dev/images/llvm-1/FuncDef.png">
<meta property="og:image" content="https://tintin.dev/images/llvm-1/Expr.png">
<meta property="article:published_time" content="2020-07-08T16:18:02.000Z">
<meta property="article:modified_time" content="2020-11-01T09:07:19.045Z">
<meta property="article:author" content="tintin">
<meta property="article:tag" content="llvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tintin.dev/images/llvm-1/AST.png">
  
  
    <link rel="icon" type="image/x-icon" href="/images/logo.jpg">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <span id="logo">01的世界</span>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://tintin.dev"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-llvm-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title article-title-tin" itemprop="headline name">
      学习LLVM第1篇：官方入门教程笔记
    </h1>
  
  <p class="article-meta-tin">by tintin @<time class="dt-published" datetime="2020-07-08T16:18:02.000Z" itemprop="datePublished">2020-07-09</time></p>


      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>官方教程地址：<a target="_blank" rel="noopener" href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html">https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这个教程介绍了如何使用LLVM来开发一门新的语言，主要包括手写的Lexer、Parser、以及如何将AST转化为LLVM IR、如何对转化后的IR进行JIT编译并执行、如何将IR编译为目标文件。</p>
<p>教程的第1～7章是一步步扩充Kaleidoscope语言的，从基本的功能，到JIT，再新增IF和FOR语句，再到用户可自定义的操作符，再到可重新赋值的变量。第8章讲解如何将IR编译为目标文件，并且跟其他语言的目标文件（比如C/C++）进行链接。第9章讲解了如何生存调试信息（主要就是源代码中各语句的位置信息），从而可以方便的进行调试。第10章做了总结，并且提出了很多可以继续开发的扩展点。</p>
<p>如果想直接看代码的话，可以只看第7、8、9三个章节的代码。1～6章节是一个迭代过程，在第7章都可以看到。</p>
<h2 id="每个章节详解"><a href="#每个章节详解" class="headerlink" title="每个章节详解"></a>每个章节详解</h2><p>下面对每一个章节进行细讲，主要是讲每个章节所做的事情，以及一些原理的重点介绍。</p>
<h3 id="第1、2章"><a href="#第1、2章" class="headerlink" title="第1、2章"></a>第1、2章</h3><p>实现第一版不带控制流的Kaleidoscope语言的词法和语法解析部分，输出抽象语法树AST。</p>
<p>词法分析部分比较简单，直接一个个字符进行判断，生成对应的token。</p>
<p>语法解析部分使用了自顶向下的递归下降语法分析方法（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Recursive_descent_parser">Recursive Descent Parsing</a>），通过最多往前判断一个token进行语法的确认，简称LL(1)。这种方法一般会给每个产生式定义一个处理函数，通过判断当前的token所属类型确定属于哪一种语法，进而调用对应的处理函数。</p>
<p>不过在解析表达式语法的时候，因为要处理二元操作符的优先级，使用了自底向上的操作符优先级判断的语法分析方法（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Operator-precedence_parser">Operator-Precedence Parsing</a>）。具体的原理大概是这样子的，比如对于<code>a + b * c</code>表达式，<code>+</code>的优先级为10，<code>*</code>的优先级为20。在解析到<code>+</code>号时，会再去判断是否后面还有操作符及优先级，如果后面的优先级更高，则会先让后面的表达式先解析，然后再回来解析<code>+</code>号。具体到这个例子，<code>*</code>号的优先级比<code>+</code>号的高，所以在解析到<code>a + b</code>的时候，并不是先解析成表达式之后再继续解析后面的，而是继续判断后面的<code>*</code>号是否优先级更高。因为<code>*</code>号的优先级较高，所以会让<code>a +</code>先等着，先解析<code>b * c</code>。得到一个表达式后作为一个完整的操作数（作为<code>+</code>号的第二个操作数），并回来解析<code>a +</code>。</p>
<p>语言BNF定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class="line">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class="line">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class="line">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class="line">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class="line">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class="line">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class="line">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class="line">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class="line">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class="line">num           -&gt; [0-9.]+</span><br><span class="line">comment       -&gt; &quot;#&quot; [^\n\r]*</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern sin(arg); # 外部函数</span><br><span class="line">sin(1);</span><br><span class="line"></span><br><span class="line">def f(a b c)</span><br><span class="line">  a + (b * c);</span><br><span class="line">f(1, 2, 3);</span><br></pre></td></tr></table></figure>



<h3 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h3><p>这一章介绍如何将前面生成的抽象语法树，转化为LLVM IR的表示。主要做的事情就是根据AST的语义，等价调用LLVM IR的API，创建module。首先来看下Kaleidoscope语言的AST表示：</p>
<p><img src="/images/llvm-1/AST.png"></p>
<p>接下来我们来看两个示例，看下他们对应的AST的样子：</p>
<ol>
<li><p>函数定义示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add (a b)</span><br><span class="line">  a + b;</span><br></pre></td></tr></table></figure>

<p><img src="/images/llvm-1/FuncDef.png"></p>
</li>
<li><p>表达式示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(1, 2);</span><br></pre></td></tr></table></figure>

<p><img src="/images/llvm-1/Expr.png"></p>
</li>
</ol>
<p>有了AST之后，转换成LLVM IR就比较直接了。针对不同的AST节点，做对应的事情，最终将其转化为一个LLVM中的Value实例。比如针对NumExpr，调用<code>ConstantFP::get(TheContext, APFloat(Val))</code>即可。不熟悉的话可以去查看下LLVM IR的API文档。下面列下每种AST节点对应的创建LLVM IR的代码（来源于教程）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NumExpr:</span></span><br><span class="line">ConstantFP::get(TheContext, APFloat(Val));</span><br><span class="line"></span><br><span class="line"><span class="comment">// VariableExpr:</span></span><br><span class="line"><span class="comment">// 根据名称从NamedValues Map中获取对应的Value</span></span><br><span class="line">Value *V = NamedValues[Name];</span><br><span class="line"></span><br><span class="line"><span class="comment">// CallExpr:</span></span><br><span class="line"><span class="comment">// 1. 根据函数名称获取前面定义了的函数实例</span></span><br><span class="line">Function *CalleeF = TheModule-&gt;getFunction(Callee);</span><br><span class="line"><span class="comment">// 2. 确定每个参数的Value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Value *&gt; ArgsV;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>, e = Args.size(); i != e; ++i) &#123;</span><br><span class="line">  ArgsV.push_back(Args[i]-&gt;codegen());</span><br><span class="line">  <span class="keyword">if</span> (!ArgsV.back())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 创建Call指令</span></span><br><span class="line">Builder.CreateCall(CalleeF, ArgsV, <span class="string">&quot;calltmp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryExpr:</span></span><br><span class="line"><span class="comment">// 1. 确定左右操作数的Value</span></span><br><span class="line">Value *L = LHS-&gt;codegen();</span><br><span class="line">Value *R = RHS-&gt;codegen();</span><br><span class="line"><span class="comment">// 2. 根据操作符，创建对应的操作</span></span><br><span class="line"><span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFAdd(L, R, <span class="string">&quot;addtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFSub(L, R, <span class="string">&quot;subtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.CreateFMul(L, R, <span class="string">&quot;multmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">    L = Builder.CreateFCmpULT(L, R, <span class="string">&quot;cmptmp&quot;</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), <span class="string">&quot;booltmp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FuncProto:</span></span><br><span class="line"><span class="comment">// 创建参数列表的类型</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type *&gt; <span class="title">Doubles</span><span class="params">(Args.size(), Type::getDoubleTy(TheContext))</span></span>;</span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line">FunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 生成函数实例</span></span><br><span class="line">Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// FuncDef:</span></span><br><span class="line">Function *TheFunction = Proto-&gt;codegen();</span><br><span class="line"><span class="comment">// 收集参数变量，用于body中的访问</span></span><br><span class="line">NamedValues.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class="line">  NamedValues[Arg.getName()] = &amp;Arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建函数的body BB，并设置指令插入的位置为底部</span></span><br><span class="line">BasicBlock *BB = BasicBlock::Create(TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">Builder.SetInsertPoint(BB);</span><br><span class="line">Value *RetVal = Body-&gt;codegen();</span><br><span class="line"><span class="comment">// 设置返回指定，指定返回的内容</span></span><br><span class="line">Builder.CreateRet(RetVal);</span><br></pre></td></tr></table></figure>

<p>在讲到FuncDef的LLVM IR的生成代码时，教程提到有一个bug，无法处理下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern foo(a);</span><br><span class="line">def foo(b) b; &#x2F;&#x2F; 两个函数原型的参数名称不一样</span><br></pre></td></tr></table></figure>

<p>下面给出我的解决方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());</span><br><span class="line"><span class="keyword">if</span> (!TheFunction) &#123;</span><br><span class="line">  TheFunction = Proto-&gt;codegen();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果TheFunction之前就创建过了，则更新参数的名称，这样之后就可以找到了</span></span><br><span class="line">  <span class="keyword">unsigned</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;args()) &#123;</span><br><span class="line">    <span class="comment">// getArgName是新增的根据idx获取参数名称的方法</span></span><br><span class="line">    Arg.setName(Proto-&gt;getArgName(idx++));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h3><p>讲了两件事情，一是如何增加函数级别的优化，二是增加JIT编译功能，通过JIT编译之后为本地代码之后，可以在C++中直接调用Kaleidoscope中的函数进行执行。</p>
<p>关于增加函数级别的优化，只需要在初始化Module的时候，同时根据创建的module创建FunctionPassManager，有了FunctionPassManager之后，就可以给他添加你想要的优化Pass了。比如教程中就添加了四个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  TheModule = <span class="built_in">std</span>::make_unique&lt;Module&gt;(<span class="string">&quot;my cool jit&quot;</span>, TheContext);</span><br><span class="line">  TheFPM = <span class="built_in">std</span>::make_unique&lt;FunctionPassManager&gt;(TheModule.get());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优化一：Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span></span><br><span class="line">  TheFPM-&gt;add(createInstructionCombiningPass());</span><br><span class="line">  <span class="comment">// 优化二：Reassociate expressions.</span></span><br><span class="line">  TheFPM-&gt;add(createReassociatePass());</span><br><span class="line">  <span class="comment">// 优化三：Eliminate Common SubExpressions.</span></span><br><span class="line">  TheFPM-&gt;add(createGVNPass());</span><br><span class="line">  <span class="comment">// 优化四：Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class="line">  TheFPM-&gt;add(createCFGSimplificationPass());</span><br><span class="line"></span><br><span class="line">  TheFPM-&gt;doInitialization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于JIT编译，本章并没有分享JIT模块的原理，而是假设已经写好了一个KaleidoscopeJIT模块，如何去使用它。通过创建一个JIT实例，然后将用户输入的代码转化为LLVM Module，然后将Module添加给JIT实例，就会对添加进去的模块进行编译。编译了之后，可以通过函数名称找到函数的内存地址，进而直接调用。核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = ParseTopLevelExpr()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (FnAST-&gt;codegen()) &#123;</span><br><span class="line">    <span class="comment">// 将TopLevelExpr所在的模块添加到JIT实例中</span></span><br><span class="line">    <span class="keyword">auto</span> H = TheJIT-&gt;addModule(<span class="built_in">std</span>::move(TheModule));</span><br><span class="line">    InitializeModuleAndPassManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译万之后找到__anon_expr的内存地址</span></span><br><span class="line">    <span class="keyword">auto</span> ExprSymbol = TheJIT-&gt;findSymbol(<span class="string">&quot;__anon_expr&quot;</span>);</span><br><span class="line">    <span class="comment">// 转化为函数指针后进行调用</span></span><br><span class="line">    <span class="keyword">double</span> (*FP)() = (<span class="keyword">double</span> (*)())(<span class="keyword">intptr_t</span>)ExprSymbol.getAddress();</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Evaluated to %f\n&quot;</span>, FP());</span><br><span class="line">    <span class="comment">// 执行完之后删除</span></span><br><span class="line">    TheJIT-&gt;removeModule(H);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>另外需要注意，为了让用户输入的函数定义，在后面一直都可以被调用。需要将函数定义存放的模块跟TopLevelExpr所处的模块分开，这样在执行完之后进行删除时，不会同时把函数定义给删除了。</p>
<h3 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h3><p>本章给Kaleidoscope添加了流程控制语句If/Then/Else和循环语句For/In。</p>
<p>扩展后语言的BNF定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class="line">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class="line">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class="line">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class="line">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># If语句</span><br><span class="line">if 1 &lt; 2 </span><br><span class="line">then 3</span><br><span class="line">else f(1, 2, 3);</span><br><span class="line"></span><br><span class="line"># For语句，1.00增长步伐可以省略</span><br><span class="line">for i &#x3D; 0, i &lt; 100, 1.00 in</span><br><span class="line">  f(1, 2, i);</span><br></pre></td></tr></table></figure>

<p>IR的生成，主要需要注意分支有哪些，以及分支汇集的地方PHI节点的创建。下面将教程中的核心代码加上注释展示出来。</p>
<p>生成条件语句的LLVM IR：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Value *CondV = Cond-&gt;codegen();</span><br><span class="line">CondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(TheContext, APFloat(<span class="number">0.0</span>)), <span class="string">&quot;ifcond&quot;</span>);</span><br><span class="line">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class="line">BasicBlock *ThenBB = BasicBlock::Create(TheContext, <span class="string">&quot;then&quot;</span>, TheFunction); <span class="comment">// 自动加到函数中</span></span><br><span class="line">BasicBlock *ElseBB = BasicBlock::Create(TheContext, <span class="string">&quot;else&quot;</span>);</span><br><span class="line">BasicBlock *MergeBB = BasicBlock::Create(TheContext, <span class="string">&quot;ifcont&quot;</span>);</span><br><span class="line"></span><br><span class="line">Builder.CreateCondBr(CondV, ThenBB, ElseBB); <span class="comment">// 插入条件分支语句的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Then语句处理</span></span><br><span class="line">Builder.SetInsertPoint(ThenBB);</span><br><span class="line">Value *ThenV = Then-&gt;codegen();</span><br><span class="line">Builder.CreateBr(MergeBB); <span class="comment">// 插入跳转到Merge分支的指令</span></span><br><span class="line">ThenBB = Builder.GetInsertBlock(); <span class="comment">// 获取Then语句的出口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Else语句处理</span></span><br><span class="line">TheFunction-&gt;getBasicBlockList().push_back(ElseBB); <span class="comment">// 添加到函数中去</span></span><br><span class="line">Builder.SetInsertPoint(ElseBB);</span><br><span class="line">Value *ElseV = Else-&gt;codegen();</span><br><span class="line">Builder.CreateBr(MergeBB); <span class="comment">// 插入跳转到Merge分支的指令</span></span><br><span class="line">ElseBB = Builder.GetInsertBlock(); <span class="comment">// 获取Else语句的出口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PHI指令的生成</span></span><br><span class="line">TheFunction-&gt;getBasicBlockList().push_back(MergeBB);</span><br><span class="line">Builder.SetInsertPoint(MergeBB);</span><br><span class="line">PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class="number">2</span>, <span class="string">&quot;iftmp&quot;</span>);</span><br><span class="line">PN-&gt;addIncoming(ThenV, ThenBB);</span><br><span class="line">PN-&gt;addIncoming(ElseV, ElseBB);</span><br></pre></td></tr></table></figure>

<p>生成For语句的LLVM IR：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Value *StartVal = Start-&gt;codegen();</span><br><span class="line">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();</span><br><span class="line">BasicBlock *PreheaderBB = Builder.GetInsertBlock();</span><br><span class="line">BasicBlock *LoopBB = BasicBlock::Create(TheContext, <span class="string">&quot;loop&quot;</span>, TheFunction);</span><br><span class="line">Builder.CreateBr(LoopBB); <span class="comment">// 跳转到Loop分支</span></span><br><span class="line"></span><br><span class="line">Builder.SetInsertPoint(LoopBB);</span><br><span class="line"><span class="comment">// 创建PHI节点</span></span><br><span class="line">PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), <span class="number">2</span>, VarName.c_str());</span><br><span class="line">Variable-&gt;addIncoming(StartVal, PreheaderBB);</span><br><span class="line">NamedValues[VarName] = Variable; <span class="comment">// 将for定义的变量添加到作用域中</span></span><br><span class="line">Body-&gt;codegen();</span><br><span class="line">Value *StepVal = Step-&gt;codegen();</span><br><span class="line">Value *NextVar = Builder.CreateFAdd(Variable, StepVal, <span class="string">&quot;nextvar&quot;</span>);</span><br><span class="line">Value *EndCond = End-&gt;codegen();</span><br><span class="line">EndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(TheContext, APFloat(<span class="number">0.0</span>)), <span class="string">&quot;loopcond&quot;</span>);</span><br><span class="line">BasicBlock *LoopEndBB = Builder.GetInsertBlock(); <span class="comment">// 为啥不可以直接使用LoopBB，而是还要获取一次呢？</span></span><br><span class="line">BasicBlock *AfterBB = BasicBlock::Create(TheContext, <span class="string">&quot;afterloop&quot;</span>, TheFunction);</span><br><span class="line">Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</span><br><span class="line"></span><br><span class="line">Builder.SetInsertPoint(AfterBB);</span><br><span class="line">Variable-&gt;addIncoming(NextVar, LoopEndBB);</span><br></pre></td></tr></table></figure>



<h3 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h3><p>本章讲解自定义操作符功能，主要的方式是通过新增特定的函数定义来实现，BNF表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class="line">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class="line">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class="line">CustomOp      -&gt; [.]+</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 取反</span><br><span class="line">def unary ! (v)</span><br><span class="line">  if v then 0 else 1;</span><br><span class="line"></span><br><span class="line"># 或运算，5为二元操作符的优先级</span><br><span class="line">def binary | 5 (LHS RHS)</span><br><span class="line">  if LHS then</span><br><span class="line">    1</span><br><span class="line">  else </span><br><span class="line">    if RHS then</span><br><span class="line">      1</span><br><span class="line">    else</span><br><span class="line">      0;</span><br></pre></td></tr></table></figure>

<p>这章主要是新增了一些语法糖，并没有新增实质性的内容，并且也没有涉及新的LLVM的内容，所以就不细说了。</p>
<h3 id="第7章"><a href="#第7章" class="headerlink" title="第7章"></a>第7章</h3><p>本章给Kaleidoscope语言引入了变量可赋值的功能。需要注意的是，LLVM IR是一种SSA（Static Single Assignment），也就是说每个变量只能被赋值一次。而变量可赋值意味着变量可以被赋值多次，所以需要有一个转化过程，将其转化为SSA格式。但是如果每个地方都需要这样手工处理的话，会相当的繁琐，你需要手工创建很多的PHI节点。幸运的是，LLVM提供了<code>mem2reg</code>的转化Pass，可以将栈变量（可以被修复多次）转化为寄存器变量（只可以被赋值一次）。因此，当我们遇到变量赋值时，我们只需要将其转化为IR中的栈变量，然后调用<code>mem2reg</code>Pass进行转化即可。</p>
<p>这里说下大致的代码逻辑。在根据函数定义和变量声明的AST生成IR时，首先在EntryBlock（因为<code>mem2reg</code>只会处理放在EntryBlock中的变量）的给每个变量创建一个栈变量，然后再对应的修改的地方创建Store指令，在需要获取的地方创建Load指令。同时因为可以定义新的变量，需要处理同名变量互相覆盖的问题。</p>
<p>语言最新的BNF表示（因为后面的章节没有再对语法有改动了，所以这里给出完整的语法，方便查看）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Program       -&gt; FunDef | ExternFun | TopLevelExpr</span><br><span class="line">FunDef        -&gt; &quot;def&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; Expr &quot;;&quot;</span><br><span class="line">              |  &quot;def&quot; &quot;unary&quot; CustomOp &quot;(&quot; Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class="line">              |  &quot;def&quot; &quot;binary&quot; CustomOp num &quot;(&quot; Expr Expr &quot;)&quot; Expr &quot;;&quot;</span><br><span class="line">CustomOp      -&gt; [.]+</span><br><span class="line">ExternFun     -&gt; &quot;extern&quot; ident &quot;(&quot; FormalArgs &quot;)&quot; &quot;;&quot;</span><br><span class="line">FormalArgs    -&gt; ε | ident | ident FormalArgs</span><br><span class="line">TopLevelExpr  -&gt; Expr &quot;;&quot;</span><br><span class="line">Expr          -&gt; num | ident | ident &quot;(&quot; ActualArgs &quot;)&quot; </span><br><span class="line">              |  Expr Op Expr | &quot;(&quot; Expr &quot;)&quot;</span><br><span class="line">              |  &quot;if&quot; Expr &quot;then&quot; Expr &quot;else&quot; Expr</span><br><span class="line">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class="line">              |  &quot;for&quot; ident &quot;&#x3D;&quot; Expr &quot;,&quot; Expr &quot;in&quot;</span><br><span class="line">              |  ident &quot;&#x3D;&quot; Expr</span><br><span class="line">              |  &quot;var&quot; VarDef [ &quot;,&quot; VarDef ] &quot;in&quot; Expr</span><br><span class="line">VarDef        -&gt; ident | ident &quot;&#x3D;&quot; Expr</span><br><span class="line">Op            -&gt; &quot;&lt;&quot; | &quot;-&quot; | &quot;+&quot; | &quot;*&quot;</span><br><span class="line">ActualArgs    -&gt; ε | ident | ident &quot;,&quot; ActualArgs</span><br><span class="line">ident         -&gt; [a-zA-Z][a-zA-Z0-9]*</span><br><span class="line">num           -&gt; [0-9.]+</span><br><span class="line">comment       -&gt; &quot;#&quot; [^\n\r]*</span><br></pre></td></tr></table></figure>

<p>新增语法对应的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def binary : 1 (x y) y; # 取两个表达式中的后一个表达式</span><br><span class="line"></span><br><span class="line">def fib(x)</span><br><span class="line">  var a &#x3D; 1, b &#x3D; 1, c in</span><br><span class="line">  (for i &#x3D; 3, i &lt; x in</span><br><span class="line">     c &#x3D; a + b :</span><br><span class="line">     a &#x3D; b :</span><br><span class="line">     b &#x3D; c) :</span><br><span class="line">  b;</span><br><span class="line"></span><br><span class="line">fib(10);</span><br></pre></td></tr></table></figure>



<h3 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h3><p>本章讲解如何将LLVM IR转化为目标文件。这章内容不多，主要包括如何设置和获取Target，如何创建TargetMachine，以及如何通过PassManager触发运行，生成目标文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> TargetTriple = sys::getDefaultTargetTriple();</span><br><span class="line">InitializeAllTargetInfos();</span><br><span class="line">InitializeAllTargets();</span><br><span class="line">InitializeAllTargetMCs();</span><br><span class="line">InitializeAllAsmParsers();</span><br><span class="line">InitializeAllAsmPrinters();</span><br><span class="line"><span class="comment">// 获取当前平台相关的Target</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Error;</span><br><span class="line"><span class="keyword">auto</span> Target = TargetRegistry::lookupTarget(TargetTriple, Error);</span><br><span class="line"><span class="comment">// 生成TargetMatchine</span></span><br><span class="line"><span class="keyword">auto</span> CPU = <span class="string">&quot;generic&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> Features = <span class="string">&quot;&quot;</span>;</span><br><span class="line">TargetOptions opt;</span><br><span class="line"><span class="keyword">auto</span> RM = Optional&lt;Reloc::Model&gt;();</span><br><span class="line"><span class="keyword">auto</span> TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</span><br><span class="line"><span class="comment">// 生成目标代码</span></span><br><span class="line"><span class="keyword">auto</span> Filename = <span class="string">&quot;output.o&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::error_code EC;</span><br><span class="line"><span class="function">raw_fd_ostream <span class="title">dest</span><span class="params">(Filename, EC, sys::fs::OF_None)</span></span>;</span><br><span class="line">legacy::PassManager pass;</span><br><span class="line"><span class="keyword">auto</span> FileType = CGFT_ObjectFile;</span><br><span class="line">TargetMachine-&gt;addPassesToEmitFile(pass, dest, <span class="literal">nullptr</span>, FileType)</span><br><span class="line">pass.run(*TheModule);</span><br><span class="line">dest.flush(); <span class="comment">// 更新到磁盘</span></span><br></pre></td></tr></table></figure>



<h3 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h3><p>本章讲解如何添加Debug信息到IR中，用于后面的程序调试。大概的原理是这样子的，LLVM提供了DIBuilder，类似IRBuilder。然后在生成IR指令前，需要调用IRBuilder的SetCurrentDebugLocation方法，设置接下来的IR指令的代码行数和列数等信息。关于调试信息的作用域，分为了模块和函数两种，在设置调试信息时，需要确定好是处在模块层还是函数层。LLVM生成的是<a target="_blank" rel="noopener" href="http://dwarfstd.org/">DWARF</a>标准格式的调试信息。</p>
<p>具体的代码可以直接看对应的章节。</p>
<h3 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h3><p>本章是最后的总结。</p>
<p>首先提到可以对Kaleidoscope做的一些扩展，比如全局变量、含类型的变量、数组等结构体、内存管理、异常管理等各种功能。</p>
<p>然后是讲了下LLVM的一些属性：</p>
<ul>
<li>LLVM IR是目标架构无关的语言，你可以将它编译成任何支持的平台。</li>
<li>LLVM IR本身并不是安全的语言，IR支持不安全的指针转换。可以在LLVM之上做一层安全的校验。</li>
<li>编程语言相关的优化。在将源码转成LLVM IR的时候，会丢失一些信息。不过你可以扩展LLVM来添加一些专门针对某一种语言的优化Pass</li>
</ul>
<p>最后提到了两个避坑指令：</p>
<ul>
<li><p>关于<code>offset/sizeof</code>的移植性问题，LLVM中的指针大小是平台相关的，不过有些方式可以避免这个问题。具体可以参考<a target="_blank" rel="noopener" href="http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt">这里</a>。</p>
</li>
<li><p>关于控制栈帧的方法（比如用于实现闭包），LLVM是提供了支持的，不过这需要前端先将代码转成CPS风格的尾递归调用才行。具体可以参考<a target="_blank" rel="noopener" href="http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt">这里</a></p>
</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul>
<li>第4章节（其实还包括后面所有需要用到JIT功能的章节），编译时需要给<code>--libs</code>增加<code>orcjit</code>参数<ul>
<li>原来：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native</code></li>
<li>需改为：<code>llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native orcjit</code> </li>
<li>或者直接改为<code>all</code>：<code>llvm-config --cxxflags --ldflags --system-libs --libs all</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/llvm/" rel="tag">llvm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/17/nand2tetris-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          Nand2Tetris Part 1 课程总结
        
      </div>
    </a>
  
  
    <a href="/2020/07/02/quickjs/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">6月7日在OSDT线上技术讨论会上的分享视频</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/llvm/">llvm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%84%E8%AE%BA/">评论</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenJDK/" rel="tag">OpenJDK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/" rel="tag">design</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/econ/" rel="tag">econ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/llvm/" rel="tag">llvm</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nand2tetris/" rel="tag">nand2tetris</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">note</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openjdk/" rel="tag">openjdk</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quickjs/" rel="tag">quickjs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scheme/" rel="tag">scheme</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ukulele/" rel="tag">ukulele</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/" rel="tag">经济学</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/14/openjdk-constant-pool/">HotSpot中的Run-Time Constant Pool实现</a>
          </li>
        
          <li>
            <a href="/2021/02/09/openjdk-class-and-object-in-hotspot/">HotSpot中的Java类和对象</a>
          </li>
        
          <li>
            <a href="/2020/12/26/openjdk-epsilon-gc-add-gc/">给OpenJDK中的Epsilon GC添加GC功能</a>
          </li>
        
          <li>
            <a href="/2020/12/23/the-design-of-everyday-things/">日用品的设计（持续更新中）</a>
          </li>
        
          <li>
            <a href="/2020/12/21/nand2tetris-2/">Nand2Tetris Part 2 课程总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 <a target="_blank" rel="noopener" href="https://github.com/lhtin">tintin</a><br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>