<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TSPL4</title>
  <link rel="icon" type="image/png" href="../think/assets/ant.png">
  <link href="../styles.css" rel="stylesheet">
  <link href="../vs.css" rel="stylesheet">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-131906119-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-131906119-1');
  </script>
  <script async src="../index.js"></script>
</head>
<body>
<h1><em>The Scheme Programming Language</em> 摘抄笔记及习题答案</h1>
<h2>Preface</h2>
<p>Scheme 由 Gerald J. Sussman 和 Guy L. Steele Jr. 发明，支持 lexical scoping、first-class procedures 和 continuations。</p>
<p>本书的目标是提供关于 Scheme 编程语言（R6RS 标准）的介绍。</p>
<h2>1. Introduction</h2>
<blockquote>
<p>Scheme is a call-by-value language, but for at least mutable (objects that can be modified), the values are pointers to the actual storage.</p>
</blockquote>
<blockquote>
<p>At the heart of the Scheme language is a small core of syntactic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language.</p>
</blockquote>
<blockquote>
<p>To support lexical scoping, a procedure carries the lexical context (environment) along with its code.</p>
</blockquote>
<h3>1.1. Scheme Syntax</h3>
<blockquote>
<p>Scheme programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.</p>
</blockquote>
<blockquote>
<p>Keywords, variables, and symbols are collectively called identifiers. Identifiers may be formed from letters, digits, and certain special characters, including ?, !, ., +, -, *, /, &lt;, =, &gt;, :, $, %, ^, &amp;, _, ~, and @, as well as a set of additional Unicode characters.</p>
</blockquote>
<blockquote>
<p>A good rule is to use short identifiers when the scope of the identifier is small and longer identifiers when the scope is larger.</p>
</blockquote>
<blockquote>
<p>Structured forms and list constants are enclosed within parentheses, e.g., (a b c) or (* (- x 2) y).</p>
</blockquote>
<blockquote>
<p>Strings are enclosed in double quotation marks, e.g., &quot;I am a string&quot;. Characters are preceded by #, e.g., #\a.</p>
</blockquote>
<p>comments: <code>; single line</code>, <code>#| block |#</code>, <code>#;(datum commnet)</code></p>
<h3>1.2. Scheme Naming Conventions</h3>
<h3>1.3. Typographical and Notational Conventions</h3>
<h2>2. Getting Started</h2>
<h3>2.1. Interacting with Scheme</h3>
<h3>2.2. Simple Expressions</h3>
<blockquote>
<p>The <code>quote</code> (<code>'</code>) forces the list to be treated as data.</p>
</blockquote>
<blockquote>
<p>Symbols and variables in Scheme are similar to symbols and variables in mathematical expressions and equations. When we evaluate the mathematical expression 1 - <em>x</em> for some value of <em>x</em>, we think of <em>x</em> as a variable. On the other hand, when we consider the algebraic equation <em>x</em>^2 - 1 = (<em>x</em> - 1)(<em>x</em> + 1), we think of <em>x</em> as a symbol (in fact, we think of the whole equation symbolically). Just as quoting a list tells Scheme to treat a parenthesized form as a list rather than as a procedure application, <strong>quoting an identifier tells Scheme to treat the identifier as a symbol rather than as a variable</strong>.</p>
</blockquote>
<blockquote>
<p>Numbers and strings may be quoted, too. Numbers and strings are treated as constants in any case, however, so quoting them is unnecessary.</p>
</blockquote>
<h3>2.3. Evaluating Scheme Expressions</h3>
<blockquote>
<p>Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms provided by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme programmer; these are referred to as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms.</p>
</blockquote>
<h3>2.4. Variables and Let Expressions</h3>
<p>每一个 variable 都有它的 scope，同名的 variable，更里面的 variable 会 shadow 外层的 variable。这种 scope 叫做 lexical scoping。</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ((<span class="hljs-name">var</span> expr) ...) body1 body2 ...)
</code></pre>
<h3>2.5. Lambda Expressions</h3>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (var ...) body1 body2 ...)
(<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> <span class="hljs-name">var</span> <span class="hljs-name">body1</span> <span class="hljs-name">body2</span> <span class="hljs-name"><span class="hljs-builtin-name">...</span></span>)
(<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (var ... var . var) body1 body2 ...)
</code></pre>
<h3>2.6. Top-Level Definitions</h3>
<h3>2.7. Conditional Expressions</h3>
<blockquote>
<p>A predicate is a procedure that answers a specific question about its arguments and returns one of the two values #t or #f.</p>
</blockquote>
<h3>2.8. Simple Recursion</h3>
<blockquote>
<p>Recursion is a simple concept: the application of a procedure from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive power far beyond ordinary looping constructs.</p>
</blockquote>
<p><strong>mapping</strong>: 映射</p>
<h3>2.9. Assignment</h3>
<blockquote>
<p>Although many programs can be written without them, assignments to top-level variables or let-bound and lambda-bound variables are sometimes useful. Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings. Assignments are performed with set!.</p>
</blockquote>
<h2>3. Going Further</h2>
<h3>3.1. Syntactic Extension</h3>
<blockquote>
<p>The core syntactic forms include top-level <code>define</code> forms, constants, variables, procedure applications, <code>quote</code> expressions, <code>lambda</code> expressions, <code>if</code> expressions, and <code>set!</code> expressions.</p>
</blockquote>
<p>core grammar:</p>
<pre><code>&lt;program&gt; -&gt; &lt;form&gt;*
&lt;form&gt; -&gt; &lt;definition&gt; | &lt;expression&gt;
&lt;definition&gt; -&gt; &lt;variable definition&gt; | (begin &lt;definition&gt;*)
&lt;variable definition&gt; -&gt; (define &lt;variable&gt; &lt;expression&gt;)
&lt;expression&gt; -&gt; &lt;constant&gt;
             |  &lt;variable&gt;
             |  (quote &lt;datum&gt;)
             |  (lambda &lt;formals&gt; &lt;expression&gt; &lt;expression&gt;*)
             |  (if &lt;expression&gt; &lt;expression&gt; &lt;expression&gt;)
             |  (set! &lt;variable&gt; &lt;expression&gt;)
             |  &lt;application&gt;
&lt;constant&gt; -&gt; &lt;boolean&gt; | &lt;number&gt; | &lt;character&gt; | &lt;string&gt;
&lt;formals&gt; -&gt; &lt;variable&gt;
          |  (&lt;variable&gt;*)
          |  (&lt;variable&gt; &lt;variable&gt;* . &lt;variable&gt;)
&lt;application&gt; -&gt; (&lt;expression&gt; &lt;expression&gt;*)

&lt;variable&gt; is any Scheme identifier
&lt;datum&gt; is any Scheme object, such as a number, list, symbol, or vector
&lt;boolean&gt; is either #t or #f
&lt;number&gt; is any number
&lt;character&gt; is any character
&lt;string&gt; is any string
</code></pre>
<h3>3.2. More Recursion</h3>
<blockquote>
<p>In a <code>letrec</code> expression, <code>expr ...</code> are most often <code>lambda</code> expressions, though this need not be the case. One restriction on the expressions must be obeyed, however. It must be possible to evaluate each <code>expr</code> without evaluating any of the variables <code>var ...</code>.</p>
</blockquote>
<h3>3.3. Continuations</h3>
<blockquote>
<p>During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. We call &quot;what to do with the value&quot; the continuation of a computation.</p>
</blockquote>
<p>对 continuation 的记录，意味着下次使用该 continuation 时会回到之前计算的某个点，再往下走。也就是说可以回到过去。</p>
<h3>3.4. Continuation Passing Style</h3>
<p>使函数调用的隐式 continuation 通过 CPS 转换变为显式。</p>
<p>使用场景：</p>
<ol>
<li>是函数调用可以返回多个值</li>
<li>可以传入多个 continuation</li>
</ol>
<h3>3.5. Internal Definitions</h3>
<blockquote>
<p>Definitions may also appear at the front of a lambda, let, or letrec body, in which case the bindings they create are local to the body.</p>
</blockquote>
<h3>3.6. Libraries</h3>
<p>用于模块化，只暴露必要的内容给使用者。</p>
<pre><code class="language-scheme">(<span class="hljs-name">library</span> (<span class="hljs-name">lib-name</span>)
  (<span class="hljs-name">export</span> x1 x2 ...)
  (<span class="hljs-name"><span class="hljs-builtin-name">import</span></span> (<span class="hljs-name">rnrs</span>))
  ...)
</code></pre>
<h2>4. Procedures and Variable Bindings</h2>
<h3>4.1. Variable References</h3>
<blockquote>
<p>Since the scope of the definitions in a <code>library</code>, top-level program, <code>lambda</code>, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed.</p>
</blockquote>
<h3>4.2. Lambda</h3>
<p><code>(lambda formals body1 body2 ...)</code></p>
<h3>4.3. Case-Lambda</h3>
<blockquote>
<p>The <code>case-lambda</code> syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments.</p>
</blockquote>
<p><code>(case-lambda clause ...)</code></p>
<p><code>clause</code>:
<code>[formals body1 body2 ...]</code></p>
<h3>4.4. Local Binding</h3>
<p><code>let</code>, <code>let*</code>, <code>letrec</code>, <code>letrec*</code></p>
<h3>4.5. Multiple Values</h3>
<p><code>let-values</code>, <code>let*-values</code></p>
<h3>4.6. Variable Definitions</h3>
<p><code>define</code></p>
<blockquote>
<p>A set of definitions may be grouped by enclosing them in a <code>begin</code> form. Definitions grouped in this manner may appear wherever ordinary variable and syntax definitions may appear. They are treated as if written separately, i.e., without the enclosing <code>begin</code> form.</p>
</blockquote>
<h3>4.7. Assignment</h3>
<p><code>set!</code></p>
<h2>5. Control Operations</h2>
<h3>5.1. Procedure Application</h3>
<blockquote>
<p>Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application.</p>
</blockquote>
<p><code>(apply procedure obj ... list)</code></p>
<blockquote>
<p><code>apply</code> is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.</p>
</blockquote>
<h3>5.2. Sequencing</h3>
<p><code>(begin expr1 expr2 ...)</code></p>
<blockquote>
<p>The bodies of many syntactic forms, including <code>lambda</code>, <code>case-lambda</code>, <code>let</code>, <code>let*</code>, <code>letrec</code>, and <code>letrec*</code>, as well as the result clauses of <code>cond</code>, <code>case</code>, and <code>do</code>, are treated as if they were inside an implicit <code>begin</code>; i.e., the expressions making up the body or result clause are executed in sequence, with the values of the last expression being returned.</p>
</blockquote>
<h3>5.3. Conditionals</h3>
<p><code>if</code>, <code>not</code>, <code>and</code>, <code>or</code>, <code>cond</code>, <code>when</code>, <code>unless</code>, <code>case</code></p>
<h3>5.4. Recursion and Iteration</h3>
<p><code>(let name ((var expr) ...) body1 body2 ...)</code></p>
<p><code>(do ((var init update) ...) (test result ...) expr ...)</code></p>
<h3>5.5. Mapping and Folding</h3>
<p><code>(map procedure list1 list2 ...)</code>
<code>(for-each procedure list1 list2 ...)</code></p>
<blockquote>
<p><code>for-each</code> is similar to <code>map</code> except that <code>for-each</code> does not create and return a list of the resulting values, and <code>for-each</code> guarantees to perform the applications in sequence over the elements from left to right.</p>
</blockquote>
<p><code>(exists procedure list1 list2 ...)</code>
<code>(for-all procedure list1 list2 ...)</code></p>
<p><code>exists</code> 和 <code>for-all</code> 的区别在于前者是在调用函数返回 <code>#t</code> 是结束，后者是在返回 <code>#f</code> 是结束。</p>
<p><code>(fold-left procedure obj list1 list2 ...)</code>
<code>(fold-right procedure obj list1 list2 ...)</code></p>
<h3>5.6. Continuations</h3>
<p>用一句比较玄的话来讲就是：它（Continuation）可以去到未来，也可以回到过去。</p>
<p><code>(call/cc procedure)</code>
<code>(dynamic-wind in body out)</code></p>
<p><code>dynamic-wind</code> 还需要再思考清楚。</p>
<h3>5.7. Delayed Evaluation</h3>
<blockquote>
<p>The benefit of using <code>delay</code> and <code>force</code> is that some amount of computation might be avoided altogether if it is delayed until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or streams.</p>
</blockquote>
<h3>5.8. Multiple Values</h3>
<p><code>(call-with-values producer consumer)</code></p>
<h3>5.9. Eval</h3>
<blockquote>
<p>Scheme's <code>eval</code> procedure allows programmers to write programs that construct and evaluate other programs. This ability to do run-time meta programming should not be overused but is handy when needed.</p>
</blockquote>
<p><code>(eval obj environment)</code>
<code>(environment import-spec ...)</code></p>
<h2>6. Operations on objects</h2>
<blockquote>
<p>This chapter describes the operations on objects, including lists, numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations.</p>
</blockquote>
<h3>6.1. Constants and Quotation</h3>
<p><code>quote</code>, <code>quasiquote</code>, <code>unquote</code>, <code>unquote-splicing</code></p>
<h3>6.2. Generic Equivalence and Type Predicates</h3>
<blockquote>
<p><code>eq?</code> is most often used to compare symbols or to check for pointer equivalence of allocated objects</p>
</blockquote>
<p><code>eq?</code>, <code>eqv?</code>, <code>equal?</code> 三者的区别在于后者比前者能判断的更加广泛。</p>
<h3>6.3. Lists and Pairs</h3>
<p><code>(list '+)</code> 与 <code>(list +)</code> 的区别在于，第一个 list 包含的是符号 symbol +，而第二个 list 包含的是程序 procedure +。</p>
<p>也就是说， list 的内容可以包含任意类型的值，包括 procedure。</p>
<p>注意 <code>'(a b c)</code> 表示含有 symbol <code>a</code> 、 <code>b</code> 和 <code>c</code> 的 list，而不是一个叫 <code>(a b c)</code> 的 symbol。</p>
<h3>6.4. Numbers</h3>
<blockquote>
<p>Scheme numbers may be classified as integers, rational numbers, real numbers, or complex numbers. This classification is hierarchical, in that all integers are rational, all rational numbers are real, and all real numbers are complex.</p>
</blockquote>
<blockquote>
<p>A Scheme number may also be classified as exact or inexact, depending upon the quality of operations used to derive the number and the inputs to these operations.</p>
</blockquote>
<h3>6.5. Fixnums</h3>
<p>fixnum 指固定范围内的整数。</p>
<h3>6.6. Flonums</h3>
<h3>6.7. Characters</h3>
<h3>6.8. Strings</h3>
<h3>6.9. Vectors</h3>
<blockquote>
<p>Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time.</p>
</blockquote>
<h3>6.10. Bytevectors</h3>
<blockquote>
<p>Bytevectors are vectors of raw binary data.</p>
</blockquote>
<h3>6.11. Symbols</h3>
<blockquote>
<p>The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as identifiers in the representation of programs, allowing fast comparison of identifiers.</p>
</blockquote>
<h3>6.12. Booleans</h3>
<h3>6.13. Hashtables</h3>
<blockquote>
<p>Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose as association lists but are typically much faster when large numbers of associations are involved.</p>
</blockquote>
<h3>6.14. Enumerations</h3>
<h2>7. Input and Output</h2>
<blockquote>
<p>All input and output operations are performed through ports.</p>
</blockquote>
<blockquote>
<p>Ports are first-class objects, like any other object in Scheme.</p>
</blockquote>
<h3>7.1. Transcoders</h3>
<h3>7.2. Opening Files</h3>
<blockquote>
<p>It is perhaps easier to imagine that the default file options are the imaginary option symbols <code>create</code>, <code>fail-if-exists</code>, and <code>truncate</code>; <code>no-create</code> removes <code>create</code>, <code>no-fail</code> removes <code>fail-if-exists</code>, and <code>no-truncate</code> removes <code>truncate</code>.</p>
</blockquote>
<h3>7.3. Standard Ports</h3>
<h3>7.4. String and Bytevector Ports</h3>
<h3>7.5. Opening Custom Ports</h3>
<h3>7.6. Port Operations</h3>
<h3>7.7. Input Operations</h3>
<h3>7.8. Output Operations</h3>
<h3>7.9. Convenience I/O</h3>
<h3>7.10. Filesystem Operations</h3>
<h3>7.11. Bytevector/String Conversions</h3>
<h2>8. Syntactic Extension</h2>
<blockquote>
<p>Syntactic extensions, or macros, are used to simplify and regularize repeated patterns in a program, to introduce syntactic forms with new evaluation rules, and to perform transformations that help make programs more efficient.</p>
</blockquote>
<blockquote>
<p>Syntactic extensions are expanded into core forms at the start of evaluation (before compilation or interpretation) by a syntax expander.</p>
</blockquote>
<h3>8.1. Keyword Bindings</h3>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> keyword expr)
(<span class="hljs-name"><span class="hljs-builtin-name">let-syntax</span></span> ((<span class="hljs-name">keyword</span> expr) ...) form1 form2 ...)
(<span class="hljs-name"><span class="hljs-builtin-name">letrec-syntax</span></span> ((<span class="hljs-name">keyword</span> expr) ...) form1 form2 ...)
</code></pre>
<h3>8.2. Syntax-Rules Transformers</h3>
<blockquote>
<p>P is of the form (P1 ... Pn) and F is a list of n elements that match P1 through Pn</p>
</blockquote>
<p>上面一句话的意思如果模式 P 是 <code>(p1 p2 p3 p4)</code> 这样子的格式的话，则 F 也必须是包含 4 个元素的列表。这里的 <code>...</code> 表示的是确定的指定了 n 个子模式。而不是在模式出现 <code>...</code> 这个标识符。表示模式中出现 <code>...</code> 标识符是通过下面中提到的标识符 <code>ellipsis</code> 来指代的。注意这里容易造成混淆。</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> <span class="hljs-literal">#f</span>])
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">t</span> <span class="hljs-symbol">'okay</span>])
    (<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> if t)))
</code></pre>
<p>扩展为：</p>
<pre><code class="language-scheme">((<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (if1)
   ((<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (t1)
      ((<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (t2)
         (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> t2 t2 t1))
       if1))
    <span class="hljs-symbol">'okay</span>))
 <span class="hljs-literal">#f</span>)
</code></pre>
<h3>8.3. Syntax-Case Transformers</h3>
<blockquote>
<p>With this mechanism (<code>syntax-case</code>), transformers are procedures of one argument. The argument is a syntax object representing the form to be processed. The return value is a syntax object representing the output form. A syntax object may be any of the following.</p>
</blockquote>
<blockquote>
<p><code>#'template</code> is equivalent to <code>(syntax template)</code>. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.</p>
</blockquote>
<blockquote>
<p>Syntactic extensions ordinarily take the form <code>(keyword subform ...)</code>, but the <code>syntax-case</code> system permits them to take the form of singleton identifiers as well.</p>
</blockquote>
<p><code>(with-syntax ((pattern expr) ...) body1 body2 ...)</code></p>
<p>理解：这里理解的重点是 <code>pattern</code>，其实和 <code>syntax-case</code> 中的 <code>pattern</code> 一致。用于解构 <code>expr</code> 的值。且看下面的示例：</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> lab
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
    (<span class="hljs-name"><span class="hljs-builtin-name">syntax-case</span></span> x ()
      [(<span class="hljs-name">_</span> e1 e2)
       (<span class="hljs-name"><span class="hljs-builtin-name">with-syntax</span></span> ([(<span class="hljs-name">_</span> x1 x2) #<span class="hljs-symbol">'e1</span>]
                     [(<span class="hljs-name">_</span> y1 y2) #<span class="hljs-symbol">'e2</span>])
         #'(+ x1 x2 y1 y2))])))
</code></pre>
<blockquote>
<p><code>quasisyntax</code> can be used in place of <code>with-syntax</code> in many cases.</p>
</blockquote>
<p>值得思考 <code>(datum-&gt;syntax template-identifier obj)</code> 的作用。</p>
<p>关于本章的语法扩展问题，需要多思考作用域相关的问题。</p>
<h2>9. Records</h2>
<h3>9.1. Defining Records</h3>
<p>注意每次定义 record type ，即使名字一样，也是不同的。</p>
<h3>9.2. Procedural Interface</h3>
<h2>10. Libraries and Top-Level Programs</h2>
<p>学习 Scheme 库的建立。</p>
<h3>10.1. Standard Libraries</h3>
<h3>10.2. Defining New Libraries</h3>
<h3>10.3. Top-Level Programs</h3>
<blockquote>
<p>Top-level programs can be thought of as <code>library</code> forms without the library wrapper, library name, and export form.</p>
</blockquote>
<h2>11. Exceptions and Conditions</h2>
<blockquote>
<p>Exceptions and conditions provide the means for system and user code to signal, detect, and recover from errors that occur when a program is run.</p>
</blockquote>
<h3>11.1. Raising and Handling Exceptions</h3>
<h3>11.2. Defining Condition Types</h3>
<h3>11.3. Standard Condition Types</h3>
<h2>12. Extended Examples</h2>
<h3>12.1. Matrix and Vector Multiplication</h3>
<h3>12.2. Sorting</h3>
<h3>12.3. A Set Constructor</h3>
<h3>12.4. Word Frequency Counting</h3>
<h3>12.5. Scheme Printer</h3>
<h3>12.6. Formatted Output</h3>
<h2>总结</h2>
<p>重点是前三章的内容，值得多读几遍。另外第十二章的示例还差几个没有看完。其余章节都浏览了一遍。之后需要查阅相关的内容时，请在索引页面搜索。</p>
<h2>Exercise</h2>
<p>2.2.1</p>
<p>a. (+ (* 1.2 (- 2 1/3) -8.7))
b. (/ (+ 2/3 4/9) (- 5/11 -4/3))
c. (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 1/2)))))
d. (* 1 -2 3 -4 5 -6 7)</p>
<p>2.2.2</p>
<p>complex numbers
real numbers
rational numbers
integers</p>
<p>2.2.3</p>
<pre><code>a. (car cdr)
b. (this ((is silly)))
c. (is this silly?)
d. (+ 2 3)
e. (+ 2 3)
f. +
g. (2 3)
h. #&lt;procedure cons&gt;
i. cons
j. (quote cons)
k. quote
l. 5
m. 5
n. 5
o. 5
</code></pre>
<p>2.2.4</p>
<pre><code>(car (car '((a b) (c d)))) =&gt; a
(car (cdr (car '((a b) (c d))))) =&gt; b
(car (car (cdr '((a b) (c d))))) =&gt; c
(car (cdr (car (cdr '((a b) (c d)))))) =&gt; d
</code></pre>
<p>2.2.5</p>
<pre><code>'((a . b) ((c) d) ())
</code></pre>
<p>2.2.6</p>
<pre><code>(1 (2 (3)) (()) 4 . 5)
</code></pre>
<p>2.2.8</p>
<p>试着解释 Scheme 表达式是如何求值。</p>
<p>答：先递归求值每个操作数，然后将得到的值应用到操作符上。</p>
<p>2.3.1</p>
<pre><code>(cdr (list + - * /)) =&gt; (list - * /)
(car (list - * /)) =&gt; -
(- 17 5) =&gt; 12
</code></pre>
<p>2.4.1</p>
<p>a.</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x</span> (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> <span class="hljs-number">3</span> a)])
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">y1</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x b)]
        [<span class="hljs-name">y2</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x b)])
    (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> y1 y2)))
</code></pre>
<p>b.</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">ls</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> a b c)])
  (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x1</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls)]
        [<span class="hljs-name">x2</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls)])
    (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> x1 x2)))
</code></pre>
<p>2.4.3</p>
<p>a.</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x1</span> <span class="hljs-symbol">'a</span>] [<span class="hljs-name">y1</span> <span class="hljs-symbol">'b</span>])
  (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x2</span> <span class="hljs-symbol">'c</span>]) (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> x2 y1))
        (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">y2</span> <span class="hljs-symbol">'d</span>]) (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> x1 y2))))
</code></pre>
<p>b.</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x1</span> '((a b) c)])
  (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x2</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> x1)])
          (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> x2))
        (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x3</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> x1)])
          (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x4</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> x3)])
                  (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> x4))
                (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x5</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> x3)])
                        x5)
                      (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> x3))))))
</code></pre>
<p>2.5.1</p>
<p>a. 'a
b. '(a)
c. 'a
d. '()</p>
<p>2.5.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> list
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> <span class="hljs-name">ls</span> <span class="hljs-name">ls</span>))
</code></pre>
<p>2.5.3</p>
<p>a. empty
b. +
c. f
d. f, y
e. y</p>
<p>2.6.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> compose
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (p1 p2)
    (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
      (<span class="hljs-name">p1</span> (<span class="hljs-name">p2</span> x)))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cadr (<span class="hljs-name">compose</span> car cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cddr (<span class="hljs-name">compose</span> cdr cdr))
</code></pre>
<p>2.6.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caar (<span class="hljs-name">compose</span> car car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdar (<span class="hljs-name">compose</span> cdr car))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caaar (<span class="hljs-name">compose</span> caar car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caadr (<span class="hljs-name">compose</span> caar cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cadar (<span class="hljs-name">compose</span> cadr car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdaar (<span class="hljs-name">compose</span> cdar car))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdddr (<span class="hljs-name">compose</span> cddr cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cddar (<span class="hljs-name">compose</span> cddr car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdadr (<span class="hljs-name">compose</span> cdar cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caddr (<span class="hljs-name">compose</span> cadr cdr))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caaaar (<span class="hljs-name">compose</span> caaar car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caaadr (<span class="hljs-name">compose</span> caaar cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caadar (<span class="hljs-name">compose</span> caadr car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cadaar (<span class="hljs-name">compose</span> cadar car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdaaar (<span class="hljs-name">compose</span> cdaar car))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caaddr (<span class="hljs-name">compose</span> caadr cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cadadr (<span class="hljs-name">compose</span> cadar cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdaadr (<span class="hljs-name">compose</span> cdaar cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> caddar (<span class="hljs-name">compose</span> caddr car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdadar (<span class="hljs-name">compose</span> cdadr car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cddaar (<span class="hljs-name">compose</span> cddar car))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cddddr (<span class="hljs-name">compose</span> cdddr cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdddar (<span class="hljs-name">compose</span> cdddr car))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cddadr (<span class="hljs-name">compose</span> cddar cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cdaddr (<span class="hljs-name">compose</span> cdadr cdr))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> cadddr (<span class="hljs-name">compose</span> caddr cdr))
</code></pre>
<p>2.7.1</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> atom?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
    (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">pair?</span></span> x))))
</code></pre>
<p>2.7.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> shorter
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls1 ls2)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">length</span></span> ls2) (<span class="hljs-name"><span class="hljs-builtin-name">length</span></span> ls1))
        ls2
        ls1)))
</code></pre>
<p>2.8.1</p>
<p>交换 cons 的参数顺序将会导致复制的 tree 的每一个节点的子节点被调换。</p>
<p>2.8.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> make-list
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n obj)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>)
        '()
        (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> obj (<span class="hljs-name">make-list</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>) obj)))))
</code></pre>
<p>2.8.4</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> list-ref
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls idx)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> idx <span class="hljs-number">0</span>)
        (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls)
        (<span class="hljs-name"><span class="hljs-builtin-name">list-ref</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls) (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> idx <span class="hljs-number">1</span>)))))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> list-tail
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls idx)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> idx <span class="hljs-number">0</span>)
        ls
        (<span class="hljs-name"><span class="hljs-builtin-name">list-ref</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls) (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> idx <span class="hljs-number">1</span>)))))
</code></pre>
<p>2.8.5</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> shorter?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls1 ls2)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
      [(<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> ls1) <span class="hljs-literal">#t</span>]
      [(<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> ls2) <span class="hljs-literal">#f</span>]
      [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">shorter?</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls1) (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls2))])))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> shorter
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls1 ls2)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">shorter?</span> ls1 ls2)
        ls1
        ls2)))
</code></pre>
<p>2.8.6</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> odd?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>)
        <span class="hljs-literal">#f</span>
        (<span class="hljs-name"><span class="hljs-builtin-name">even?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)))))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> even?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>)
        <span class="hljs-literal">#t</span>
        (<span class="hljs-name"><span class="hljs-builtin-name">odd?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>)))))
</code></pre>
<p>2.8.7</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> transpose
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">left</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> car ls)]
          [<span class="hljs-name">right</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> cdr ls)])
      (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> left right))))
</code></pre>
<p>2.9.1</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> make-counter
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (init step)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">init</span> init])
      (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
        (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> init (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> init step))
        init))))
</code></pre>
<p>2.9.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> make-stack
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">ls</span> '()])
      (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (msg . args)
        (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> msg
          [(<span class="hljs-name">empty?</span>) (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> ls)]
          [(<span class="hljs-name">push!</span>) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> ls (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args) ls))]
          [(<span class="hljs-name">top</span>) (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls)]
          [(<span class="hljs-name">pop!</span>) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> ls (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls))]
          [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> <span class="hljs-string">"oops"</span>])))))
</code></pre>
<p>2.9.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> make-stack
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">ls</span> '()])
      (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (msg . args)
        (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> msg
          [(<span class="hljs-name">empty?</span>) (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> ls)]
          [(<span class="hljs-name">push!</span>) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> ls (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args) ls))]
          [(<span class="hljs-name">top</span>) (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls)]
          [(<span class="hljs-name">pop!</span>) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> ls (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls))]
          [(<span class="hljs-name">ref</span>) (<span class="hljs-name"><span class="hljs-builtin-name">list-ref</span></span> ls (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args))]
          [(<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span>) (<span class="hljs-name"><span class="hljs-builtin-name">set-car!</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list-tail</span></span> ls (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args))
                            (<span class="hljs-name"><span class="hljs-builtin-name">cadr</span></span> args))]
          [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> <span class="hljs-string">"oops"</span>])))))
</code></pre>
<p>2.9.4</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> make-stack
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name"><span class="hljs-builtin-name">vector</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">make-vector</span></span> n)]
          [<span class="hljs-name">at</span> <span class="hljs-number">0</span>])
      (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (msg . args)
        (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> msg
          [(<span class="hljs-name">empty?</span>) (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> at <span class="hljs-number">0</span>)]
          [(<span class="hljs-name">push!</span>) (<span class="hljs-name"><span class="hljs-builtin-name">begin</span></span>
                     (<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> vector at (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args))
                     (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> at (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> at <span class="hljs-number">1</span>)))]
          [(<span class="hljs-name">top</span>) (<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> vector (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> at <span class="hljs-number">1</span>))]
          [(<span class="hljs-name">pop!</span>) (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> at (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> at <span class="hljs-number">1</span>))]
          [(<span class="hljs-name">ref</span>)
           (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">idx</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> at <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args))])
             (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> idx <span class="hljs-number">0</span>)
                 (<span class="hljs-name">assertion-violation</span> <span class="hljs-symbol">'make-stack</span> <span class="hljs-string">"out of range."</span> idx)
                 (<span class="hljs-name"><span class="hljs-builtin-name">vector-ref</span></span> vector idx)))]
          [(<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span>)
           (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">idx</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> at <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args))])
             (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> idx <span class="hljs-number">0</span>)
                 (<span class="hljs-name">assertion-violation</span> <span class="hljs-symbol">'make-stack</span> <span class="hljs-string">"out of range."</span> idx)
                 (<span class="hljs-name"><span class="hljs-builtin-name">vector-set!</span></span> vector idx (<span class="hljs-name"><span class="hljs-builtin-name">cadr</span></span> args))))]
          [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> <span class="hljs-string">"oops"</span>])))))
</code></pre>
<p>2.9.5</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> make-queue
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">end</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-symbol">'ignored</span> '())])
      (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> end end))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> emptyq?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q)
    (<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> q) (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> q))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> putq!
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q v)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">end</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-symbol">'ignored</span> '())])
      (<span class="hljs-name"><span class="hljs-builtin-name">set-car!</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> q) v)
      (<span class="hljs-name"><span class="hljs-builtin-name">set-cdr!</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> q) end)
      (<span class="hljs-name"><span class="hljs-builtin-name">set-cdr!</span></span> q end))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> getq
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">emptyq?</span> q)
        (<span class="hljs-name">assertion-violation</span> <span class="hljs-symbol">'getq</span> <span class="hljs-string">"queue is empty"</span> q)
        (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> q)))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> delq!
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">emptyq?</span> q)
        (<span class="hljs-name">assertion-violation</span> delq <span class="hljs-string">"queue is empty"</span> q)
        (<span class="hljs-name"><span class="hljs-builtin-name">set-car!</span></span> q (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> q))))))
</code></pre>
<p>2.9.6</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> make-queue
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">end</span> '()])
      (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> end end))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> emptyq?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q)
    (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> q))
         (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> q)))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> putq!
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q v)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">tail</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> q)])
      (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> tail)
          (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">body</span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> v '())])
            (<span class="hljs-name"><span class="hljs-builtin-name">set-car!</span></span> q body)
            (<span class="hljs-name"><span class="hljs-builtin-name">set-cdr!</span></span> q body))
          (<span class="hljs-name"><span class="hljs-builtin-name">begin</span></span>
            (<span class="hljs-name"><span class="hljs-builtin-name">set-cdr!</span></span> tail (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> v '()))
            (<span class="hljs-name"><span class="hljs-builtin-name">set-cdr!</span></span> q (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> tail)))))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> getq
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">emptyq?</span> q)
        (<span class="hljs-name">assertion-violation</span> <span class="hljs-symbol">'getq</span> <span class="hljs-string">"queue is empty"</span> q)
        (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> q)))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> delq!
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (q)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
      [(<span class="hljs-name">emptyq?</span> q)
       (<span class="hljs-name">assertion-violation</span> delq <span class="hljs-string">"queue is empty"</span> q)]
      [(<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> q) (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> q))
       (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">empty</span> '()])
         (<span class="hljs-name"><span class="hljs-builtin-name">set-car!</span></span> q empty)
         (<span class="hljs-name"><span class="hljs-builtin-name">set-cdr!</span></span> q empty))]
      [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span>
       (<span class="hljs-name"><span class="hljs-builtin-name">set-car!</span></span> q (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> q)))])))
</code></pre>
<p>2.9.8</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> list?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
      [(<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> x) <span class="hljs-literal">#t</span>]
      [(<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">pair?</span></span> x)
            (<span class="hljs-name">have-cyclic?</span> x x)) <span class="hljs-literal">#f</span>]
      [(<span class="hljs-name"><span class="hljs-builtin-name">pair?</span></span> x) (<span class="hljs-name">list-help</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> x))]
      [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> <span class="hljs-literal">#f</span>])))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> list-help
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
      [(<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> x) <span class="hljs-literal">#t</span>]
      [(<span class="hljs-name"><span class="hljs-builtin-name">pair?</span></span> x) (<span class="hljs-name">list-help</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> x))]
      [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> <span class="hljs-literal">#f</span>])))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> have-cyclic?
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (hare tortoise)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
      [(<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">pair?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> hare))) <span class="hljs-literal">#f</span>]
      [(<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">pair?</span></span> (<span class="hljs-name">cddr</span> hare))) <span class="hljs-literal">#f</span>]
      [(<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> (<span class="hljs-name">cddr</span> hare) (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> tortoise)) <span class="hljs-literal">#t</span>]
      [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">have-cyclic?</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> hare)) (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> tortoise))])))
</code></pre>
<p>3.1.1</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x</span> (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> <span class="hljs-symbol">'a</span> ls)])
  (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> <span class="hljs-symbol">'b</span> x)))
<span class="hljs-comment">;; =&gt;</span>
((<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
   (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> <span class="hljs-symbol">'b</span> x)) <span class="hljs-literal">#f</span>))
 (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> <span class="hljs-symbol">'a</span> ls))
<span class="hljs-comment">;; =&gt;</span>
((<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
   (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> <span class="hljs-symbol">'b</span> x) <span class="hljs-literal">#f</span>))
 (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> <span class="hljs-symbol">'a</span> ls))
</code></pre>
<p>3.1.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> x '(a b c)) (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> x))
<span class="hljs-comment">;; =&gt;</span>
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> x '(a b c))
    (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> x '(a b c))
    (<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> x)))
<span class="hljs-comment">;; =&gt;</span>
(<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> x '(a b c))
    (<span class="hljs-name"><span class="hljs-builtin-name">memv</span></span> x '(a b c))
    (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> x))
</code></pre>
<p>3.1.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> let*
  (<span class="hljs-name"><span class="hljs-builtin-name">syntax-rules</span></span> ()
    [(<span class="hljs-name">_</span> () b1 b2 ...)
     (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> () b1 b2 ...)]
    [(<span class="hljs-name">_</span> ([<span class="hljs-name">x</span> e]) b1 b2 ...)
     (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x</span> e]) b1 b2 ...)]
    [(<span class="hljs-name">_</span> ([<span class="hljs-name">x1</span> e1] [<span class="hljs-name">x2</span> e2] ...) b1 b2 ...)
     (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">x1</span> e1])
       (<span class="hljs-name"><span class="hljs-builtin-name">let*</span></span> ([<span class="hljs-name">x2</span> e2] ...) b1 b2 ...))]))
</code></pre>
<p>3.1.4</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> when <span class="hljs-comment">;; 如果对</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">syntax-rules</span></span> ()
    [(<span class="hljs-name">_</span> test e1 e2 ...)
     (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> test
         (<span class="hljs-name"><span class="hljs-builtin-name">begin</span></span> e1 e2 ...)
         <span class="hljs-literal">#f</span>)]))
(<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> unless <span class="hljs-comment">;; 如果不对</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">syntax-rules</span></span> ()
    [(<span class="hljs-name">_</span> test e1 e2 ...)
     (<span class="hljs-name"><span class="hljs-builtin-name">when</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> test) e1 e2 ...)]))
</code></pre>
<p>3.2.2</p>
<p>the named <code>let</code>, beacuse it's more simple.</p>
<p>3.2.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> xxx ([<span class="hljs-name">t</span> <span class="hljs-symbol">'even?</span>] [<span class="hljs-name">x</span> <span class="hljs-number">20</span>])
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
    [(<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> t <span class="hljs-symbol">'even?</span>)
     (<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> x <span class="hljs-number">0</span>)
         (<span class="hljs-name">xxx</span> <span class="hljs-symbol">'odd?</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x <span class="hljs-number">1</span>)))]
    [(<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> t <span class="hljs-symbol">'odd?</span>)
     (<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> x <span class="hljs-number">0</span>))
          (<span class="hljs-name">xxx</span> <span class="hljs-symbol">'even?</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x <span class="hljs-number">1</span>)))]))
</code></pre>
<p>3.2.4</p>
<pre><code class="language-scheme">(<span class="hljs-name">fibonacci</span> <span class="hljs-number">40</span>)
</code></pre>
<p>1: 331160280次
2: 39次</p>
<p>3.2.5</p>
<pre><code class="language-scheme"><span class="hljs-comment">;; use set!</span>
(<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> let
  (<span class="hljs-name"><span class="hljs-builtin-name">syntax-rules</span></span> ()
    [(<span class="hljs-name">_</span> ((<span class="hljs-name">x</span> e) ...) b1 b2 ...)
     ((<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x ...) b1 b2 ...) e ...)]
    [(<span class="hljs-name">_</span> name ((<span class="hljs-name">x</span> e) ...) b1 b2 ...)
     (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">name</span> <span class="hljs-literal">#f</span>])
       (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> name (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x ...) b1 b2 ...))
       (<span class="hljs-name">name</span> e ...))]))
</code></pre>
<p>3.2.6</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> even? <span class="hljs-comment">; incorrect!</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">a</span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> x <span class="hljs-number">0</span>)])
      (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> a
          a
          (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">b</span> (<span class="hljs-name"><span class="hljs-builtin-name">odd?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x <span class="hljs-number">1</span>))])
            (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> b b <span class="hljs-literal">#f</span>))))))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> even? <span class="hljs-comment">; correct!</span>
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">a</span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> x <span class="hljs-number">0</span>)])
      (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> a
          a
          (<span class="hljs-name"><span class="hljs-builtin-name">odd?</span></span> (<span class="hljs-name">-x</span> <span class="hljs-number">1</span>))))))
</code></pre>
<p>注意它们的区别：每次调用 <code>even?</code> 就多了一层 <code>let</code> 和 <code>if</code></p>
<p>3.2.7</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> factor
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> f ([<span class="hljs-name">n</span> n] [<span class="hljs-name">i</span> <span class="hljs-number">3</span>])
      (<span class="hljs-name"><span class="hljs-builtin-name">let-values</span></span> ([(<span class="hljs-name">s</span> r) (<span class="hljs-name">exact-integer-sqrt</span> n)])
        (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
          [(<span class="hljs-name"><span class="hljs-builtin-name">&gt;=</span></span> i s) (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> n)]
          [(<span class="hljs-name"><span class="hljs-builtin-name">integer?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">/</span></span> n <span class="hljs-number">2</span>))
           (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> <span class="hljs-number">2</span> (<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-builtin-name">/</span></span> n <span class="hljs-number">2</span>) i))]
          [(<span class="hljs-name"><span class="hljs-builtin-name">integer?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">/</span></span> n i))
           (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> i (<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-builtin-name">/</span></span> n i) i))]
          [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">f</span> n (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> i <span class="hljs-number">1</span>))])))))
</code></pre>
<p>First is the most important problem to solve.</p>
<p>3.3.1</p>
<p>3.3.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> product
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> f ([<span class="hljs-name">ls</span> ls] [<span class="hljs-name">c</span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> () <span class="hljs-number">1</span>)])
      (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
        [(<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> ls) (<span class="hljs-name">c</span>)]
        [(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls) <span class="hljs-number">0</span>) <span class="hljs-number">0</span>]
        [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls) (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
                            (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls) (<span class="hljs-name">c</span>))))]))))
</code></pre>
<p>通过回调的形式返回。</p>
<p>3.3.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> exit (<span class="hljs-name"><span class="hljs-builtin-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (k) k)))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> quit
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> lwp-list)
        (<span class="hljs-name">exit</span> <span class="hljs-literal">#f</span>)
        (<span class="hljs-name">start</span>))))
</code></pre>
<p>关键是定义一个退出的 continuation。</p>
<p>3.3.4</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lwp-list (<span class="hljs-name">make-queue</span>))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> lwp
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (thunk)
    (<span class="hljs-name">putq!</span> lwp-list thunk)))
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> start
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> ()
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">p</span> (<span class="hljs-name">getq</span> lwp-list)])
      (<span class="hljs-name">delq!</span> lwp-list)
      (<span class="hljs-name">p</span>))))
</code></pre>
<p>3.3.5</p>
<p>3.4.1</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> reciprocal
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n success failure)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>)
        (<span class="hljs-name">failure</span>)
        (<span class="hljs-name">success</span> (<span class="hljs-name"><span class="hljs-builtin-name">/</span></span> <span class="hljs-number">1</span> n)))))
</code></pre>
<p>3.4.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> retry <span class="hljs-literal">#f</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> factorial
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x k)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> x <span class="hljs-number">0</span>)
        (<span class="hljs-name"><span class="hljs-builtin-name">begin</span></span>
          (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> retry k)
          (<span class="hljs-name">k</span> <span class="hljs-number">1</span>))
        (<span class="hljs-name">factorial</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> x <span class="hljs-number">1</span>)
                   (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n)
                     (<span class="hljs-name">k</span> (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> n x)))))))
</code></pre>
<p>3.4.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> reciprocals
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ls success failure)
    (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> map1 [(<span class="hljs-name">ls</span> ls) (<span class="hljs-name">ls2</span> '())]
      (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
        [(<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> ls)
         (<span class="hljs-name">success</span> (<span class="hljs-name"><span class="hljs-builtin-name">reverse</span></span> ls2))]
        [(<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls) <span class="hljs-number">0</span>)
         (<span class="hljs-name">failure</span> <span class="hljs-string">"zero found"</span>)]
        [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">map1</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> ls) (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> ls) ls2))]))))
</code></pre>
<p>3.5.1</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> complain
  (<span class="hljs-name"><span class="hljs-builtin-name">syntax-rules</span></span> ()
    [(<span class="hljs-name">_</span> ek msg expr)
     (<span class="hljs-name">ek</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> msg expr))]))
</code></pre>
<p>3.5.2</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> calc
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (expr)
    <span class="hljs-comment">; grab an error continuation ek</span>
    (<span class="hljs-name"><span class="hljs-builtin-name">call/cc</span></span>
     (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ek)
       (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> do-calc
         (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ek expr)
           (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
             [(<span class="hljs-name"><span class="hljs-builtin-name">number?</span></span> expr) expr]
             [(<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list?</span></span> expr) (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">length</span></span> expr) <span class="hljs-number">3</span>))
              (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">op</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> expr)] [<span class="hljs-name">args</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> expr)])
                (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> op
                  [(<span class="hljs-name">add</span>) (<span class="hljs-name">apply-op</span> ek + args)]
                  [(<span class="hljs-name">sub</span>) (<span class="hljs-name">apply-op</span> ek - args)]
                  [(<span class="hljs-name">mul</span>) (<span class="hljs-name">apply-op</span> ek * args)]
                  [(<span class="hljs-name">div</span>) (<span class="hljs-name">apply-op</span> ek / args)]
                  [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">complain</span> ek <span class="hljs-string">"invalid operator"</span> op)]))]
             [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">complain</span> ek <span class="hljs-string">"invalid expression"</span> expr)])))
       (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> apply-op
         (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ek op args)
           (<span class="hljs-name">op</span> (<span class="hljs-name">do-calc</span> ek (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args)) (<span class="hljs-name">do-calc</span> ek (<span class="hljs-name"><span class="hljs-builtin-name">cadr</span></span> args)))))
       (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> complain
         (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (ek msg expr)
           (<span class="hljs-name">ek</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> msg expr))))
       (<span class="hljs-name">do-calc</span> ek expr)))))
</code></pre>
<p>3.5.3</p>
<pre><code class="language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> calc <span class="hljs-literal">#f</span>)
(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ()
  (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> do-calc
    (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (expr)
      (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
        [(<span class="hljs-name"><span class="hljs-builtin-name">number?</span></span> expr) expr]
        [(<span class="hljs-name"><span class="hljs-builtin-name">and</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">list?</span></span> expr) (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">length</span></span> expr) <span class="hljs-number">3</span>))
         (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">op</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> expr)] [<span class="hljs-name">args</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> expr)])
           (<span class="hljs-name"><span class="hljs-builtin-name">case</span></span> op
             [(<span class="hljs-name">add</span>) (<span class="hljs-name">apply-op</span> + args)]
             [(<span class="hljs-name">sub</span>) (<span class="hljs-name">apply-op</span> - args)]
             [(<span class="hljs-name">mul</span>) (<span class="hljs-name">apply-op</span> * args)]
             [(<span class="hljs-name">div</span>) (<span class="hljs-name">apply-op</span> / args)]
             [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">assertion-violation</span> <span class="hljs-symbol">'do-calc</span> <span class="hljs-string">"invalid operator"</span> op)]))]
        [<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">assertion-violation</span> <span class="hljs-symbol">'do-calc</span> <span class="hljs-string">"invalid expression"</span> expr)])))
  (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> apply-op
    (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (op args)
      (<span class="hljs-name">op</span> (<span class="hljs-name">do-calc</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> args)) (<span class="hljs-name">do-calc</span> (<span class="hljs-name"><span class="hljs-builtin-name">cadr</span></span> args)))))
  (<span class="hljs-name"><span class="hljs-builtin-name">set!</span></span> calc do-calc))
</code></pre>
<p>3.5.4</p>
<pre><code class="language-scheme">...
       [(and (list? expr) (= (length expr) 2))
         (let ([op (car expr)] [arg (cadr expr)])
           (case op
             [(minus) (- (do-calc arg))]))]
...
</code></pre>
<p>3.6.1</p>
<pre><code class="language-scheme">  (<span class="hljs-name"><span class="hljs-builtin-name">define-syntax</span></span> gpa
    (<span class="hljs-name"><span class="hljs-builtin-name">syntax-rules</span></span> ()
      [(<span class="hljs-name">_</span> g1 g2 ...)
       (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ([<span class="hljs-name">ls</span> (<span class="hljs-name"><span class="hljs-builtin-name">map</span></span> letter-&gt;number
                      (<span class="hljs-name">filter</span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (g) (<span class="hljs-name"><span class="hljs-builtin-name">not</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> g <span class="hljs-symbol">'x</span>)))
                            '(g1 g2 ...)))])
         (<span class="hljs-name"><span class="hljs-builtin-name">/</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">apply</span></span> + ls) (<span class="hljs-name"><span class="hljs-builtin-name">length</span></span> ls)))]))
</code></pre>
<p>3.6.2</p>
<pre><code class="language-scheme">...
  define count
    (lambda (g0 ls)
      (length (filter (lambda (g) (eq? g g0))
                      ls))))
  (define gs '(a b c d f))

  (define-syntax distribution
    (syntax-rules ()
      [(_ g1 g2 ...)
       (let ([ls '(g1 g2 ...)])
         (map list (map (lambda (g0) (count g0 ls))
                        gs)
              gs))]))
...
</code></pre>
<p>3.6.3</p>
<pre><code class="language-scheme">...
  (define print-one
    (lambda (gn)
      (string-append
       "  "
       (symbol-&gt;string (cadr gn))
       ": "
       (make-string (car gn) #\*)
       "\n")))

  (define print
    (lambda (dist)
      (if (null? dist)
          ""
          (string-append (print-one (car dist))
                         (print (cdr dist))))))

  (define histogram
    (lambda (port dist)
      (put-string port "prints:\n")
      (put-string port
                  (print dist))))
...
</code></pre>
<p>12.2.1</p>
<p>使用 <code>(list (car ls))</code> 的原因是因为虽然此时 <code>n</code> 是 1，但是 <code>ls</code> 可能含有超过不只一个元素。如果直接返回 <code>ls</code>，就会导致结果不正确。</p>
<p>如果替换成 <code>(if (null? (cdr ls)) ls (list (car ls)))</code>，可以省去 <code>ls</code> 的初始长度那么多的空间。</p>
<p>12.2.2</p>
<p>假设有 <code>n</code> 个数字排列，则可以省略 <code>n</code> 个空间。</p>


</body>
</html>
